
//@version=6
strategy("DBO_Prod", shorttitle="DBO_Prod", overlay=true, calc_on_every_tick=true, process_orders_on_close=false, margin_long=0, margin_short=0)
import adam_overton/TradersPostDeluxe/11 as tp
 
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1) GLOBAL CONFIG
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string tzInput = input.string("America/Los_Angeles", "Time Zone", options = ["America/New_York", "America/Chicago", "America/Los_Angeles", "UTC", "Europe/London", "Asia/Tokyo"])
showPnLIndicators = input.string("Yes", "Show Profit/Loss Indicators", options=["Yes", "No"], group="Display Settings")
showDebugLabels = input.bool(true, "Show L1 Trade Labels", group="Display Settings")
// Add below existing Display Settings inputs
showOppositeDebugLabels = input.bool(false, "Show L2 Opposite Side and Sev 3 News Trade Labels", group="Display Settings")
// Low-level counter-change tracing (independent of high-level debug labels)
bool showLowLevelTrace = input.bool(false, "Show L3 Debug Low-Level Trace", group="Display Settings")
showVWAPComponents = input.bool(false, "Show VWAP Plot", group="Display Settings")

var bool resetTimes                     = true
var string rangeSetSnapshot             = "3:10"
var int rangeStart                      = na
var int rangeEnd                        = na
var int exitTime                        = na
var bool scoped_officialRangeStarted    = false
var int scoped_actualRangeStart         = na
var int lastEntryBar                    = -1
var bool sessionValid                   = true
string sessionInvalidReason             = ""
var bool issuedLongOrder                = false
var bool issuedShortOrder               = false
var bool drew                           = false
var bool sessionBlocked                 = false
var int  emergencyExitBar               = na
var bool emergencyExitSent              = false
var int lastIssuedTradeNumber           = 0
var float sessionPL_snapshot            = na
var int tradesToday_snapshot            = na
var table sessionTable                  = na
var int snapshotRangeStart              = na
var bool earlyExitFired                 = false
string vwapMode                         = "Session"
int vwapLen                             = 14
var int lastProfitLblBar                = na
var int lastExitEmitBar                 = na
var int lastCancelSweepBar              = na
var int cycleSide                       = 0
var int oppOutstanding                  = 0
var bool tradingHalted                  = false     // global: PL + Sev3 intraday halt state
var int  lastHaltInfoBar                = na        // L3 debug label throttle
var int  sev3ReleaseMs                  = na        // global Sev 3 resume time (ms from midnight, reused across UI elements)


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Recoup Pending & Gate (persistents)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var bool  oppPending     = false  // recoup pending latch (scheduled on base entry bar B)
var int   oppPendDir     = na     // +1 pending Long OppAdd, -1 pending Short OppAdd (opposite of base)
var int   oppPendFromBar = na     // bar_index of base entry (B)
var float oppPendClose   = na     // snapshot of B close for telemetry/labels
var float oppPendEntry   = na     // executed entry price snapshot at B (audit/confirmation)
var bool  oppAddGate     = false  // centralized OppAdd placement gate (AND this in placement condition)
var int   oppCancelCode  = na     // 0 none, 1 flip, 2 stop, 3 profit/flatten, 4 close_side_fail, 5 risk, 6 halt, 7 qty0, 8 session, 9 other

//debugging trade counting
// === TRACE: order counter ===
var int    lastIssuedTradeNumber_prev = lastIssuedTradeNumber
var string lastIssuedTradeNumber_reason = ""


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2) SINGLE SESSION INPUTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
riskDollars         = input.float(300.0, "Inital Trade Risk Dollars", tooltip="Initial Long and Short Risk Sizing")
maxDailyLoss        = input.float(1250, title="Max Daily Loss Limit (Caps Recoup Trade)", tooltip="Set to 0 for unlimited risk")
maxDailyProfit      = input.float(240, title="Max Daily Profit (Halt)", tooltip="Set to 0 to disable profit cap") 

int rangeEndHour        = input.int(3, "Range End Hour") 
int rangeEndMin         = input.int(34, "Range End Min")
int lookbackH           = input.int(4, "Lookback Hour") 
int lookbackM           = input.int(0, "Lookback Min")
int exitDurH            = input.int(9, "Exit Duration Hour")
int exitDurM            = input.int(35, "Exit Duration Min")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3.1) Entry/TP/SL and Opposite Trade Behavior (3-way)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
int tradeLimit          = input.int(3, "Max Set of Long+Short Orders", group="Trade Settings", tooltip="REMEMBER we will ALWAYS take the opposing trade, real # of trades could be 2x this number")
float tpRatio           = input.float(0.56, "TP Ratio", step=0.01,group="Trade Settings")
float entryOff          = input.float(12.0, "Entry Offset to enter trade", group="Trade Settings")
float stopOff           = input.float(2.0, "Stop Offset to enter trade", group="Trade Settings")
minimumOneContract  = input.bool(true, "Minimum One Contract", tooltip="Force at least one contract even if risk% yields 0", group="Trade Settings")

slType                  = input.string("RR", "Stop Loss Type", options=["RR","Points"], group="Trade Settings")
float rrRatio           = input.float(1.7, "SL:TP Ratio/R:R Inverted", group="Trade Settings")
float ptsSL             = input.float(14.0, "Stop Loss (pts)", group="Trade Settings")

//Yes these two things should be combined but I was being lazy
oppositeQtyMultiplier   = input.float(4.0, "Opposite Trade Quantity Multiplier", step=0.1, group="Recoup Trade Settings")
oppositeReissueEntryOffsetPts = input.float(-1, "Opposite Reissue Entry Offset (pts)", step=0.25, group="Recoup Trade Settings",  tooltip="Set -1 to match the existing entries. Note that it's entry offset (12) - stop offset (2), so a 10 would match")
oppositeTpOverride      = input.float(0.46, "Opposite Trade TP Override (-1 = default)", step=0.01, group="Recoup Trade Settings")
// Proxy routing for opposite reissue (e.g., MYM â†’ YM)
// >>> CHANGE: user control to scale OppAdd stop distance vs original bracket
float oppAddStopPct = input.float(80.0, "Opposite Add Stop % of Original", step = 1.0, minval = 1.0, maxval = 100.0, group = "Recoup Trade Settings")

useProxyRealtimeOnly    = input.bool(true, "Proxy Ticker (YM vs MYM) For Alerts (Realtime Only)", group="Recoup Trade Settings")
float proxyQtyMul       = input.float(0.10, "Proxy Qty Multiplier (YMâ‰ˆ10x MYM)", step=0.01, group="Recoup Trade Settings")
bool oppAddMinOneYM = input.bool(true, "Opposite Trade Minimun 1 contract (proxy only)", tooltip="Force at least one contract even if risk% yields 0, WARNING Could exceed risk", group="Recoup Trade Settings")  

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3) RISK / HALT / BEHAVIOR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
midpointStartTolerancePct = input.float(35.0, "Midpoint Start Proximity (%)", group="Quality Filters", minval = -1, maxval = 100,tooltip="-1 default to use global setting")
requireMidpointReturn = input.bool(true, "Require Midpoint Quality after Trade 1", group="Quality Filters")
earlyExitMinutes    = input.int(10, "Early Exit Minutes Before Session End", minval=0, tooltip="If we are green right before session then exit")

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4) QUALITY FILTERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
minRangePoints          = input.float(50, "Minimum Range Width (pts)", group="Quality Filters", tooltip="-1 default to disable")
maxRangePoints          = input.float(350, "Maximum Range Width (pts)", group="Quality Filters", tooltip="-1 default to disable")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4.3) News Filters (Severity 1/2/3)  // >>> CHANGE: replace Sev 3-only block with per-type, per-severity filters
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Build the session date string (inclusive end alignment from your range model)
// >>> CHANGE: use session date for all news checks (keeps prior behavior timing)
string sessionDateStr = str.tostring(year(rangeEnd, tzInput)) + "-" + str.tostring(month(rangeEnd, tzInput), "00") + "-" + str.tostring(dayofmonth(rangeEnd, tzInput), "00")

// â€”â€”â€” Inputs: grouped by Severity; per-type checkboxes alphabetized; unchecked = block day â€”â€”â€”
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// News Inputs (with tooltips: Checked vs Unchecked behavior)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â€”â€”â€” Inputs: grouped by Severity; per-type checkboxes alphabetized; unchecked = block day â€”â€”â€”
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// News Inputs (with tooltips: Checked vs Unchecked behavior)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool useSev3TimeWindow = input.bool(true, "News: Use Intraday Delay Mode (all severities)", group="News Controls")  // enable Sev3 intraday window mode
int sev3PostDelayMin = input.int(5, "News Post-Event Delay (minutes)-All Severity", minval=0, maxval=240, group="News Controls")  //    post-news delay minutes applies to all severties by default
useSev3Filter = input.bool(true, "News: Default Blocked (Severity 3) Filter", group="News: Severity 3", tooltip="Checked: include Severity 3 events in blocking. Unchecked: ignore Severity 3 events (per-type toggles below have no effect).")
allow_ADP_Non_Farm_Employment_Change = input.string("Inherit", "ADP Non-Farm Employment Change", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Business_Inventories_m_m = input.string("Inherit", "Business Inventories m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_CPI_y_y = input.string("Inherit", "CPI y/y", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Capacity_Utilization_Rate = input.string("Inherit", "Capacity Utilization Rate", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_FOMC_Statement = input.string("Inherit", "FOMC Statement", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_FOMC_Meeting_Minutes = input.string("Inherit", "FOMC Meeting Minutes", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
// allow_Final_GDP_q_q = input.string("Inherit", "Final GDP q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Final_GDP_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
allow_ISM_Manufacturing_PMI = input.string("Block entire day", "ISM Manufacturing PMI", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Backtesting showed to stay away Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_ISM_Services_PMI = input.string("Inherit", "ISM Services PMI", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Industrial_Production_m_m = input.string("Inherit", "Industrial Production m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_NAHB_Housing_Market_Index = input.string("Inherit", "NAHB Housing Market Index", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Philly_Fed_Manufacturing_Index = input.string("Inherit", "Philly Fed Manufacturing Index", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Futures_Contract_Roll_Over_Day = input.string("Inherit", "Futures Contract Roll Over Day", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Bank_Holiday = input.string("Block entire day", "Bank Holiday", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 3", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)

useSev2Filter = input.bool(false, "News: Severity 2 Prop Red Folder", group="News: Severity 2", tooltip="Checked: include Severity 2 events in blocking. Unchecked: ignore Severity 2 events (per-type toggles below have no effect).These are events that prop consider do not trade but have been profitable.")
allow_ADP_Weekly_Employment_Change = input.string("Inherit", "ADP Weekly Employment Change", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Employment_Cost_Index_q_q = input.string("Inherit", "Employment Cost Index q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Core_PCE_Price_Index_m_m = input.string("Inherit", "Core PCE Price Index m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Core_PPI_m_m = input.string("Inherit", "Core PPI m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Core_Retail_Sales_m_m = input.string("Inherit", "Core Retail Sales m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Federal_Funds_Rate = input.string("Inherit", "Federal Funds Rate", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_FOMC_Economic_Projections = input.string("Inherit", "FOMC Economic Projections", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_FOMC_Press_Conference = input.string("Inherit", "FOMC Press Conference", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_JOLTS_Job_Openings = input.string("Inherit", "JOLTS Job Openings", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Prelim_GDP_q_q = input.string("Inherit", "Prelim GDP q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Prelim_UoM_Consumer_Sentiment = input.string("Inherit", "Prelim UoM Consumer Sentiment", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Prelim_UoM_Inflation_Expectations = input.string("Inherit", "Prelim UoM Inflation Expectations", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Unemployment_Claims = input.string("Inherit", "Unemployment Claims", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 2", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox


useSev1Filter = input.bool(false, "News: Default Trade (Severity 1)", group="News: Severity 1", tooltip="Checked: include Severity 1 events in blocking. Unchecked: ignore Severity 1 events (per-type toggles below have no effect).")
// allow_Advance_GDP_q_q = input.string("Inherit", "Advance GDP q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Advance_GDP_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Average_Hourly_Earnings_m_m = input.string("Inherit", "Average Hourly Earnings m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Average_Hourly_Earnings_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
allow_CPI_m_m = input.string("Inherit", "CPI m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
allow_Core_CPI_m_m = input.string("Inherit", "Core CPI m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸ§ PATCH: per-type policy dropdown replaces checkbox
// allow_Crude_Oil_Inventories = input.string("Inherit", "Crude Oil Inventories", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Crude_Oil_Inventories = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Existing_Home_Sales = input.string("Inherit", "Existing Home Sales", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Existing_Home_Sales = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Fed_Chair_Powell_Testifies = input.string("Inherit", "Fed Chair Testifies", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Fed_Chair_Powell_Testifies = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Fed_Chair_Powell_Speaks = input.string("Inherit", "Fed Chair Powell Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Fed_Chair_Powell_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Flash_Manufacturing_PMI = input.string("Inherit", "Flash Manufacturing PMI", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Flash_Manufacturing_PMI = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Flash_Services_PMI = input.string("Inherit", "Flash Services PMI", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Flash_Services_PMI = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Jackson_Hole_Symposium = input.string("Inherit", "Jackson Hole Symposium", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Jackson_Hole_Symposium = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Natural_Gas_Storage = input.string("Inherit", "Natural Gas Storage", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Natural_Gas_Storage = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Non_Farm_Employment_Change = input.string("Inherit", "Non-Farm Employment Change", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Non_Farm_Employment_Change = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_PPI_m_m = input.string("Inherit", "PPI m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_PPI_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Personal_Income_m_m = input.string("Inherit", "Personal Income m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Personal_Income_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Personal_Spending_m_m = input.string("Inherit", "Personal Spending m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Personal_Spending_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_President_Trump_Speaks = input.string("Inherit", "President Trump Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_President_Trump_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Retail_Sales_m_m = input.string("Inherit", "Retail Sales m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Retail_Sales_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Revised_UoM_Consumer_Sentiment = input.string("Inherit", "Revised UoM Consumer Sentiment", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Revised_UoM_Consumer_Sentiment = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Revised_UoM_Inflation_Expectations = input.string("Inherit", "Revised UoM Inflation Expectations", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Revised_UoM_Inflation_Expectations = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Unemployment_Rate = input.string("Inherit", "Unemployment Rate", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Unemployment_Rate = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_10_y_Bond_Auction = input.string("Inherit", "10-y Bond Auction", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_10_y_Bond_Auction = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_30_y_Bond_Auction = input.string("Inherit", "30-y Bond Auction", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_30_y_Bond_Auction = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_API_Weekly_Statistical_Bulletin = input.string("Inherit", "API Weekly Statistical Bulletin", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_API_Weekly_Statistical_Bulletin = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Advance_GDP_Price_Index_q_q = input.string("Inherit", "Advance GDP Price Index q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Advance_GDP_Price_Index_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Bank_Stress_Test_Results = input.string("Inherit", "Bank Stress Test Results", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Bank_Stress_Test_Results = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Beige_Book = input.string("Inherit", "Beige Book", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Beige_Book = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Building_Permits = input.string("Inherit", "Building Permits", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Building_Permits = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_CB_Consumer_Confidence = input.string("Inherit", "CB Consumer Confidence", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_CB_Consumer_Confidence = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_CB_Leading_Index_m_m = input.string("Inherit", "CB Leading Index m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_CB_Leading_Index_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Challenger_Job_Cuts_y_y = input.string("Inherit", "Challenger Job Cuts y/y", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Challenger_Job_Cuts_y_y = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Chicago_PMI = input.string("Inherit", "Chicago PMI", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Chicago_PMI = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Cleveland_Fed_Inflation_Expectations = input.string("Inherit", "Cleveland Fed Inflation Expectations", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Cleveland_Fed_Inflation_Expectations = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Construction_Spending_m_m = input.string("Inherit", "Construction Spending m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Construction_Spending_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Consumer_Credit_m_m = input.string("Inherit", "Consumer Credit m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Consumer_Credit_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Core_Durable_Goods_Orders_m_m = input.string("Inherit", "Core Durable Goods Orders m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Core_Durable_Goods_Orders_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Current_Account = input.string("Inherit", "Current Account", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Current_Account = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Daylight_Saving_Time_Shift = input.string("Inherit", "Daylight Saving Time Shift", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Daylight_Saving_Time_Shift = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Durable_Goods_Orders_m_m = input.string("Inherit", "Durable Goods Orders m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Durable_Goods_Orders_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Empire_State_Manufacturing_Index = input.string("Inherit", "Empire State Manufacturing Index", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Empire_State_Manufacturing_Index = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Financial_Stability_Report = input.string("Inherit", "FOMC Financial Stability Report", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Financial_Stability_Report = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Barkin_Speaks = input.string("Inherit", "FOMC Member Barkin Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Barkin_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Barr_Speaks = input.string("Inherit", "FOMC Member Barr Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Barr_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Bostic_Speaks = input.string("Inherit", "FOMC Member Bostic Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Bostic_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Bowman_Speaks = input.string("Inherit", "FOMC Member Bowman Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Bowman_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Collins_Speaks = input.string("Inherit", "FOMC Member Collins Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Collins_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Cook_Speaks = input.string("Inherit", "FOMC Member Cook Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Cook_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Daly_Speaks = input.string("Inherit", "FOMC Member Daly Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Daly_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Goolsbee_Speaks = input.string("Inherit", "FOMC Member Goolsbee Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Goolsbee_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Hammack_Speaks = input.string("Inherit", "FOMC Member Hammack Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Hammack_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Harker_Speaks = input.string("Inherit", "FOMC Member Harker Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Harker_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Jefferson_Speaks = input.string("Inherit", "FOMC Member Jefferson Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Jefferson_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Kashkari_Speaks = input.string("Inherit", "FOMC Member Kashkari Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Kashkari_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Kugler_Speaks = input.string("Inherit", "FOMC Member Kugler Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Kugler_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Logan_Speaks = input.string("Inherit", "FOMC Member Logan Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Logan_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Miran_Speaks = input.string("Inherit", "FOMC Member Miran Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Miran_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Musalem_Speaks = input.string("Inherit", "FOMC Member Musalem Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Musalem_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Paulson_Speaks = input.string("Inherit", "FOMC Member Paulson Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Paulson_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Schmid_Speaks = input.string("Inherit", "FOMC Member Schmid Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Schmid_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Waller_Speaks = input.string("Inherit", "FOMC Member Waller Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Waller_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_FOMC_Member_Williams_Speaks = input.string("Inherit", "FOMC Member Williams Speaks", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_FOMC_Member_Williams_Speaks = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Factory_Orders_m_m = input.string("Inherit", "Factory Orders m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Factory_Orders_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Fed_Monetary_Policy_Report = input.string("Inherit", "Fed Monetary Policy Report", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Fed_Monetary_Policy_Report = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Federal_Budget_Balance = input.string("Inherit", "Federal Budget Balance", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Federal_Budget_Balance = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Final_GDP_Price_Index_q_q = input.string("Inherit", "Final GDP Price Index q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Final_GDP_Price_Index_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Final_Manufacturing_PMI = input.string("Inherit", "Final Manufacturing PMI", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Final_Manufacturing_PMI = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Final_Services_PMI = input.string("Inherit", "Final Services PMI", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Final_Services_PMI = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Final_Wholesale_Inventories_m_m = input.string("Inherit", "Final Wholesale Inventories m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Final_Wholesale_Inventories_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Goods_Trade_Balance = input.string("Inherit", "Goods Trade Balance", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Goods_Trade_Balance = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_HPI_m_m = input.string("Inherit", "HPI m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_HPI_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Housing_Starts = input.string("Inherit", "Housing Starts", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Housing_Starts = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_ISM_Manufacturing_Prices = input.string("Inherit", "ISM Manufacturing Prices", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_ISM_Manufacturing_Prices = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Import_Prices_m_m = input.string("Inherit", "Import Prices m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Import_Prices_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Loan_Officer_Survey = input.string("Inherit", "Loan Officer Survey", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Loan_Officer_Survey = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Mortgage_Delinquencies = input.string("Inherit", "Mortgage Delinquencies", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Mortgage_Delinquencies = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_NFIB_Small_Business_Index = input.string("Inherit", "NFIB Small Business Index", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_NFIB_Small_Business_Index = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_New_Home_Sales = input.string("Inherit", "New Home Sales", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_New_Home_Sales = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Pending_Home_Sales_m_m = input.string("Inherit", "Pending Home Sales m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Pending_Home_Sales_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Prelim_Benchmark_Payrolls_Revision = input.string("Inherit", "Prelim Benchmark Payrolls Revision", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Prelim_Benchmark_Payrolls_Revision = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Prelim_GDP_Price_Index_q_q = input.string("Inherit", "Prelim GDP Price Index q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Prelim_GDP_Price_Index_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Prelim_Nonfarm_Productivity_q_q = input.string("Inherit", "Prelim Nonfarm Productivity q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Prelim_Nonfarm_Productivity_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Prelim_Unit_Labor_Costs_q_q = input.string("Inherit", "Prelim Unit Labor Costs q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Prelim_Unit_Labor_Costs_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Prelim_Wholesale_Inventories_m_m = input.string("Inherit", "Prelim Wholesale Inventories m/m", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Prelim_Wholesale_Inventories_m_m = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_RCM_TIPP_Economic_Optimism = input.string("Inherit", "RCM/TIPP Economic Optimism", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_RCM_TIPP_Economic_Optimism = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Revised_Nonfarm_Productivity_q_q = input.string("Inherit", "Revised Nonfarm Productivity q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Revised_Nonfarm_Productivity_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Revised_Unit_Labor_Costs_q_q = input.string("Inherit", "Revised Unit Labor Costs q/q", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Revised_Unit_Labor_Costs_q_q = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Richmond_Manufacturing_Index = input.string("Inherit", "Richmond Manufacturing Index", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Richmond_Manufacturing_Index = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_S_P_CS_Composite_20_HPI_y_y = input.string("Inherit", "S&P/CS Composite-20 HPI y/y", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_S_P_CS_Composite_20_HPI_y_y = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_TIC_Long_Term_Purchases = input.string("Inherit", "TIC Long-Term Purchases", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_TIC_Long_Term_Purchases = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Trade_Balance = input.string("Inherit", "Trade Balance", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Trade_Balance = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Treasury_Currency_Report = input.string("Inherit", "Treasury Currency Report", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Treasury_Currency_Report = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled
// allow_Wards_Total_Vehicle_Sales = input.string("Inherit", "Wards Total Vehicle Sales", options=["Inherit","Ignore","Delay then trade","Block entire day"], group="News: Severity 1", tooltip="Inherit=use severity toggle; Ignore=never block; Delay=block until event+delay; All-day=block full day.")  // ðŸŸª PATCH: Sev 1 inputs disabled (no matching events currently)
allow_Wards_Total_Vehicle_Sales = "Inherit"  // ðŸŸª PATCH: Sev 1 default policy while inputs are disabled

// â€”â€”â€” Stable TypeId map (0-based) used by the unified table â€”â€”â€”
// >>> CHANGE: Appended new types from authoritative severity list; preserved existing 0..32 IDs.
int TYPE_CPI_m_m = 0
int TYPE_CPI_y_y = 1
int TYPE_Core_CPI_m_m = 2
int TYPE_Core_PPI_m_m = 3
int TYPE_FOMC_Economic_Projections = 4
int TYPE_FOMC_Meeting_Minutes = 5
int TYPE_Federal_Funds_Rate = 6
int TYPE_ISM_Manufacturing_PMI = 7
int TYPE_ISM_Services_PMI = 8
int TYPE_Non_Farm_Employment_Change = 9
int TYPE_PPI_m_m = 10
int TYPE_President_Trump_Speaks = 11
int TYPE_Unemployment_Rate = 12
int TYPE_Core_PCE_Price_Index_m_m = 13
int TYPE_Core_Retail_Sales_m_m = 14
int TYPE_FOMC_Press_Conference = 15
int TYPE_FOMC_Statement = 16
int TYPE_Fed_Chair_Powell_Speaks = 17
int TYPE_Fed_Chair_Powell_Testifies = 18
int TYPE_Retail_Sales_m_m = 19
int TYPE_ADP_Non_Farm_Employment_Change = 20
int TYPE_Advance_GDP_q_q = 21
int TYPE_Average_Hourly_Earnings_m_m = 22
int TYPE_Employment_Cost_Index_q_q = 23
int TYPE_Final_GDP_q_q = 24
int TYPE_Flash_Manufacturing_PMI = 25
int TYPE_Flash_Services_PMI = 26
int TYPE_JOLTS_Job_Openings = 27
int TYPE_Jackson_Hole_Symposium = 28
int TYPE_Prelim_GDP_q_q = 29
int TYPE_Prelim_UoM_Consumer_Sentiment = 30
int TYPE_Prelim_UoM_Inflation_Expectations = 31
int TYPE_Unemployment_Claims = 32
int TYPE_Business_Inventories_m_m = 33
int TYPE_Capacity_Utilization_Rate = 34
int TYPE_Crude_Oil_Inventories = 35
int TYPE_Existing_Home_Sales = 36
int TYPE_Industrial_Production_m_m = 37
int TYPE_NAHB_Housing_Market_Index = 38
int TYPE_Natural_Gas_Storage = 39
int TYPE_Personal_Spending_m_m = 40
int TYPE_Personal_Income_m_m = 41
int TYPE_Philly_Fed_Manufacturing_Index = 42
int TYPE_Revised_UoM_Inflation_Expectations = 43
int TYPE_Revised_UoM_Consumer_Sentiment = 44
int TYPE_Futures_Contract_Roll_Over_Day = 45 
int TYPE_10_y_Bond_Auction = 46
int TYPE_30_y_Bond_Auction = 47
int TYPE_ADP_Weekly_Employment_Change = 48
int TYPE_API_Weekly_Statistical_Bulletin = 49
int TYPE_Advance_GDP_Price_Index_q_q = 50
int TYPE_Bank_Holiday = 51
int TYPE_Bank_Stress_Test_Results = 52
int TYPE_Beige_Book = 53
int TYPE_Building_Permits = 54
int TYPE_CB_Consumer_Confidence = 55
int TYPE_CB_Leading_Index_m_m = 56
int TYPE_Challenger_Job_Cuts_y_y = 57
int TYPE_Chicago_PMI = 58
int TYPE_Cleveland_Fed_Inflation_Expectations = 59
int TYPE_Construction_Spending_m_m = 60
int TYPE_Consumer_Credit_m_m = 61
int TYPE_Core_Durable_Goods_Orders_m_m = 62
int TYPE_Current_Account = 63
int TYPE_Daylight_Saving_Time_Shift = 64
int TYPE_Durable_Goods_Orders_m_m = 65
int TYPE_Empire_State_Manufacturing_Index = 66
int TYPE_FOMC_Financial_Stability_Report = 67
int TYPE_FOMC_Member_Barkin_Speaks = 68
int TYPE_FOMC_Member_Barr_Speaks = 69
int TYPE_FOMC_Member_Bostic_Speaks = 70
int TYPE_FOMC_Member_Bowman_Speaks = 71
int TYPE_FOMC_Member_Collins_Speaks = 72
int TYPE_FOMC_Member_Cook_Speaks = 73
int TYPE_FOMC_Member_Daly_Speaks = 74
int TYPE_FOMC_Member_Goolsbee_Speaks = 75
int TYPE_FOMC_Member_Hammack_Speaks = 76
int TYPE_FOMC_Member_Harker_Speaks = 77
int TYPE_FOMC_Member_Jefferson_Speaks = 78
int TYPE_FOMC_Member_Kashkari_Speaks = 79
int TYPE_FOMC_Member_Kugler_Speaks = 80
int TYPE_FOMC_Member_Logan_Speaks = 81
int TYPE_FOMC_Member_Miran_Speaks = 82
int TYPE_FOMC_Member_Musalem_Speaks = 83
int TYPE_FOMC_Member_Paulson_Speaks = 84
int TYPE_FOMC_Member_Schmid_Speaks = 85
int TYPE_FOMC_Member_Waller_Speaks = 86
int TYPE_FOMC_Member_Williams_Speaks = 87
int TYPE_Factory_Orders_m_m = 88
int TYPE_Fed_Monetary_Policy_Report = 89
int TYPE_Federal_Budget_Balance = 90
int TYPE_Final_GDP_Price_Index_q_q = 91
int TYPE_Final_Manufacturing_PMI = 92
int TYPE_Final_Services_PMI = 93
int TYPE_Final_Wholesale_Inventories_m_m = 94
int TYPE_Goods_Trade_Balance = 95
int TYPE_HPI_m_m = 96
int TYPE_Housing_Starts = 97
int TYPE_ISM_Manufacturing_Prices = 98
int TYPE_Import_Prices_m_m = 99
int TYPE_Loan_Officer_Survey = 100
int TYPE_Mortgage_Delinquencies = 101
int TYPE_NFIB_Small_Business_Index = 102
int TYPE_New_Home_Sales = 103
int TYPE_Pending_Home_Sales_m_m = 104
int TYPE_Prelim_Benchmark_Payrolls_Revision = 105
int TYPE_Prelim_GDP_Price_Index_q_q = 106
int TYPE_Prelim_Nonfarm_Productivity_q_q = 107
int TYPE_Prelim_Unit_Labor_Costs_q_q = 108
int TYPE_Prelim_Wholesale_Inventories_m_m = 109
int TYPE_RCM_TIPP_Economic_Optimism = 110
int TYPE_Revised_Nonfarm_Productivity_q_q = 111
int TYPE_Revised_Unit_Labor_Costs_q_q = 112
int TYPE_Richmond_Manufacturing_Index = 113
int TYPE_S_P_CS_Composite_20_HPI_y_y = 114
int TYPE_TIC_Long_Term_Purchases = 115
int TYPE_Trade_Balance = 116
int TYPE_Treasury_Currency_Report = 117
int TYPE_Wards_Total_Vehicle_Sales = 118


// â€”â€”â€” Unified event table (parallel arrays). Times kept for Stage-2 deferral. â€”â€”â€”
var arrDateStr = array.new_string()
var arrTimeMS = array.new_int()
var arrSeverity = array.new_int()
var arrTypeId = array.new_int()

// Per-type â€œAllow tradingâ€ lookup (index == TypeId)
var policyByTypeId = array.new_int()  // ðŸŸ§ PATCH: per-type policy (0=inherit,1=ignore,2=delay,3=all-day)
// >>> CHANGE: declare per-type severity map at top level (visible outside init block)
var typeSevByTypeId = array.new_int()
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŸ§ PATCH: Per-type policy encoding
// 0 Inherit (use severity toggle), 1 Ignore, 2 Delay then trade, 3 Block entire day
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
int POLICY_INHERIT = 0  // ðŸŸ§ PATCH
int POLICY_IGNORE = 1  // ðŸŸ§ PATCH
int POLICY_DELAY = 2  // ðŸŸ§ PATCH
int POLICY_ALLDAY = 3  // ðŸŸ§ PATCH

f_policyToInt(_p) =>
    int _v = POLICY_INHERIT
    if _p == "Ignore"
        _v := POLICY_IGNORE
    if _p == "Delay then trade"
        _v := POLICY_DELAY
    if _p == "Block entire day"
        _v := POLICY_ALLDAY
    _v



if bar_index == 0
    // Reset inits
    array.clear(arrDateStr)
    array.clear(arrTimeMS)
    array.clear(arrSeverity)
    array.clear(arrTypeId)
    array.clear(policyByTypeId)  // ðŸŸ§ PATCH

    // >>> CHANGE: BEGIN policyByTypeId pushes (neutral type names; indices unchanged)
    array.push(policyByTypeId, f_policyToInt(allow_CPI_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_CPI_y_y))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Core_CPI_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Core_PPI_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Economic_Projections))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Meeting_Minutes))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Federal_Funds_Rate))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_ISM_Manufacturing_PMI))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_ISM_Services_PMI))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Non_Farm_Employment_Change))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_PPI_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_President_Trump_Speaks))  // ðŸŸ§ PATCH         // was _Sev3
    array.push(policyByTypeId, f_policyToInt(allow_Unemployment_Rate))  // ðŸŸ§ PATCH              // was _Sev3
    array.push(policyByTypeId, f_policyToInt(allow_Core_PCE_Price_Index_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Core_Retail_Sales_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Press_Conference))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Statement))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Fed_Chair_Powell_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Fed_Chair_Powell_Testifies))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Retail_Sales_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_ADP_Non_Farm_Employment_Change))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Advance_GDP_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Average_Hourly_Earnings_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Employment_Cost_Index_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Final_GDP_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Flash_Manufacturing_PMI))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Flash_Services_PMI))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_JOLTS_Job_Openings))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Jackson_Hole_Symposium))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Prelim_GDP_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Prelim_UoM_Consumer_Sentiment))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Prelim_UoM_Inflation_Expectations))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Unemployment_Claims))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Business_Inventories_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Capacity_Utilization_Rate))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Crude_Oil_Inventories))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Existing_Home_Sales))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Industrial_Production_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_NAHB_Housing_Market_Index))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Natural_Gas_Storage))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Personal_Spending_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Personal_Income_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Philly_Fed_Manufacturing_Index))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Revised_UoM_Inflation_Expectations))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Revised_UoM_Consumer_Sentiment))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Futures_Contract_Roll_Over_Day))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_10_y_Bond_Auction))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_30_y_Bond_Auction))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_ADP_Weekly_Employment_Change))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_API_Weekly_Statistical_Bulletin))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Advance_GDP_Price_Index_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Bank_Holiday))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Bank_Stress_Test_Results))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Beige_Book))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Building_Permits))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_CB_Consumer_Confidence))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_CB_Leading_Index_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Challenger_Job_Cuts_y_y))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Chicago_PMI))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Cleveland_Fed_Inflation_Expectations))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Construction_Spending_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Consumer_Credit_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Core_Durable_Goods_Orders_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Current_Account))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Daylight_Saving_Time_Shift))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Durable_Goods_Orders_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Empire_State_Manufacturing_Index))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Financial_Stability_Report))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Barkin_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Barr_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Bostic_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Bowman_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Collins_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Cook_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Daly_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Goolsbee_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Hammack_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Harker_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Jefferson_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Kashkari_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Kugler_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Logan_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Miran_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Musalem_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Paulson_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Schmid_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Waller_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_FOMC_Member_Williams_Speaks))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Factory_Orders_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Fed_Monetary_Policy_Report))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Federal_Budget_Balance))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Final_GDP_Price_Index_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Final_Manufacturing_PMI))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Final_Services_PMI))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Final_Wholesale_Inventories_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Goods_Trade_Balance))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_HPI_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Housing_Starts))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_ISM_Manufacturing_Prices))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Import_Prices_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Loan_Officer_Survey))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Mortgage_Delinquencies))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_NFIB_Small_Business_Index))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_New_Home_Sales))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Pending_Home_Sales_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Prelim_Benchmark_Payrolls_Revision))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Prelim_GDP_Price_Index_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Prelim_Nonfarm_Productivity_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Prelim_Unit_Labor_Costs_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Prelim_Wholesale_Inventories_m_m))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_RCM_TIPP_Economic_Optimism))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Revised_Nonfarm_Productivity_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Revised_Unit_Labor_Costs_q_q))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Richmond_Manufacturing_Index))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_S_P_CS_Composite_20_HPI_y_y))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_TIC_Long_Term_Purchases))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Trade_Balance))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Treasury_Currency_Report))  // ðŸŸ§ PATCH
    array.push(policyByTypeId, f_policyToInt(allow_Wards_Total_Vehicle_Sales))  // ðŸŸ§ PATCH
    // >>> CHANGE: END policyByTypeId pushes

    // >>> CHANGE: BEGIN typeSevByTypeId (Type â†’ Severity map; indices 0..32 must match TypeId map)
    if array.size(typeSevByTypeId) == 0
        array.push(typeSevByTypeId, 3)  // 0  TYPE_CPI_m_m
        array.push(typeSevByTypeId, 3)  // 1  TYPE_CPI_y_y
        array.push(typeSevByTypeId, 3)  // 2  TYPE_Core_CPI_m_m
        array.push(typeSevByTypeId, 2)  // 3  TYPE_Core_PPI_m_m // >>> CHANGE: align with new Severity 1
        array.push(typeSevByTypeId, 2)  // 4  TYPE_FOMC_Economic_Projections // >>> CHANGE: align with new Severity 1
        array.push(typeSevByTypeId, 3)  // 5  TYPE_FOMC_Meeting_Minutes
        array.push(typeSevByTypeId, 2)  // 6  TYPE_Federal_Funds_Rate // >>> CHANGE: align with new Severity 1
        array.push(typeSevByTypeId, 3)  // 7  TYPE_ISM_Manufacturing_PMI
        array.push(typeSevByTypeId, 3)  // 8  TYPE_ISM_Services_PMI
        array.push(typeSevByTypeId, 1)  // 9  TYPE_Non_Farm_Employment_Change // >>> CHANGE: align with new Severity 1
        array.push(typeSevByTypeId, 1)  // 10 TYPE_PPI_m_m // >>> CHANGE: align with new Severity 1
        array.push(typeSevByTypeId, 1)  // 11 TYPE_President_Trump_Speaks
        array.push(typeSevByTypeId, 1)  // 12 TYPE_Unemployment_Rate
        array.push(typeSevByTypeId, 2)  // 13 TYPE_Core_PCE_Price_Index_m_m // >>> CHANGE: was 2 â†’ 1
        array.push(typeSevByTypeId, 2)  // 14 TYPE_Core_Retail_Sales_m_m // >>> CHANGE: was 2 â†’ 1
        array.push(typeSevByTypeId, 2)  // 15 TYPE_FOMC_Press_Conference // >>> CHANGE: align with new Severity 1
        array.push(typeSevByTypeId, 3)  // 16 TYPE_FOMC_Statement // >>> CHANGE: align with new Severity 2
        array.push(typeSevByTypeId, 1)  // 17 TYPE_Fed_Chair_Powell_Speaks // >>> CHANGE: was 2 â†’ 3
        array.push(typeSevByTypeId, 1)  // 18 TYPE_Fed_Chair_Powell_Testifies // >>> CHANGE: align with new Severity 1
        array.push(typeSevByTypeId, 1)  // 19 TYPE_Retail_Sales_m_m // >>> CHANGE: was 2 â†’ 1
        array.push(typeSevByTypeId, 3)  // 20 TYPE_ADP_Non_Farm_Employment_Change // >>> CHANGE: align with new Severity 3
        array.push(typeSevByTypeId, 1)  // 21 TYPE_Advance_GDP_q_q
        array.push(typeSevByTypeId, 1)  // 22 TYPE_Average_Hourly_Earnings_m_m
        array.push(typeSevByTypeId, 2)  // 23 TYPE_Employment_Cost_Index_q_q
        array.push(typeSevByTypeId, 1)  // 24 TYPE_Final_GDP_q_q
        array.push(typeSevByTypeId, 1)  // 25 TYPE_Flash_Manufacturing_PMI
        array.push(typeSevByTypeId, 1)  // 26 TYPE_Flash_Services_PMI
        array.push(typeSevByTypeId, 2)  // 27 TYPE_JOLTS_Job_Openings 
        array.push(typeSevByTypeId, 1)  // 28 TYPE_Jackson_Hole_Symposium
        array.push(typeSevByTypeId, 2)  // 29 TYPE_Prelim_GDP_q_q
        array.push(typeSevByTypeId, 2)  // 30 TYPE_Prelim_UoM_Consumer_Sentiment
        array.push(typeSevByTypeId, 2)  // 31 TYPE_Prelim_UoM_Inflation_Expectations
        array.push(typeSevByTypeId, 2)  // 32 TYPE_Unemployment_Claims // >>> CHANGE: align with new Severity 1
        // >>> CHANGE: appended new types 33..44 per authoritative list; IDs unchanged
        array.push(typeSevByTypeId, 3)  // 33 TYPE_Business_Inventories_m_m
        array.push(typeSevByTypeId, 3)  // 34 TYPE_Capacity_Utilization_Rate
        array.push(typeSevByTypeId, 1)  // 35 TYPE_Crude_Oil_Inventories
        array.push(typeSevByTypeId, 1)  // 36 TYPE_Existing_Home_Sales
        array.push(typeSevByTypeId, 3)  // 37 TYPE_Industrial_Production_m_m
        array.push(typeSevByTypeId, 3)  // 38 TYPE_NAHB_Housing_Market_Index
        array.push(typeSevByTypeId, 1)  // 39 TYPE_Natural_Gas_Storage
        array.push(typeSevByTypeId, 1)  // 40 TYPE_Personal_Spending_m_m
        array.push(typeSevByTypeId, 1)  // 41 TYPE_Personal_Income_m_m
        array.push(typeSevByTypeId, 3)  // 42 TYPE_Philly_Fed_Manufacturing_Index
        array.push(typeSevByTypeId, 1)  // 43 TYPE_Revised_UoM_Inflation_Expectations
        array.push(typeSevByTypeId, 1)  // 44 TYPE_Revised_UoM_Consumer_Sentiment
        array.push(typeSevByTypeId, 3)  // 45 TYPE_Futures_Contract_Roll_Over_Day
        array.push(typeSevByTypeId, 1)  // 46 TYPE_10_y_Bond_Auction
        array.push(typeSevByTypeId, 1)  // 47 TYPE_30_y_Bond_Auction
        array.push(typeSevByTypeId, 2)  // 48 TYPE_ADP_Weekly_Employment_Change
        array.push(typeSevByTypeId, 1)  // 49 TYPE_API_Weekly_Statistical_Bulletin
        array.push(typeSevByTypeId, 1)  // 50 TYPE_Advance_GDP_Price_Index_q_q
        array.push(typeSevByTypeId, 3)  // 51 TYPE_Bank_Holiday
        array.push(typeSevByTypeId, 1)  // 52 TYPE_Bank_Stress_Test_Results
        array.push(typeSevByTypeId, 1)  // 53 TYPE_Beige_Book
        array.push(typeSevByTypeId, 1)  // 54 TYPE_Building_Permits
        array.push(typeSevByTypeId, 1)  // 55 TYPE_CB_Consumer_Confidence
        array.push(typeSevByTypeId, 1)  // 56 TYPE_CB_Leading_Index_m_m
        array.push(typeSevByTypeId, 1)  // 57 TYPE_Challenger_Job_Cuts_y_y
        array.push(typeSevByTypeId, 1)  // 58 TYPE_Chicago_PMI
        array.push(typeSevByTypeId, 1)  // 59 TYPE_Cleveland_Fed_Inflation_Expectations
        array.push(typeSevByTypeId, 1)  // 60 TYPE_Construction_Spending_m_m
        array.push(typeSevByTypeId, 1)  // 61 TYPE_Consumer_Credit_m_m
        array.push(typeSevByTypeId, 1)  // 62 TYPE_Core_Durable_Goods_Orders_m_m
        array.push(typeSevByTypeId, 1)  // 63 TYPE_Current_Account
        array.push(typeSevByTypeId, 1)  // 64 TYPE_Daylight_Saving_Time_Shift
        array.push(typeSevByTypeId, 1)  // 65 TYPE_Durable_Goods_Orders_m_m
        array.push(typeSevByTypeId, 1)  // 66 TYPE_Empire_State_Manufacturing_Index
        array.push(typeSevByTypeId, 1)  // 67 TYPE_FOMC_Financial_Stability_Report
        array.push(typeSevByTypeId, 1)  // 68 TYPE_FOMC_Member_Barkin_Speaks
        array.push(typeSevByTypeId, 1)  // 69 TYPE_FOMC_Member_Barr_Speaks
        array.push(typeSevByTypeId, 1)  // 70 TYPE_FOMC_Member_Bostic_Speaks
        array.push(typeSevByTypeId, 1)  // 71 TYPE_FOMC_Member_Bowman_Speaks
        array.push(typeSevByTypeId, 1)  // 72 TYPE_FOMC_Member_Collins_Speaks
        array.push(typeSevByTypeId, 1)  // 73 TYPE_FOMC_Member_Cook_Speaks
        array.push(typeSevByTypeId, 1)  // 74 TYPE_FOMC_Member_Daly_Speaks
        array.push(typeSevByTypeId, 1)  // 75 TYPE_FOMC_Member_Goolsbee_Speaks
        array.push(typeSevByTypeId, 1)  // 76 TYPE_FOMC_Member_Hammack_Speaks
        array.push(typeSevByTypeId, 1)  // 77 TYPE_FOMC_Member_Harker_Speaks
        array.push(typeSevByTypeId, 1)  // 78 TYPE_FOMC_Member_Jefferson_Speaks
        array.push(typeSevByTypeId, 1)  // 79 TYPE_FOMC_Member_Kashkari_Speaks
        array.push(typeSevByTypeId, 1)  // 80 TYPE_FOMC_Member_Kugler_Speaks
        array.push(typeSevByTypeId, 1)  // 81 TYPE_FOMC_Member_Logan_Speaks
        array.push(typeSevByTypeId, 1)  // 82 TYPE_FOMC_Member_Miran_Speaks
        array.push(typeSevByTypeId, 1)  // 83 TYPE_FOMC_Member_Musalem_Speaks
        array.push(typeSevByTypeId, 1)  // 84 TYPE_FOMC_Member_Paulson_Speaks
        array.push(typeSevByTypeId, 1)  // 85 TYPE_FOMC_Member_Schmid_Speaks
        array.push(typeSevByTypeId, 1)  // 86 TYPE_FOMC_Member_Waller_Speaks
        array.push(typeSevByTypeId, 1)  // 87 TYPE_FOMC_Member_Williams_Speaks
        array.push(typeSevByTypeId, 1)  // 88 TYPE_Factory_Orders_m_m
        array.push(typeSevByTypeId, 1)  // 89 TYPE_Fed_Monetary_Policy_Report
        array.push(typeSevByTypeId, 1)  // 90 TYPE_Federal_Budget_Balance
        array.push(typeSevByTypeId, 1)  // 91 TYPE_Final_GDP_Price_Index_q_q
        array.push(typeSevByTypeId, 1)  // 92 TYPE_Final_Manufacturing_PMI
        array.push(typeSevByTypeId, 1)  // 93 TYPE_Final_Services_PMI
        array.push(typeSevByTypeId, 1)  // 94 TYPE_Final_Wholesale_Inventories_m_m
        array.push(typeSevByTypeId, 1)  // 95 TYPE_Goods_Trade_Balance
        array.push(typeSevByTypeId, 1)  // 96 TYPE_HPI_m_m
        array.push(typeSevByTypeId, 1)  // 97 TYPE_Housing_Starts
        array.push(typeSevByTypeId, 1)  // 98 TYPE_ISM_Manufacturing_Prices
        array.push(typeSevByTypeId, 1)  // 99 TYPE_Import_Prices_m_m
        array.push(typeSevByTypeId, 1)  // 100 TYPE_Loan_Officer_Survey
        array.push(typeSevByTypeId, 1)  // 101 TYPE_Mortgage_Delinquencies
        array.push(typeSevByTypeId, 1)  // 102 TYPE_NFIB_Small_Business_Index
        array.push(typeSevByTypeId, 1)  // 103 TYPE_New_Home_Sales
        array.push(typeSevByTypeId, 1)  // 104 TYPE_Pending_Home_Sales_m_m
        array.push(typeSevByTypeId, 1)  // 105 TYPE_Prelim_Benchmark_Payrolls_Revision
        array.push(typeSevByTypeId, 1)  // 106 TYPE_Prelim_GDP_Price_Index_q_q
        array.push(typeSevByTypeId, 1)  // 107 TYPE_Prelim_Nonfarm_Productivity_q_q
        array.push(typeSevByTypeId, 1)  // 108 TYPE_Prelim_Unit_Labor_Costs_q_q
        array.push(typeSevByTypeId, 1)  // 109 TYPE_Prelim_Wholesale_Inventories_m_m
        array.push(typeSevByTypeId, 1)  // 110 TYPE_RCM_TIPP_Economic_Optimism
        array.push(typeSevByTypeId, 1)  // 111 TYPE_Revised_Nonfarm_Productivity_q_q
        array.push(typeSevByTypeId, 1)  // 112 TYPE_Revised_Unit_Labor_Costs_q_q
        array.push(typeSevByTypeId, 1)  // 113 TYPE_Richmond_Manufacturing_Index
        array.push(typeSevByTypeId, 1)  // 114 TYPE_S_P_CS_Composite_20_HPI_y_y
        array.push(typeSevByTypeId, 1)  // 115 TYPE_TIC_Long_Term_Purchases
        array.push(typeSevByTypeId, 1)  // 116 TYPE_Trade_Balance
        array.push(typeSevByTypeId, 1)  // 117 TYPE_Treasury_Currency_Report
        array.push(typeSevByTypeId, 1)  // 118 TYPE_Wards_Total_Vehicle_Sales
    // >>> CHANGE: END typeSevByTypeId

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // NEWS ROWS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Futures Contract Roll Over Days â€” treat as Sev3, end-of-RTH (13:00 PT) so trade-after-news still blocks the whole session
    // 13:00 PT â†’ 46,800,000 ms from midnight
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 2025 roll dates (given): Mon Mar 17, Jun 16, Sep 15, Dec 15

if bar_index == 0
    //news contract rollover events
    array.push(arrDateStr, "2025-03-17")
    array.push(arrTimeMS, 46800000)
    array.push(arrTypeId, TYPE_Futures_Contract_Roll_Over_Day)  
    array.push(arrDateStr, "2025-06-16")
    array.push(arrTimeMS, 46800000)
    array.push(arrTypeId, TYPE_Futures_Contract_Roll_Over_Day) 
    array.push(arrDateStr, "2025-09-15")
    array.push(arrTimeMS, 46800000)
    array.push(arrTypeId, TYPE_Futures_Contract_Roll_Over_Day)  
    array.push(arrDateStr, "2025-12-15")
    array.push(arrTimeMS, 46800000)
    array.push(arrTypeId, TYPE_Futures_Contract_Roll_Over_Day) 

// ANCHOR (existing in 12-21 DBO):     // NEWS ROWS
// Generated from jul25jan26.csv â€” Sev2+Sev3 only; drops rows with 00:00 time (ForexFactory merged-time-cell artifacts)

if bar_index == 0
    // USD Bank Holiday rows â€” 2025 Jul
    array.push(arrDateStr, "2025-07-04") //adding as a do not trade day
    array.push(arrTimeMS, 10799000)
    array.push(arrTypeId, TYPE_Bank_Holiday)  // Bank Holiday
    array.push(arrDateStr, "2025-07-05")
    array.push(arrTimeMS, 10799000)
    array.push(arrTypeId, TYPE_Bank_Holiday)  // Bank Holiday
    array.push(arrDateStr, "2025-09-02")
    array.push(arrTimeMS, 10799000)
    array.push(arrTypeId, TYPE_Bank_Holiday)  // Bank Holiday
    array.push(arrDateStr, "2025-10-14")
    array.push(arrTimeMS, 10799000)
    array.push(arrTypeId, TYPE_Bank_Holiday)  // Bank Holiday
    array.push(arrDateStr, "2025-11-12")
    array.push(arrTimeMS, 7199000)
    array.push(arrTypeId, TYPE_Bank_Holiday)  // Bank Holiday
    array.push(arrDateStr, "2025-11-28")
    array.push(arrTimeMS, 7199000)
    array.push(arrTypeId, TYPE_Bank_Holiday)  // Bank Holiday

if bar_index == 0
    // CSV NEWS ROWS â€” Sev2+Sev3 only  // jul25jan26.csv
    array.push(arrDateStr, "2025-07-01")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Manufacturing_PMI)  // ISM Manufacturing PMI
    array.push(arrDateStr, "2025-07-01")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_JOLTS_Job_Openings)  // JOLTS Job Openings
    array.push(arrDateStr, "2025-07-02")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Non_Farm_Employment_Change)  // ADP Non-Farm Employment Change
    array.push(arrDateStr, "2025-07-03")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-07-03")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Services_PMI)  // ISM Services PMI
    array.push(arrDateStr, "2025-07-09")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Meeting_Minutes)  // FOMC Meeting Minutes
    array.push(arrDateStr, "2025-07-10")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-07-15")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_CPI_m_m)  // Core CPI m/m
    array.push(arrDateStr, "2025-07-15")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_m_m)  // CPI m/m
    array.push(arrDateStr, "2025-07-15")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_y_y)  // CPI y/y
    array.push(arrDateStr, "2025-07-16")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_PPI_m_m)  // Core PPI m/m
    array.push(arrDateStr, "2025-07-17")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_Retail_Sales_m_m)  // Core Retail Sales m/m
    array.push(arrDateStr, "2025-07-17")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-07-17")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Philly_Fed_Manufacturing_Index)  // Philly Fed Manufacturing Index
    array.push(arrDateStr, "2025-07-18")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Consumer_Sentiment)  // Prelim UoM Consumer Sentiment
    array.push(arrDateStr, "2025-07-18")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Inflation_Expectations)  // Prelim UoM Inflation Expectations
    array.push(arrDateStr, "2025-07-24")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-07-29")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_JOLTS_Job_Openings)  // JOLTS Job Openings
    array.push(arrDateStr, "2025-07-30")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Non_Farm_Employment_Change)  // ADP Non-Farm Employment Change
    array.push(arrDateStr, "2025-07-30")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_Federal_Funds_Rate)  // Federal Funds Rate
    array.push(arrDateStr, "2025-07-30")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Statement)  // FOMC Statement
    array.push(arrDateStr, "2025-07-30")
    array.push(arrTimeMS, 41400000)
    array.push(arrTypeId, TYPE_FOMC_Press_Conference)  // FOMC Press Conference
    array.push(arrDateStr, "2025-07-31")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-07-31")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_PCE_Price_Index_m_m)  // Core PCE Price Index m/m
    array.push(arrDateStr, "2025-07-31")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Employment_Cost_Index_q_q)  // Employment Cost Index q/q
    array.push(arrDateStr, "2025-08-01")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Manufacturing_PMI)  // ISM Manufacturing PMI
    array.push(arrDateStr, "2025-08-05")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Services_PMI)  // ISM Services PMI
    array.push(arrDateStr, "2025-08-07")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-08-12")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_CPI_m_m)  // Core CPI m/m
    array.push(arrDateStr, "2025-08-12")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_m_m)  // CPI m/m
    array.push(arrDateStr, "2025-08-12")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_y_y)  // CPI y/y
    array.push(arrDateStr, "2025-08-14")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-08-14")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_PPI_m_m)  // Core PPI m/m
    array.push(arrDateStr, "2025-08-15")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_Retail_Sales_m_m)  // Core Retail Sales m/m
    array.push(arrDateStr, "2025-08-15")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Consumer_Sentiment)  // Prelim UoM Consumer Sentiment
    array.push(arrDateStr, "2025-08-15")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Inflation_Expectations)  // Prelim UoM Inflation Expectations
    array.push(arrDateStr, "2025-08-20")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Meeting_Minutes)  // FOMC Meeting Minutes
    array.push(arrDateStr, "2025-08-21")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-08-21")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Philly_Fed_Manufacturing_Index)  // Philly Fed Manufacturing Index
    array.push(arrDateStr, "2025-08-28")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-08-29")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_PCE_Price_Index_m_m)  // Core PCE Price Index m/m
    array.push(arrDateStr, "2025-09-02")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Manufacturing_PMI)  // ISM Manufacturing PMI
    array.push(arrDateStr, "2025-09-03")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_JOLTS_Job_Openings)  // JOLTS Job Openings
    array.push(arrDateStr, "2025-09-04")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Non_Farm_Employment_Change)  // ADP Non-Farm Employment Change
    array.push(arrDateStr, "2025-09-04")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-09-04")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Services_PMI)  // ISM Services PMI
    array.push(arrDateStr, "2025-09-10")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_PPI_m_m)  // Core PPI m/m
    array.push(arrDateStr, "2025-09-11")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_y_y)  // CPI y/y
    array.push(arrDateStr, "2025-09-11")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-09-11")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_CPI_m_m)  // Core CPI m/m
    array.push(arrDateStr, "2025-09-11")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_m_m)  // CPI m/m
    array.push(arrDateStr, "2025-09-12")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Inflation_Expectations)  // Prelim UoM Inflation Expectations
    array.push(arrDateStr, "2025-09-12")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Consumer_Sentiment)  // Prelim UoM Consumer Sentiment
    array.push(arrDateStr, "2025-09-16")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_Retail_Sales_m_m)  // Core Retail Sales m/m
    array.push(arrDateStr, "2025-09-17")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_Federal_Funds_Rate)  // Federal Funds Rate
    array.push(arrDateStr, "2025-09-17")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Economic_Projections)  // FOMC Economic Projections
    array.push(arrDateStr, "2025-09-17")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Statement)  // FOMC Statement
    array.push(arrDateStr, "2025-09-17")
    array.push(arrTimeMS, 41400000)
    array.push(arrTypeId, TYPE_FOMC_Press_Conference)  // FOMC Press Conference
    array.push(arrDateStr, "2025-09-18")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Philly_Fed_Manufacturing_Index)  // Philly Fed Manufacturing Index
    array.push(arrDateStr, "2025-09-18")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-09-25")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-09-26")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_PCE_Price_Index_m_m)  // Core PCE Price Index m/m
    array.push(arrDateStr, "2025-09-30")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_JOLTS_Job_Openings)  // JOLTS Job Openings
    array.push(arrDateStr, "2025-10-01")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Non_Farm_Employment_Change)  // ADP Non-Farm Employment Change
    array.push(arrDateStr, "2025-10-01")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Manufacturing_PMI)  // ISM Manufacturing PMI
    array.push(arrDateStr, "2025-10-03")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Services_PMI)  // ISM Services PMI
    array.push(arrDateStr, "2025-10-08")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Meeting_Minutes)  // FOMC Meeting Minutes
    array.push(arrDateStr, "2025-10-10")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Inflation_Expectations)  // Prelim UoM Inflation Expectations
    array.push(arrDateStr, "2025-10-10")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Consumer_Sentiment)  // Prelim UoM Consumer Sentiment
    array.push(arrDateStr, "2025-10-16")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Philly_Fed_Manufacturing_Index)  // Philly Fed Manufacturing Index
    array.push(arrDateStr, "2025-10-24")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_CPI_m_m)  // Core CPI m/m
    array.push(arrDateStr, "2025-10-24")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_m_m)  // CPI m/m
    array.push(arrDateStr, "2025-10-24")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_y_y)  // CPI y/y
    array.push(arrDateStr, "2025-10-28")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ADP Weekly Employment Change
    array.push(arrDateStr, "2025-10-29")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_Federal_Funds_Rate)  // Federal Funds Rate
    array.push(arrDateStr, "2025-10-29")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Statement)  // FOMC Statement
    array.push(arrDateStr, "2025-10-29")
    array.push(arrTimeMS, 41400000)
    array.push(arrTypeId, TYPE_FOMC_Press_Conference)  // FOMC Press Conference
    array.push(arrDateStr, "2025-11-03")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Manufacturing_PMI)  // ISM Manufacturing PMI
    array.push(arrDateStr, "2025-11-05")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Non_Farm_Employment_Change)  // ADP Non-Farm Employment Change
    array.push(arrDateStr, "2025-11-05")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Services_PMI)  // ISM Services PMI
    array.push(arrDateStr, "2025-11-07")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Consumer_Sentiment)  // Prelim UoM Consumer Sentiment
    array.push(arrDateStr, "2025-11-07")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Inflation_Expectations)  // Prelim UoM Inflation Expectations
    array.push(arrDateStr, "2025-11-11")
    array.push(arrTimeMS, 19560000)
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ADP Weekly Employment Change
    array.push(arrDateStr, "2025-11-18")
    array.push(arrTimeMS, 600000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-11-18")
    array.push(arrTimeMS, 19740000)
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ADP Weekly Employment Change
    array.push(arrDateStr, "2025-11-19")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Meeting_Minutes)  // FOMC Meeting Minutes
    array.push(arrDateStr, "2025-11-20")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-11-20")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Philly_Fed_Manufacturing_Index)  // Philly Fed Manufacturing Index
    array.push(arrDateStr, "2025-11-25")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ADP Weekly Employment Change
    array.push(arrDateStr, "2025-11-25")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_PPI_m_m)  // Core PPI m/m
    array.push(arrDateStr, "2025-11-25")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_Retail_Sales_m_m)  // Core Retail Sales m/m
    array.push(arrDateStr, "2025-11-26")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-12-01")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Manufacturing_PMI)  // ISM Manufacturing PMI
    array.push(arrDateStr, "2025-12-03")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Non_Farm_Employment_Change)  // ADP Non-Farm Employment Change
    array.push(arrDateStr, "2025-12-03")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_ISM_Services_PMI)  // ISM Services PMI
    array.push(arrDateStr, "2025-12-04")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-12-05")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Core_PCE_Price_Index_m_m)  // Core PCE Price Index m/m
    array.push(arrDateStr, "2025-12-05")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Consumer_Sentiment)  // Prelim UoM Consumer Sentiment
    array.push(arrDateStr, "2025-12-05")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_Prelim_UoM_Inflation_Expectations)  // Prelim UoM Inflation Expectations
    array.push(arrDateStr, "2025-12-09")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ADP Weekly Employment Change
    array.push(arrDateStr, "2025-12-09")
    array.push(arrTimeMS, 25200000)
    array.push(arrTypeId, TYPE_JOLTS_Job_Openings)  // JOLTS Job Openings
    array.push(arrDateStr, "2025-12-10")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Employment_Cost_Index_q_q)  // Employment Cost Index q/q
    array.push(arrDateStr, "2025-12-10")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Statement)  // FOMC Statement
    array.push(arrDateStr, "2025-12-10")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_Federal_Funds_Rate)  // Federal Funds Rate
    array.push(arrDateStr, "2025-12-10")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Economic_Projections)  // FOMC Economic Projections
    array.push(arrDateStr, "2025-12-10")
    array.push(arrTimeMS, 41400000)
    array.push(arrTypeId, TYPE_FOMC_Press_Conference)  // FOMC Press Conference
    array.push(arrDateStr, "2025-12-11")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-12-16")
    array.push(arrTimeMS, 18900000)
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ADP Weekly Employment Change
    array.push(arrDateStr, "2025-12-16")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Core_Retail_Sales_m_m)  // Core Retail Sales m/m
    array.push(arrDateStr, "2025-12-18")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_CPI_y_y)  // CPI y/y
    array.push(arrDateStr, "2025-12-18")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-12-18")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Philly_Fed_Manufacturing_Index)  // Philly Fed Manufacturing Index
    array.push(arrDateStr, "2025-12-24")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims
    array.push(arrDateStr, "2025-12-30")
    array.push(arrTimeMS, 39600000)
    array.push(arrTypeId, TYPE_FOMC_Meeting_Minutes)  // FOMC Meeting Minutes
    array.push(arrDateStr, "2025-12-31")
    array.push(arrTimeMS, 19800000)
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // Unemployment Claims


// Jan 2026 â€” CSV NEWS ROWS â€” Sev2+Sev3 only  // jul25jan26.csv  // ðŸŸ§ PATCH
if bar_index == 0  // ðŸŸ§ PATCH
    array.push(arrDateStr, "2026-01-05")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 25200000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_ISM_Manufacturing_PMI)  // ðŸŸ§ PATCH: ISM Manufacturing PMI
    array.push(arrDateStr, "2026-01-06")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 25200000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_JOLTS_Job_Openings)  // ðŸŸ§ PATCH: JOLTS Job Openings
    array.push(arrDateStr, "2026-01-07")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 18900000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_ADP_Non_Farm_Employment_Change)  // ðŸŸ§ PATCH: ADP Non-Farm Employment Change
    array.push(arrDateStr, "2026-01-07")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 25200000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_ISM_Services_PMI)  // ðŸŸ§ PATCH: ISM Services PMI
    array.push(arrDateStr, "2026-01-08")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // ðŸŸ§ PATCH: Unemployment Claims
    array.push(arrDateStr, "2026-01-09")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 25200000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Prelim_UoM_Consumer_Sentiment)  // ðŸŸ§ PATCH: Prelim UoM Consumer Sentiment
    array.push(arrDateStr, "2026-01-09")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 25200000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Prelim_UoM_Inflation_Expectations)  // ðŸŸ§ PATCH: Prelim UoM Inflation Expectations
    array.push(arrDateStr, "2026-01-13")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 0)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ðŸŸ§ PATCH: ADP Weekly Employment Change
    array.push(arrDateStr, "2026-01-13")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Core_CPI_m_m)  // ðŸŸ§ PATCH: Core CPI m/m
    array.push(arrDateStr, "2026-01-13")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_CPI_m_m)  // ðŸŸ§ PATCH: CPI m/m
    array.push(arrDateStr, "2026-01-13")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_CPI_y_y)  // ðŸŸ§ PATCH: CPI y/y
    array.push(arrDateStr, "2026-01-14")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 1000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Core_PPI_m_m)  // ðŸŸ§ PATCH: Core PPI m/m
    array.push(arrDateStr, "2026-01-14")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Core_PPI_m_m)  // ðŸŸ§ PATCH: Core PPI m/m
    array.push(arrDateStr, "2026-01-15")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Core_Retail_Sales_m_m)  // ðŸŸ§ PATCH: Core Retail Sales m/m
    array.push(arrDateStr, "2026-01-15")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // ðŸŸ§ PATCH: Unemployment Claims
    array.push(arrDateStr, "2026-01-15")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Philly_Fed_Manufacturing_Index)  // ðŸŸ§ PATCH: Philly Fed Manufacturing Index
    array.push(arrDateStr, "2026-01-20")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 0)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ðŸŸ§ PATCH: ADP Weekly Employment Change
    array.push(arrDateStr, "2026-01-22")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // ðŸŸ§ PATCH: Unemployment Claims
    array.push(arrDateStr, "2026-01-27")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 0)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_ADP_Weekly_Employment_Change)  // ðŸŸ§ PATCH: ADP Weekly Employment Change
    array.push(arrDateStr, "2026-01-28")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 39600000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Federal_Funds_Rate)  // ðŸŸ§ PATCH: Federal Funds Rate
    array.push(arrDateStr, "2026-01-28")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 39600000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_FOMC_Statement)  // ðŸŸ§ PATCH: FOMC Statement
    array.push(arrDateStr, "2026-01-28")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 41400000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_FOMC_Press_Conference)  // ðŸŸ§ PATCH: FOMC Press Conference
    array.push(arrDateStr, "2026-01-29")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Core_PCE_Price_Index_m_m)  // ðŸŸ§ PATCH: Core PCE Price Index m/m
    array.push(arrDateStr, "2026-01-29")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Unemployment_Claims)  // ðŸŸ§ PATCH: Unemployment Claims
    array.push(arrDateStr, "2026-01-30")  // ðŸŸ§ PATCH
    array.push(arrTimeMS, 19800000)  // ðŸŸ§ PATCH
    array.push(arrTypeId, TYPE_Core_PPI_m_m)  // ðŸŸ§ PATCH: Core PPI m/m

// â€”â€”â€” Evaluate today's news to set sev3Blocked (no labels here) â€”â€”â€”
bool _hasAnyBlockingToday = false  // ðŸŸ§ PATCH: any blocking event today (all severities)
bool _hasAllDayBlockingToday = false  // ðŸŸ§ PATCH: any policy "Block entire day" event today
bool _hasTimedBlockingToday = false  // ðŸŸ§ PATCH: any timed block with valid time today (inherit/delay)
int _lastBlockMsToday = 0  // ðŸŸ§ PATCH: latest blocking event time (ms from midnight), timed-only
int _N = array.size(arrDateStr)
for _i = 0 to _N - 1
    string _d = array.get(arrDateStr, _i)
    bool _isToday = _d == sessionDateStr
    if _isToday
        int _tid = array.get(arrTypeId, _i)
        int _sev = array.get(typeSevByTypeId, _tid)
        int _pol = array.get(policyByTypeId, _tid)
        bool _sevEnabled = (_sev == 3 and useSev3Filter) or (_sev == 2 and useSev2Filter) or (_sev == 1 and useSev1Filter)
        bool _blocks = false
        bool _allDay = false
        bool _timed = false
        if _pol == POLICY_ALLDAY
            _blocks := true
            _allDay := true
        if _pol == POLICY_DELAY
            _blocks := true
            _timed := true
        if _pol == POLICY_INHERIT
            _blocks := _sevEnabled
            _timed := _sevEnabled
        if _blocks
            _hasAnyBlockingToday := true
            if _allDay
                _hasAllDayBlockingToday := true
            else
                if useSev3TimeWindow and _timed
                    int _tMs = array.get(arrTimeMS, _i)
                    bool _timeValid = _tMs > 0 and _tMs < 86400000
                    if _timeValid
                        if not _hasTimedBlockingToday or _tMs > _lastBlockMsToday
                            _lastBlockMsToday := _tMs
                        _hasTimedBlockingToday := true

bool _timeBlockedNow = false  // ðŸŸ§ PATCH
if _hasAllDayBlockingToday
    _timeBlockedNow := true
else
    if useSev3TimeWindow
        if _hasTimedBlockingToday
            int _curMinutes = hour(time, tzInput) * 60 + minute(time, tzInput)
            int _curMs = _curMinutes * 60000
            int _delayMs = sev3PostDelayMin * 60000
            sev3ReleaseMs := _lastBlockMsToday + _delayMs
            _timeBlockedNow := _curMs < sev3ReleaseMs
        else
            if not na(sev3ReleaseMs)
                sev3ReleaseMs := na
            _timeBlockedNow := false
    else
        if not na(sev3ReleaseMs)
            sev3ReleaseMs := na
        _timeBlockedNow := _hasAnyBlockingToday

sev3Blocked = _timeBlockedNow  // ðŸŸ§ PATCH: sev3Blocked now reflects "newsBlockedNow" across all severities

// â”€â”€â”€ Session / Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool forceHistoricalOnly = input.bool(false, "Force Historical Only (override realtime)", group="Session/Mode")
bool realtimeEffective   = barstate.isrealtime and not forceHistoricalOnly

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5) FRESHNESS WATCHERS (rebuild window on TZ / input change)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// NEW: detect user TZ changes (string-safe) and trigger a window rebuild
var string _tzPrev = na
if na(_tzPrev)
    _tzPrev := tzInput
if tzInput != _tzPrev
    resetTimes := true
    _tzPrev := tzInput

// Rebuild window if key config flips mid-session (string/int/hash-safe)
var string _cfgUID = ""
string _cfgNow = str.format("{0}", tzInput)
if _cfgNow != _cfgUID
    resetTimes := true
    _cfgUID := _cfgNow

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 6) Internal State  LEVELS, TP & STOPS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// --- SNAPSHOTS (frozen at first breakout bar) ---
var bool   sessionSnapTaken = false
var bool   sessionValidFrozen = true
var string sessionInvalidReasonFrozen = ""

// declare each var separately
var float dayHigh = na
var float dayLow  = na
var bool placedTrades = false
// [NEW] Deferred re-arm flags after a profit when immediate midpoint-gated reissue fails
var bool rearmAfterProfitPending = false
var int  rearmEligibleFromBar    = na

longEntry   = dayHigh + entryOff
shortEntry  = dayLow  - entryOff
longStop    = dayLow  - stopOff
shortStop   = dayHigh + stopOff
rangeSize   = math.abs(longEntry - longStop)
tpSize       = rangeSize * tpRatio
longTP      = longEntry  + tpSize
shortTP     = shortEntry - tpSize
stopSize = switch slType
    "RR"     => tpSize * rrRatio
    "Points" => ptsSL
    => na


// â–º Opposite-side TP override flag
bool oppTPOverrideActive = oppositeTpOverride >= 0

// â”€â”€ SIZING SNAPSHOT (frozen at first breakout) â”€â”€
var bool  sizingSnapTaken = false
var float sLongEntry  = na
var float sShortEntry = na
var float sLongStop   = na
var float sShortStop  = na
var float sLongTP     = na
var float sShortTP    = na

bool doSizeSnap = not sizingSnapTaken and time[1] < rangeEnd and time >= rangeEnd and not na(dayHigh) and not na(dayLow) and dayHigh != dayLow
if doSizeSnap
    sLongEntry := longEntry
    sShortEntry := shortEntry
    sLongStop := longStop
    sShortStop := shortStop
    sLongTP := longTP
    sShortTP := shortTP
    sizingSnapTaken := true

float useLongEntry  = sizingSnapTaken ? sLongEntry  : longEntry
float useShortEntry = sizingSnapTaken ? sShortEntry : shortEntry
float useLongStop   = sizingSnapTaken ? sLongStop   : longStop
float useShortStop  = sizingSnapTaken ? sShortStop  : shortStop
float useLongTP     = sizingSnapTaken ? sLongTP     : longTP
float useShortTP    = sizingSnapTaken ? sShortTP    : shortTP

// â”€â”€ FROZEN Opposite-TP targets (session-stable) â”€â”€
float useOppMult    = oppTPOverrideActive ? oppositeTpOverride : tpRatio
float useRangeSize  = math.abs(useLongEntry - useLongStop)
float useTpSizeOpp  = useRangeSize * useOppMult
float useLongTPOpp  = useLongEntry + useTpSizeOpp
float useShortTPOpp = useShortEntry - useTpSizeOpp

// superseded by frozen useLongTPOpp/useShortTPOpp
rangeSize := rangeSize

// Working vars for scaled reissue (declare once; update with :=)
var bool   oppTPLineActive = false
var bool   oppTPLineIsLong = false
var float  oppTPLinePrice  = na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 7) ORDER HELPERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// "+/-HHMM" offset string for given tz at current bar date
f_tz_offset_str(_tz) =>
    int yy = year(time, _tz), mm = month(time, _tz), dd = dayofmonth(time, _tz)
    int locMid = timestamp(_tz, yy, mm, dd, 0, 0), utcMid = timestamp("UTC", yy, mm, dd, 0, 0)
    int offMin = int(math.round((locMid - utcMid) / 60000))
    int ah = math.abs(offMin) / 60, am = math.abs(offMin) % 60
    string sgn = offMin >= 0 ? "+" : "-"
    sgn + str.tostring(ah, "00") + str.tostring(am, "00")

// "YYYY-MM-DDTHH:MM:SSÂ±HHMM" using tzInput
f_iso_local(_t, _tz) =>
    string d = str.tostring(year(_t, _tz)) + "-" + str.tostring(month(_t, _tz), "00") + "-" + str.tostring(dayofmonth(_t, _tz), "00")
    string h = str.tostring(hour(_t, _tz), "00") + ":" + str.tostring(minute(_t, _tz), "00") + ":" + str.tostring(second(_t, _tz), "00")
    d + "T" + h + f_tz_offset_str(_tz)


// Atomic exit: cancel â†’ close â†’ emit (chart JSON + optional proxy JSON via new TradersPost API)
// Returns [didExit, proxySent]
f_exit_atomic(_reason, _comment, _price, _timeMS, _tz, _chartTkr, _proxyTkr, _emitLabel, _doCancelAllBefore, _thisEntryId, _thisExitId, _oppPrimaryId, _oppPrimaryExitId, _allowChartEmit, _allowProxyEmit) =>
    bool didExit = false
    bool proxySent = false
    bool inPosBefore = strategy.position_size != 0
    tp.ErrorResponse _exit_proxy    = tp.ErrorResponse.new()
    tp.ErrorResponse _cancelChart   = tp.ErrorResponse.new()
    tp.ErrorResponse _cancelProxy   = tp.ErrorResponse.new()
    tp.ErrorResponse _chartexit     = tp.ErrorResponse.new()



    if _doCancelAllBefore
        strategy.cancel_all()
    else
        if str.length(_thisEntryId) > 0
            strategy.cancel(_thisEntryId)
        if str.length(_thisExitId) > 0
            strategy.cancel(_thisExitId)
        if str.length(_oppPrimaryId) > 0
            strategy.cancel(_oppPrimaryId)
        if str.length(_oppPrimaryExitId) > 0
            strategy.cancel(_oppPrimaryExitId)

    if _doCancelAllBefore and str.length(_chartTkr) > 0
        _cancelChart := tp.SendAdvancedOrder(ticker = _chartTkr, orderType = tp.OrderType.market, action = tp.Action.exit, signalPrice = _price, cancel = true, comment = _reason + "|" + _comment)  
        log.info("CancelSweep â€¢ CHART â€¢ " + _chartTkr + " â€¢ " + _cancelChart.message)  
        
    if _doCancelAllBefore and useProxyRealtimeOnly and realtimeEffective and str.length(_proxyTkr) > 0 and _proxyTkr != _chartTkr
        _cancelProxy := tp.SendAdvancedOrder(ticker = _proxyTkr, orderType = tp.OrderType.market, action = tp.Action.exit, signalPrice = _price, cancel = true, comment = _reason + "|" + _comment)  
        log.info("CancelSweep â€¢ PROXY â€¢ " + _proxyTkr + " â€¢ " + _cancelProxy.message) 

    if inPosBefore
        strategy.close_all(comment = _comment)
        didExit := true

    bool sendChartExit = str.length(_chartTkr) > 0 and _allowChartEmit and (inPosBefore or not _doCancelAllBefore)  // only emit chart Exit JSON when in a pos, unless caller disables cancel-sweep (e.g. ProfitTP-Guard)
    bool sendProxyExit = useProxyRealtimeOnly and realtimeEffective and str.length(_proxyTkr) > 0 and _proxyTkr != _chartTkr and _allowProxyEmit and (inPosBefore or not _doCancelAllBefore)  // same gating for proxy Exit JSON; ProfitTP-Guard still allowed when flat

    if sendChartExit
        _chartexit := tp.SendAdvancedOrder(ticker = _chartTkr, orderType = tp.OrderType.market, action = tp.Action.exit, signalPrice = _price, cancel = true, comment = _reason + "|" + _comment)
        log.info("JSON Normal Output:\n" + _chartexit.message)

    if sendProxyExit
        _exit_proxy := tp.SendAdvancedOrder(ticker = _proxyTkr, orderType = tp.OrderType.market, action = tp.Action.exit, signalPrice = _price, cancel = true, comment = _reason + "|" + _comment)
        log.info("JSON Proxy Output:\n" + _exit_proxy.message)
        proxySent := true

    if _emitLabel and showDebugLabels and didExit
        label.new(bar_index, low - syminfo.mintick * 40, "Exit â€¢ " + _comment, style = label.style_label_down, color = color.new(color.green, 20), textcolor = color.white)


    // Test focus
    //  â€¢ Normal TP/SL (ProfitTP, EarlyExit, Emergency, EOS): first exit bar has inPosBefore=true â†’ CancelSweep + Exit JSON per symbol (no change).
    //  â€¢ EOS / emergency / cleanup on later bars: inPosBefore=false, _doCancelAllBefore=true â†’ only CancelSweep JSON per symbol (no extra Exit JSON).
    //  â€¢ ProfitTP-Guard: _doCancelAllBefore=false, chartTkr="", proxyTkr set â†’ proxy Exit JSON still emitted even when TV is flat.
    //  â€¢ Desync safety: leave live broker pos while TV flat â†’ EOS/Emergency continue to send CancelSweep JSON for both symbols each bar â‰¥ exitTime.

    [didExit, proxySent]



// Position Size Calculation
f_calcPositionSize(_entry, _stop) =>
    float priceDiff = math.abs(_entry - _stop)
    float tickCount = syminfo.mintick != 0 ? priceDiff / syminfo.mintick : priceDiff
    costPerContract = tickCount * syminfo.pointvalue
    bool isMicro = str.substring(syminfo.ticker, 0, 1) == "M"
    //made this change to be able to round up for YM, violates risk rules, but on a high probability trade.
    contractCount = isMicro ? math.floor(riskDollars / costPerContract) : math.round(riskDollars / costPerContract)
    if minimumOneContract and contractCount <= 0
        contractCount := 1
    contractCount


// Projected-risk helpers (qty Ã— |entry-stop| in ticks Ã— pointvalue), think about the risk we are about to take
// and abort if we are going to blow our daily lose limit. 
f_calcTradeRiskDollars(_entry, _stop, _qty) =>
    float priceDiff = math.abs(_entry - _stop), float ticks = syminfo.mintick != 0 ? priceDiff / syminfo.mintick : priceDiff, float riskPer = ticks * syminfo.pointvalue, float tot = riskPer * _qty, tot

f_projectedRiskOK(_entry, _stop, _qty, _curLossDollars) =>
    float addLoss = f_calcTradeRiskDollars(_entry, _stop, _qty), bool limitOff = maxDailyLoss <= 0, bool ok = limitOff or (_curLossDollars + addLoss <= maxDailyLoss), ok

// Centralized issuer for bracket alerts + local strategy orders (single source of truth)
f_issueBracket(id, dir, entry, stop, limit, qty, placeLocal, tkr) =>
    bool isLong = dir == strategy.long
    bool useStopEntry = not na(entry)
    tp_orderType = useStopEntry ? tp.OrderType.stop : tp.OrderType.market
    // --- NEW: Send TradersPost bracket (absolute TP/SL prices) ---
    _resp_b = tp.SendBracketOrder(ticker = tkr, action = (isLong ? tp.Action.buy : tp.Action.sell), quantity = qty, quantityType = tp.QuantityType.fixed, orderType = tp_orderType, entryPrice = (useStopEntry ? entry : na), takeProfitPrice = (not na(limit) ? limit : na), stopLossPrice = (not na(stop) ? stop : na), takeProfitAmount = na, stopLossAmount = na, stopLossType = tp.StopLossType.stop, signalPrice = close, comment = id)
    // --- NEW: JSON echo for observability (same style as exits) ---
    if qty > 0
        log.info("Entry Bracket JSON:\n" + _resp_b.message)
    if placeLocal and qty > 0
        strategy.entry(id, dir, stop = entry, qty = qty)
        strategy.exit(id + "_Exit", from_entry = id, stop = stop, limit = limit)
    placeLocal and qty > 0

f_placeBracket(id, dir, entry, stop, limit, tradesCount, alreadyIssued, rangeConfirmed, _curLossDollars) =>
    qty = f_calcPositionSize(entry, stop)
    bool orderPlaced = false
    bool issuedNow   = false
    bool allowByRisk = f_projectedRiskOK(entry, stop, qty, _curLossDollars)
    if qty > 0 and rangeConfirmed and allowByRisk
        if not alreadyIssued
            string labelText = "#" + str.tostring(tradesCount + 1) + " Orders Issued"
            if showDebugLabels
                label.new(x=bar_index, y=dayHigh + syminfo.mintick * 100, text=labelText, style=label.style_label_down, color=color.orange, textcolor=color.white)
            bool _placed = f_issueBracket(id, dir, entry, stop, limit, qty, true, syminfo.ticker)
            orderPlaced := _placed
        else
            orderPlaced := orderPlaced
    orderPlaced


// Centralized entry/exit with explicit qty (for proxy adds & special cases)
f_placeBracket_qty(id, dir, entry, stop, limit, qty) =>
    f_issueBracket(id, dir, entry, stop, limit, qty, true, syminfo.ticker)


isPriceInsideRange() =>
    close < useLongEntry and close > useShortEntry

// Build full-size contract from micro root (MESâ†’ES, MNQâ†’NQ, MYMâ†’YM); else return original
f_get_proxy_ticker(_base) =>
    string r3 = str.substring(_base, 0, 3)
    string out = (r3 == "MES" or r3 == "MNQ" or r3 == "MYM") ? str.substring(_base, 1, str.length(_base)) : _base
    out

// Send opposite entry on proxy symbol (full-size) with proper TP/SL objects
// NOTE: _qtyMicro is the intended MICRO-equivalent add; _qtyMul is the microâ†’full multiplier (e.g., 0.10)
f_send_opposite_on_proxy(_proxyTicker, _isLongOpp, _entry, _stop, _tp, _qtyMicro, _qtyMul, _blocked) =>
    int qFull = na
    int qMicro = na
    bool placed = false
    if not _blocked
        qFull := int(math.floor(_qtyMicro * _qtyMul))                                          //    base floor
        if oppAddMinOneYM and useProxyRealtimeOnly and realtimeEffective and _qtyMicro > 0    //    : toggle-guarded min-1 YM
            qFull := math.max(1, qFull)   
        qMicro := int(math.max(1, math.floor(_qtyMicro)))
        string sid = (_isLongOpp ? "OppAddL_" : "OppAddS_") + str.tostring(bar_index)
        if useProxyRealtimeOnly and realtimeEffective

            _ = f_issueBracket(sid, _isLongOpp ? strategy.long : strategy.short, _entry, _stop, _tp, qFull, false, _proxyTicker)
            placed :=  qFull > 0
        else
            bool _p = f_issueBracket(sid, _isLongOpp ? strategy.long : strategy.short, _entry, _stop, _tp, qMicro, true, syminfo.ticker)
            placed := _p
    placed


// â–º Compute ADDITIONAL full-size contracts needed so that TOTAL $ risk â‰ˆ (base_micro_risk Ã— targetMult).
// We leave the original micro bracket intact and only add the delta as a full-size order.
// Returns integer # of full-size contracts (>= 0). Uses current symbol's pointvalue for risk math.
f_calc_additional_proxy_qty(_entry, _stop, _targetMult, _ensureMin1) =>
    // Risk per 1 MICRO contract:
    float riskPerMicro = f_calcTradeRiskDollars(_entry, _stop, 1)
    // Base MICRO qty (what bracket sizing would choose now)
    float baseQtyMicro = f_calcPositionSize(_entry, _stop)
    // Base risk in $ actually represented by MICRO side:
    float baseRisk = riskPerMicro * baseQtyMicro
    // Target total risk:
    float targetRisk = baseRisk * _targetMult
    // Additional risk needed for target (if any):
    float addRisk = targetRisk - baseRisk
    // $ risk per ONE FULL-SIZE contract â‰ˆ riskPerMicro / proxyQtyMul (e.g., /0.10 = Ã—10)
    float riskPerFull = proxyQtyMul > 0 ? riskPerMicro / proxyQtyMul : na
    int qFull = addRisk > 0 and not na(riskPerFull) and riskPerFull > 0 ? int(math.floor(addRisk / riskPerFull)) : 0
    // Optionally enforce at least 1 full-size contract when addRisk > 0
    if _ensureMin1 and addRisk > 0 and qFull <= 0
        qFull := 1
    qFull

// â–º Compute ADDITIONAL MICRO contracts needed so TOTAL $ risk â‰ˆ (base_micro_risk Ã— targetMult).
// Returns integer # of micro contracts (>= 0). Does not quantize through full-size.
f_calc_additional_micro_qty(_entry, _stop, _targetMult, _ensureMin1) =>
    float riskPerMicro = f_calcTradeRiskDollars(_entry, _stop, 1)
    float baseQtyMicro = f_calcPositionSize(_entry, _stop)
    float baseRisk = riskPerMicro * baseQtyMicro
    float targetRisk = baseRisk * _targetMult
    float addRisk = targetRisk - baseRisk
    int qMicro = addRisk > 0 and riskPerMicro > 0 ? int(math.floor(addRisk / riskPerMicro)) : 0
    if _ensureMin1 and addRisk > 0 and qMicro <= 0
        qMicro := 1
    qMicro

// Tracks whether we issued a proxy (YM) add-on, so we can also exit it
var bool   proxyPosActive = false
var string proxyTickerPos = ""
var int    proxyPosDir    = 0     // +1 long, -1 short
var int    proxyPosQty    = 0     // full-size contracts requested



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 8) DST-SAFE WINDOW BUILDER (single 3:10 session)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Midnight-proof range window (Pine v6 standalone)
// Requirements in scope (types shown for clarity):
//   string tzInput
//   int    rangeEndHour, rangeEndMin
//   int    lookbackH, lookbackM, exitDurH, exitDurM
//   var int rangeStart = na, rangeEnd = na, exitTime = na
//   var bool resetTimes = false
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if resetTimes
    // If overrides not ready, keep previous window (prevents â€œepoch linesâ€)
    if na(rangeEndHour) or na(rangeEndMin)
        rangeEnd   := rangeEnd
        rangeStart := rangeStart
        exitTime   := exitTime
    else
        // Build today's end-of-range anchor in tzInput
        int yy = year(time, tzInput)
        int mm = month(time, tzInput)
        int dd = dayofmonth(time, tzInput)
        int nowH = hour(time, tzInput)
        int nowM = minute(time, tzInput)

        int baseEnd = timestamp(tzInput, yy, mm, dd, rangeEndHour, rangeEndMin)
        bool pastCut = nowH > rangeEndHour or (nowH == rangeEndHour and nowM >= rangeEndMin)

        // If weâ€™re already past the cut today, roll anchor to the next calendar day (DST-safe)
        if pastCut
            int ny = year(baseEnd + 86400000, tzInput)
            int nm = month(baseEnd + 86400000, tzInput)
            int nd = dayofmonth(baseEnd + 86400000, tzInput)
            baseEnd := timestamp(tzInput, ny, nm, nd, rangeEndHour, rangeEndMin)

        int lookbackMS = lookbackH * 3600000 + lookbackM * 60000
        int exitDurMS  = exitDurH * 3600000 + exitDurM * 60000

        rangeEnd   := baseEnd
        rangeStart := baseEnd - lookbackMS
        exitTime   := baseEnd + exitDurMS

        // Safety: ensure strictly increasing times even for 0h / 24h lookbacks
        if rangeStart >= rangeEnd
            rangeStart := rangeEnd - 60000

        // Commit window + clear reset flag atomically
        drew := false
        resetTimes := false


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 9) WINDOW FLAGS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool inDefine   = time >= rangeStart and time < rangeEnd
bool inBreakoutWindow = time >= rangeEnd and time < exitTime
// 9.1) Early-exit window flag (derived every bar)
int earlyMS = earlyExitMinutes * 60000
int earlyStart = exitTime - earlyMS
bool inEarlyWindow = not na(exitTime) and not na(earlyStart) and time >= earlyStart and time < exitTime

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 10) INDICATORS (compute every bar; no stateful calls in branches)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

float vwapSource = inDefine or inBreakoutWindow ? hlc3 : na
float sessionVWAP = ta.vwap(vwapSource)
float sessionVWMA = ta.vwma(close, vwapLen)
anchoredVWAP = vwapMode == "Session" ? (na(sessionVWAP) ? sessionVWMA : sessionVWAP) : sessionVWMA

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 11) QUALITY FILTERS EVAL (freeze once at first breakout)
// Spec: Freeze sessionValid + reason at first breakout
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool firstBreakoutBar = time[1] < rangeEnd and time >= rangeEnd
if firstBreakoutBar and not na(dayHigh) and not na(dayLow) and dayHigh != dayLow
    float _width = dayHigh - dayLow
    bool minOk = minRangePoints <= 0 or _width >= minRangePoints
    bool maxOk = maxRangePoints <= 0 or _width <= maxRangePoints

        // >>> CHANGE: single-pass news evaluation + detailed reasons (this replaces any earlier news loop)
    // ðŸŸ§ PATCH: Intraday Delay Mode applies across all severities; only "Block entire day" invalidates the session in that mode.
    string newsReasons = ""
    int newsMaxSev = 0
    int _Nn = array.size(arrDateStr)
    bool _invalidatingNewsToday = false

    for _i = 0 to _Nn - 1
        string _d = array.get(arrDateStr, _i)
        bool _isToday = _d == sessionDateStr
        if _isToday
            int _tid = array.get(arrTypeId, _i)
            int _sev = array.get(typeSevByTypeId, _tid)
            int _pol = array.get(policyByTypeId, _tid)
            bool _sevEnabled = (_sev == 3 and useSev3Filter) or (_sev == 2 and useSev2Filter) or (_sev == 1 and useSev1Filter)
            bool _blocks = false
            bool _allDay = false
            if _pol == POLICY_ALLDAY
                _blocks := true
                _allDay := true
            if _pol == POLICY_DELAY
                _blocks := true
            if _pol == POLICY_INHERIT
                _blocks := _sevEnabled
            bool _invalidate = false
            if _blocks
                if _allDay
                    _invalidate := true
                else
                    if not useSev3TimeWindow
                        _invalidate := true
            if _invalidate
                string _nm = switch _tid
                    TYPE_CPI_m_m => "CPI m/m"
                    TYPE_CPI_y_y => "CPI y/y"
                    TYPE_Core_CPI_m_m => "Core CPI m/m"
                    TYPE_Core_PPI_m_m => "Core PPI m/m"
                    TYPE_FOMC_Economic_Projections => "FOMC Economic Projections"
                    TYPE_FOMC_Meeting_Minutes => "FOMC Meeting Minutes"
                    TYPE_Federal_Funds_Rate => "Federal Funds Rate"
                    TYPE_ISM_Manufacturing_PMI => "ISM Manufacturing PMI"
                    TYPE_ISM_Services_PMI => "ISM Services PMI"
                    TYPE_Non_Farm_Employment_Change => "Non-Farm Employment Change"
                    TYPE_PPI_m_m => "PPI m/m"
                    TYPE_President_Trump_Speaks => "President Trump Speaks"
                    TYPE_Unemployment_Rate => "Unemployment Rate"
                    TYPE_Core_PCE_Price_Index_m_m => "Core PCE Price Index m/m"
                    TYPE_Core_Retail_Sales_m_m => "Core Retail Sales m/m"
                    TYPE_FOMC_Press_Conference => "FOMC Press Conference"
                    TYPE_FOMC_Statement => "FOMC Statement"
                    TYPE_Fed_Chair_Powell_Speaks => "Fed Chair Powell Speaks"
                    TYPE_Fed_Chair_Powell_Testifies => "Fed Chair Powell Testifies"
                    TYPE_Retail_Sales_m_m => "Retail Sales m/m"
                    TYPE_ADP_Non_Farm_Employment_Change => "ADP Non-Farm Employment Change"
                    TYPE_Advance_GDP_q_q => "Advance GDP q/q"
                    TYPE_Average_Hourly_Earnings_m_m => "Average Hourly Earnings m/m"
                    TYPE_Employment_Cost_Index_q_q => "Employment Cost Index q/q"
                    TYPE_Final_GDP_q_q => "Final GDP q/q"
                    TYPE_Flash_Manufacturing_PMI => "Flash Manufacturing PMI"
                    TYPE_Flash_Services_PMI => "Flash Services PMI"
                    TYPE_JOLTS_Job_Openings => "JOLTS Job Openings"
                    TYPE_Jackson_Hole_Symposium => "Jackson Hole Symposium"
                    TYPE_Prelim_GDP_q_q => "Prelim GDP q/q"
                    TYPE_Prelim_UoM_Consumer_Sentiment => "Prelim UoM Consumer Sentiment"
                    TYPE_Prelim_UoM_Inflation_Expectations => "Prelim UoM Inflation Expectations"
                    TYPE_Unemployment_Claims => "Unemployment Claims"
                    TYPE_10_y_Bond_Auction => "10-y Bond Auction"
                    TYPE_30_y_Bond_Auction => "30-y Bond Auction"
                    TYPE_ADP_Weekly_Employment_Change => "ADP Weekly Employment Change"
                    TYPE_API_Weekly_Statistical_Bulletin => "API Weekly Statistical Bulletin"
                    TYPE_Advance_GDP_Price_Index_q_q => "Advance GDP Price Index q/q"
                    TYPE_Bank_Holiday => "Bank Holiday"
                    TYPE_Bank_Stress_Test_Results => "Bank Stress Test Results"
                    TYPE_Beige_Book => "Beige Book"
                    TYPE_Building_Permits => "Building Permits"
                    TYPE_CB_Consumer_Confidence => "CB Consumer Confidence"
                    TYPE_CB_Leading_Index_m_m => "CB Leading Index m/m"
                    TYPE_Challenger_Job_Cuts_y_y => "Challenger Job Cuts y/y"
                    TYPE_Chicago_PMI => "Chicago PMI"
                    TYPE_Cleveland_Fed_Inflation_Expectations => "Cleveland Fed Inflation Expectations"
                    TYPE_Construction_Spending_m_m => "Construction Spending m/m"
                    TYPE_Consumer_Credit_m_m => "Consumer Credit m/m"
                    TYPE_Core_Durable_Goods_Orders_m_m => "Core Durable Goods Orders m/m"
                    TYPE_Current_Account => "Current Account"
                    TYPE_Daylight_Saving_Time_Shift => "Daylight Saving Time Shift"
                    TYPE_Durable_Goods_Orders_m_m => "Durable Goods Orders m/m"
                    TYPE_Empire_State_Manufacturing_Index => "Empire State Manufacturing Index"
                    TYPE_FOMC_Financial_Stability_Report => "FOMC Financial Stability Report"
                    TYPE_FOMC_Member_Barkin_Speaks => "FOMC Member Barkin Speaks"
                    TYPE_FOMC_Member_Barr_Speaks => "FOMC Member Barr Speaks"
                    TYPE_FOMC_Member_Bostic_Speaks => "FOMC Member Bostic Speaks"
                    TYPE_FOMC_Member_Bowman_Speaks => "FOMC Member Bowman Speaks"
                    TYPE_FOMC_Member_Collins_Speaks => "FOMC Member Collins Speaks"
                    TYPE_FOMC_Member_Cook_Speaks => "FOMC Member Cook Speaks"
                    TYPE_FOMC_Member_Daly_Speaks => "FOMC Member Daly Speaks"
                    TYPE_FOMC_Member_Goolsbee_Speaks => "FOMC Member Goolsbee Speaks"
                    TYPE_FOMC_Member_Hammack_Speaks => "FOMC Member Hammack Speaks"
                    TYPE_FOMC_Member_Harker_Speaks => "FOMC Member Harker Speaks"
                    TYPE_FOMC_Member_Jefferson_Speaks => "FOMC Member Jefferson Speaks"
                    TYPE_FOMC_Member_Kashkari_Speaks => "FOMC Member Kashkari Speaks"
                    TYPE_FOMC_Member_Kugler_Speaks => "FOMC Member Kugler Speaks"
                    TYPE_FOMC_Member_Logan_Speaks => "FOMC Member Logan Speaks"
                    TYPE_FOMC_Member_Miran_Speaks => "FOMC Member Miran Speaks"
                    TYPE_FOMC_Member_Musalem_Speaks => "FOMC Member Musalem Speaks"
                    TYPE_FOMC_Member_Paulson_Speaks => "FOMC Member Paulson Speaks"
                    TYPE_FOMC_Member_Schmid_Speaks => "FOMC Member Schmid Speaks"
                    TYPE_FOMC_Member_Waller_Speaks => "FOMC Member Waller Speaks"
                    TYPE_FOMC_Member_Williams_Speaks => "FOMC Member Williams Speaks"
                    TYPE_Factory_Orders_m_m => "Factory Orders m/m"
                    TYPE_Fed_Monetary_Policy_Report => "Fed Monetary Policy Report"
                    TYPE_Federal_Budget_Balance => "Federal Budget Balance"
                    TYPE_Final_GDP_Price_Index_q_q => "Final GDP Price Index q/q"
                    TYPE_Final_Manufacturing_PMI => "Final Manufacturing PMI"
                    TYPE_Final_Services_PMI => "Final Services PMI"
                    TYPE_Final_Wholesale_Inventories_m_m => "Final Wholesale Inventories m/m"
                    TYPE_Goods_Trade_Balance => "Goods Trade Balance"
                    TYPE_HPI_m_m => "HPI m/m"
                    TYPE_Housing_Starts => "Housing Starts"
                    TYPE_ISM_Manufacturing_Prices => "ISM Manufacturing Prices"
                    TYPE_Import_Prices_m_m => "Import Prices m/m"
                    TYPE_Loan_Officer_Survey => "Loan Officer Survey"
                    TYPE_Mortgage_Delinquencies => "Mortgage Delinquencies"
                    TYPE_NFIB_Small_Business_Index => "NFIB Small Business Index"
                    TYPE_New_Home_Sales => "New Home Sales"
                    TYPE_Pending_Home_Sales_m_m => "Pending Home Sales m/m"
                    TYPE_Prelim_Benchmark_Payrolls_Revision => "Prelim Benchmark Payrolls Revision"
                    TYPE_Prelim_GDP_Price_Index_q_q => "Prelim GDP Price Index q/q"
                    TYPE_Prelim_Nonfarm_Productivity_q_q => "Prelim Nonfarm Productivity q/q"
                    TYPE_Prelim_Unit_Labor_Costs_q_q => "Prelim Unit Labor Costs q/q"
                    TYPE_Prelim_Wholesale_Inventories_m_m => "Prelim Wholesale Inventories m/m"
                    TYPE_RCM_TIPP_Economic_Optimism => "RCM/TIPP Economic Optimism"
                    TYPE_Revised_Nonfarm_Productivity_q_q => "Revised Nonfarm Productivity q/q"
                    TYPE_Revised_Unit_Labor_Costs_q_q => "Revised Unit Labor Costs q/q"
                    TYPE_Richmond_Manufacturing_Index => "Richmond Manufacturing Index"
                    TYPE_S_P_CS_Composite_20_HPI_y_y => "S&P/CS Composite-20 HPI y/y"
                    TYPE_TIC_Long_Term_Purchases => "TIC Long-Term Purchases"
                    TYPE_Trade_Balance => "Trade Balance"
                    TYPE_Treasury_Currency_Report => "Treasury Currency Report"
                    TYPE_Wards_Total_Vehicle_Sales => "Wards Total Vehicle Sales"
                    => "News"
                bool _dupe = str.contains("|" + newsReasons + "|", "|" + _nm + "|")
                newsReasons := _dupe ? newsReasons : (newsReasons == "" ? _nm : newsReasons + ", " + _nm)
                newsMaxSev := _sev > newsMaxSev ? _sev : newsMaxSev
                _invalidatingNewsToday := true

    bool sevOk = not _invalidatingNewsToday

    // >>> CHANGE: single source of truth for the rest of the script
    //sev3Blocked := not sevOk

    // Build frozen reason string (snapshot checks only)
    sessionInvalidReasonFrozen := ""
    if not minOk
        sessionInvalidReasonFrozen += (sessionInvalidReasonFrozen != "" ? " | " : "") + "Min Range Size"
    if not maxOk
        sessionInvalidReasonFrozen += (sessionInvalidReasonFrozen != "" ? " | " : "") + "Max Range Size"
    if not sevOk
        string _newsTag = "News: " + newsReasons + " (Sev " + str.tostring(newsMaxSev) + ")"
        sessionInvalidReasonFrozen += (sessionInvalidReasonFrozen != "" ? " | " : "") + _newsTag  // >>> CHANGE: detailed reason

    sessionValidFrozen := sessionInvalidReasonFrozen == ""
    sessionSnapTaken := true
    sessionValid := sessionValidFrozen
    sessionInvalidReason := sessionInvalidReasonFrozen

    if showDebugLabels and not sessionValidFrozen
        label.new(bar_index, low, "Skipped: " + sessionInvalidReasonFrozen, style=label.style_label_up, textcolor=color.black, color=color.yellow, xloc=xloc.bar_index, yloc=yloc.belowbar)

// Keep live mirrors after snapshot
if sessionSnapTaken
    sessionValid := sessionValidFrozen
    sessionInvalidReason := sessionInvalidReasonFrozen
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// END 11) QUALITY FILTERS EVAL (freeze once at first breakout)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 12) OPTIONAL DEFERRED START (midpoint proximity) 
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
scoped_rangeMidpoint = not na(dayHigh) and not na(dayLow) ? (dayHigh + dayLow) / 2 : na
scoped_rangeWidth = not na(dayHigh) and not na(dayLow) ? (dayHigh - dayLow) : na
scoped_inBreakoutWindow = not na(exitTime) and time >= rangeEnd and time < exitTime and time > rangeStart
scoped_inDeferredBreakout = scoped_inBreakoutWindow and not scoped_officialRangeStarted
scoped_isNearMidpoint = not na(scoped_rangeMidpoint) and scoped_rangeWidth > 0 and math.abs(close - scoped_rangeMidpoint) <= (scoped_rangeWidth * midpointStartTolerancePct / 100)
 
// TEMP DEBUG: trace post-range bars until official start flips
var int _traceCount = 0
bool _isBreakoutBar = time[1] < rangeEnd and time >= rangeEnd
bool _shouldTrace = scoped_inBreakoutWindow and not scoped_officialRangeStarted and _traceCount < 8
if not sessionBlocked

    // Core start filters (generic â€œquality filtersâ€)
    bool _startFiltersCoreOK = sessionValid and not inEarlyWindow and not sev3Blocked  //  gate midpoint start on session + news + early window

    // === LEGITIMATE TRIGGERS (all quality filters must pass) ===
    isValidMidpointTrigger = scoped_inBreakoutWindow and midpointStartTolerancePct > 0 and scoped_isNearMidpoint and barstate.isconfirmed and _startFiltersCoreOK  // 
    isValidFallbackTrigger = scoped_inBreakoutWindow and midpointStartTolerancePct <= 0 and barstate.isconfirmed and _startFiltersCoreOK  // 
  

    // Proximity activation
    if isValidMidpointTrigger and not scoped_officialRangeStarted
        scoped_officialRangeStarted := true
        scoped_actualRangeStart := time
        //label.new(bar_index, high+40, "Midpoint", style=label.style_label_down, color=color.purple, textcolor=color.white)

    // Fallback activation
    if isValidFallbackTrigger and not scoped_officialRangeStarted
        scoped_officialRangeStarted := true
        scoped_actualRangeStart := time
   
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    
// 12.1) Sev 3 News Resume Time Text (reusable for labels/info)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    string sev3DelayedUntilText = ""  //    : reusable â€œHH:MM am/pmâ€ string based on sev3ReleaseMs
    if sev3Blocked and useSev3TimeWindow and useSev3Filter and not na(sev3ReleaseMs)
        int _relMinutesLabel = int(math.floor(sev3ReleaseMs / 60000))  // ðŸŸ¥ PATCH: force integer minutes (avoid decimal hour in label)
        int _maxDayMinutesLabel = 23 * 60 + 59
        if _relMinutesLabel < 0
            _relMinutesLabel := 0
        if _relMinutesLabel > _maxDayMinutesLabel
            _relMinutesLabel := _maxDayMinutesLabel
        int _hh24Label = int(math.floor(_relMinutesLabel / 60))  // ðŸŸ¥ PATCH: integer hour (avoid 7.0666 display)
        int _mmLabel = _relMinutesLabel % 60
        int _hh12Label = _hh24Label % 12
        if _hh12Label == 0
            _hh12Label := 12
        string _suffixLabel = _hh24Label >= 12 ? "pm" : "am"
        string _hhStrLabel = str.tostring(_hh12Label)
        string _mmStrLabel = str.tostring(_mmLabel, "00")
        sev3DelayedUntilText := str.format("{0}:{1} {2}", _hhStrLabel, _mmStrLabel, _suffixLabel)  //    : centralized formatted time
    else
        sev3DelayedUntilText := ""  //    : ensure always non-na string when not blocked

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    
// 12.2) Deferred-start reason label (first breakout bar only)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var label deferredStartLabel = na
    bool _deferredStartActive = scoped_inBreakoutWindow and not scoped_officialRangeStarted and not isValidMidpointTrigger and not isValidFallbackTrigger  // any reason we are deferring start

    // Emit the reasoned "Delayed Start:..." label once, on the first breakout bar where we actually defer
    if showDebugLabels and _deferredStartActive and time == rangeEnd and not na(dayHigh) and na(deferredStartLabel)  // gate label on real deferral at first breakout bar
        string _labelText = "Delayed Start:Other"  // fallback for unexplained deferrals
        if sev3Blocked or tradingHalted
            _labelText := sev3Blocked and str.length(sev3DelayedUntilText) > 0 ? "Delayed Start:News Until " + sev3DelayedUntilText : "Delayed Start:News"  //   reuse centralized Sev 3 resume string
        else if midpointStartTolerancePct > 0 and scoped_isNearMidpoint and _startFiltersCoreOK and not barstate.isconfirmed  // waiting for initial breakout bar close
            _labelText := "Waiting For initial bar to close."  //  Bar not closed, not sure what to do
        else if midpointStartTolerancePct > 0 and not scoped_isNearMidpoint
            _labelText := "Delayed Start:MidPoint"  // Midpoint price bar didn't close in range
        else if inEarlyWindow
            _labelText := "Delayed Start:Early"  // 
        else if not sessionValid
            _labelText := "Delayed Start:Session"  // 
        deferredStartLabel := label.new(x=bar_index, y=dayHigh + syminfo.mintick * 40, text=_labelText, style=label.style_label_down, color=color.new(color.red, 85), textcolor=color.white)  //   

    // Auto-clear the label once we are no longer in deferred-start (i.e., we either started or aborted)
    // This keeps the label visible for the entire deferred phase, including Sev3 news delay
    if not _deferredStartActive and not na(deferredStartLabel)  //    : clear when deferred phase ends
        label.delete(deferredStartLabel)  //    
        deferredStartLabel := na  //    
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 12.b) Midpoint Start â€” Why Not? (diagnostics)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Inputs used: showLowLevelTrace (already defined)
// Vars used: scoped_inBreakoutWindow, midpointStartTolerancePct, scoped_isNearMidpoint,
//            scoped_officialRangeStarted, sessionValidFrozen, sessionValid, sessionBlocked,
//            tradingHalted, requireMidpointReturn, tradesToday, inEarlyWindow
// No redeclarations; pure observability.

bool _midEligible_now = scoped_inBreakoutWindow and midpointStartTolerancePct > 0 and scoped_isNearMidpoint
bool _midWouldLatch   = _midEligible_now and barstate.isconfirmed
// All quality filters (generic): session, news, early-window, midpoint
// All quality filters (generic): session, news, early-window, midpoint + PL halt + trade-limit
bool _entryCtxAllOK   = sessionValid and
                         not sessionBlocked and
                         not inEarlyWindow and
                         not sev3Blocked and
                         not tradingHalted and
                         (tradeLimit == 0 or lastIssuedTradeNumber < tradeLimit)

// Emit a single, compact reason label only while we are eligible but not started yet
if showLowLevelTrace and _midEligible_now and not scoped_officialRangeStarted
    string _why = ""
    _why := _why + (barstate.isconfirmed ? "" : "waiting-close")
    _why := _why + (sessionValid ? "" : (str.length(_why) > 0 ? " | " : "") + "invalid-session")
    _why := _why + (sessionBlocked ? (str.length(_why) > 0 ? " | " : "") + "sessionBlocked" : "")
    //_why := _why + (tradingHalted ? (str.length(_why) > 0 ? " | " : "") + "halted" : "")
    _why := _why + (inEarlyWindow ? (str.length(_why) > 0 ? " | " : "") + "early-window" : "")
    // If nothing appended yet, show the â€œwould latch nowâ€ signal
    _why := str.length(_why) == 0 ? "would-latch-on-close" : _why
    label.new(bar_index, high + syminfo.mintick * 20, "MidStart: " + _why, style=label.style_label_down, color=color.new(color.purple, 20), textcolor=color.white)


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 13) ENTRY ENGINE (dual lock: session validity + trade limit)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var box deferredBox                     = na 
if inBreakoutWindow and not scoped_officialRangeStarted and not sessionBlocked and not na(dayHigh) and not na(dayLow)  //    deferred phase â€” draw red box while start is delayed
    int redLeft = rangeEnd  //    : deferred box always starts at scheduled range end
    int redRight = time  //    : extend to current bar while deferred
    if na(deferredBox)
        deferredBox := box.new(left=redLeft, top=dayHigh, right=redRight, bottom=dayLow, xloc=xloc.bar_time, bgcolor=color.new(color.red, 85), border_width=0)  //   create red deferred box
    else
        box.set_right(deferredBox, redRight)  //    : grow red box until official start

// â”€â”€ 13.b) Yellow active box: from actual start through exitTime â”€â”€
if inBreakoutWindow and not drew and not na(dayHigh) and scoped_officialRangeStarted and not sessionBlocked
    int boxLeft = scoped_actualRangeStart < rangeEnd ? rangeEnd : scoped_actualRangeStart
    color _activeBg = color.new(color.yellow, 80)  //   active box is always yellow once official start is latched
    box.new(left=boxLeft, top=dayHigh, right=exitTime, bottom=dayLow, xloc=xloc.bar_time, bgcolor=_activeBg, border_width=0)
    drew := true

if time[0] < rangeStart or time[0] > exitTime
    dayHigh := na
if time[0] < rangeStart or time[0] > exitTime
    dayLow := na
if time[0] < rangeStart or time[0] > exitTime
    scoped_officialRangeStarted := false
if time[0] < rangeStart or time[0] > exitTime
    scoped_actualRangeStart := na
if time[0] < rangeStart or time[0] > exitTime  //    : cleanup deferred red box on full session reset
    if not na(deferredBox)
        box.delete(deferredBox)  //    
        deferredBox := na        //    

if inDefine
    dayHigh := na(dayHigh) ? high : math.max(dayHigh, high)
    dayLow  := na(dayLow)  ? low  : math.min(dayLow, low)

if (not inBreakoutWindow)
    drew := false
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 15) DAILY HALTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Session PnL Calculation
f_calcSessionPL(_startTime, _endTime) =>
    var float totalPL = 0.0
    if not na(_startTime) and not na(_endTime) and strategy.closedtrades > 0
        totalPL := 0.0
        for i = 0 to strategy.closedtrades - 1
            float eTime = strategy.closedtrades.entry_time(i)
            if eTime >= _startTime and eTime <= _endTime
                float entryPrice = strategy.closedtrades.entry_price(i)
                float exitPrice = strategy.closedtrades.exit_price(i)
                float tradeQty = math.abs(strategy.closedtrades.size(i))
                bool isLong = strategy.closedtrades.size(i) > 0
                float points = isLong ? (exitPrice - entryPrice) : (entryPrice - exitPrice)
                float dollars = (points * syminfo.pointvalue * tradeQty) - strategy.closedtrades.commission(i)  // net P&L = contract-aware dollars âˆ’ broker commission
                totalPL := totalPL + dollars
    totalPL

f_calcDayPL() =>
    var float totalDayPL = 0.0
    yy = year(time, tzInput)
    mm = month(time, tzInput)
    dd = dayofmonth(time, tzInput)

    // Calculate today's 15:00
    dayStart = timestamp(tzInput, yy, mm, dd, 15, 0)

    // If current time is before today's 15:00, get prior day's 15:00 using timestamp math
    if time < dayStart
        dayStart := dayStart - 86400000  // Subtract 1 day in milliseconds

    totalDayPL := f_calcSessionPL(dayStart, time)

dayPL = f_calcDayPL()
float curLossDollars = dayPL < 0 ? -dayPL : 0.0
var bool plHalted = false  // latch for daily PL halts only
bool newsHaltedNow = sev3Blocked  //  per-bar news gate (non-latched)

// Evaluate PL-based trading halt condition (latching)
if maxDailyLoss > 0 and dayPL < -maxDailyLoss
    plHalted := true  // latch PL halt

if maxDailyProfit > 0 and dayPL >= maxDailyProfit
    plHalted := true  //  latch PL halt

// Reset PL latch at next global open (15:00 in tzInput)
int globalOpen = timestamp(tzInput, year(time, tzInput), month(time, tzInput), dayofmonth(time, tzInput), 15, 0)
if time >= globalOpen and time[1] < globalOpen
    plHalted := false

// Combine PL latch and live news halt into a single gate
tradingHalted := plHalted or newsHaltedNow  // PL halts stay latched; Sev3 halts follow time window

bool _newsReleaseNow = newsHaltedNow[1] and not newsHaltedNow
if showOppositeDebugLabels and _newsReleaseNow
    label.new(bar_index, high + syminfo.mintick * 60, "Sev 3 News Over", style=label.style_label_down, color=color.new(color.orange, 0), textcolor=color.white)

// â”€â”€ L3: Explain why trading is halted even if the box looks valid
bool _enterBreakoutThisBar = inBreakoutWindow and not inBreakoutWindow[1]
bool _haltEdgeNow          = tradingHalted and not tradingHalted[1]

// Show a one-shot label when we either:
//   â€¢ enter the breakout window while already halted (e.g. daily PL reached earlier in the day), or
//   â€¢ just transitioned into a halted state while in the window.
if showLowLevelTrace and tradingHalted and (_enterBreakoutThisBar or _haltEdgeNow)
    string _haltWhy = ""
    if plHalted
        _haltWhy := dayPL <= -maxDailyLoss ? "Daily Loss Halt" : "Daily Profit Halt"
    else
        if newsHaltedNow
            _haltWhy := "Sev3 News Window"
        else
            _haltWhy := "Other Halt"

    label.new(
         bar_index,
         high + syminfo.mintick * 80,
         "Halted: " + _haltWhy,
         style = label.style_label_down,
         color = color.new(color.red, 40),
         textcolor = color.white
     )

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 16) ENTRY & EXIT LOGIC (Dual Lock: Session Validity + Trade Limit)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//clears per-session gates before the engine arms entries (e.g., placedTrades, 
// waitUntilBar, postTradeLock).
// zeroes counters (tradesToday) and snapshot vars so the data window/panel shows fresh values.
// pairs with your EOS cleanup (which cancels orders and sets resetTimes := true) by 
// resetting counters/flags that the EOS block doesnâ€™t touch. see your EOS cleanup: 
// it triggers on the first bar at/after exitTime, cancels orders, closes all, and sets resetTimes := true.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var tradesToday = 0
var closedTrades = 0
var int waitUntilBar = na
var int postTradeLock = na

// Start-of-session reset â€” fires once at the first bar inside the new session
if bar_index > 0 and time[1] < rangeStart and time >= rangeStart
    placedTrades := false
    tradesToday := 0
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    postTradeLock := na
    issuedLongOrder := false
    issuedShortOrder := false
    lastIssuedTradeNumber_reason := "session-reset"
    lastIssuedTradeNumber := 0
    emergencyExitSent := false
    earlyExitFired := false
    proxyPosActive := false
    proxyTickerPos := ""
    proxyPosDir    := 0
    proxyPosQty    := 0
    sessionPL_snapshot := na
    tradesToday_snapshot := na
    sessionTable := na
    drew := false
    rearmAfterProfitPending := false
    rearmEligibleFromBar := na
    // reset frozen snapshots for the new session
    sizingSnapTaken := false
    sLongEntry := na
    sShortEntry := na
    sLongStop  := na
    sShortStop := na
    sLongTP    := na
    sShortTP   := na
    sessionSnapTaken := false
    sessionValidFrozen := true
    sessionInvalidReasonFrozen := ""
    tradingHalted := false
    // >>>   G: session-begin â€” reset cycle state
    cycleSide := 0
    oppOutstanding := 0

//But if the script loads mid-session (inside the range window, before that crossing logic runs), lastIssuedTradeNumber can still reflect a prior session.
// this code is supposed to help with chart reload issues. 
if barstate.isfirst and time >= rangeStart and time < exitTime
    placedTrades := false
    issuedLongOrder := false
    issuedShortOrder := false
    lastIssuedTradeNumber_reason := "mid-session-reset"
    lastIssuedTradeNumber := 0


// Reset just after session ends âœ… Executes once, on the first bar after the session ends - Ideal for resetting session state (e.g., flags, counters, UI values)
if bar_index > 0 and time[1] < exitTime and time[0] >= exitTime
    tradesToday := 0
    placedTrades := false
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    issuedLongOrder := false
    issuedShortOrder := false
    // â—„â—„â—„ clear our trade-number gating for next session
    lastIssuedTradeNumber_reason := "session-reset"
    lastIssuedTradeNumber := 0
    emergencyExitSent      := false
    sessionPL_snapshot := na
    tradesToday_snapshot := na
    sessionTable := na
    proxyPosActive := false
    proxyTickerPos := ""
    proxyPosDir    := 0
    proxyPosQty    := 0
    // >>>   H: session-end â€” reset cycle state
    cycleSide := 0
    oppOutstanding := 0

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 17) ENTRY ENGINE (dual lock: session validity + trade limit)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
idLong = "Long"
idShort = "Short"
canceledLong = false
canceledShort = false

/// â”€â”€ Emergency exit block (single-latch, single-line calls)
if realtimeEffective and not emergencyExitSent and bar_index == emergencyExitBar and (na(lastExitEmitBar) or lastExitEmitBar != bar_index)
    bool allowExit_em = na(lastExitEmitBar) or lastExitEmitBar != bar_index
    bool allowChart_em = allowExit_em
    bool allowProxy_em = allowExit_em
    string chartTkr_em = syminfo.ticker
    string proxyTkr_em = proxyTickerPos != "" ? proxyTickerPos : f_get_proxy_ticker(chartTkr_em)
    bool emitLabel_em = true
    bool allowCancelSweep_em = na(lastCancelSweepBar) or lastCancelSweepBar != bar_index  //    Emergency may request CancelSweep once per bar
    bool doCancelAll_em = allowCancelSweep_em  //    gate _doCancelAllBefore by per-bar latch
    bool posIsLong_em = strategy.position_size > 0
    string thisEntry_em = posIsLong_em ? idLong : idShort
    string thisExit_em  = posIsLong_em ? idLong + "_Exit" : idShort + "_Exit"
    string oppPrim_em   = posIsLong_em ? idShort : idLong
    string oppPrimEx_em = posIsLong_em ? idShort + "_Exit" : idLong + "_Exit"
    [didExit_em_tmp, proxySent_em_tmp] = f_exit_atomic("Emergency", "Emergency Market Exit", close, time, tzInput, chartTkr_em, proxyTkr_em, emitLabel_em, doCancelAll_em, thisEntry_em, thisExit_em, oppPrim_em, oppPrimEx_em, allowChart_em, allowProxy_em)
    if allowCancelSweep_em and doCancelAll_em  //    latch CancelSweep usage for this bar
        lastCancelSweepBar := bar_index  //    

    if didExit_em_tmp
        emergencyExitSent := true
    if proxySent_em_tmp and proxyTickerPos != ""
        proxyPosActive := false
        proxyTickerPos := ""
        proxyPosDir    := 0
        proxyPosQty    := 0
    oppTPLineActive := false
    oppTPLineIsLong := false
    oppTPLinePrice  := na
    // >>>   F: emergency â€” reset cycle state â€” BEGIN
    cycleSide := 0
    oppOutstanding := 0
    // >>>   F: emergency â€” reset cycle state â€” END
    if didExit_em_tmp
        lastExitEmitBar := bar_index
    if proxySent_em_tmp
        lastExitEmitBar := bar_index

// Evaluate entry conditions each bar                                  
bool currentPriceIsInsideRange_check = isPriceInsideRange()
bool priceGateOK = lastIssuedTradeNumber == 0 ? true : currentPriceIsInsideRange_check
bool allConditionsMetForTradePlacement = not tradingHalted and
                                         sessionValid and
                                         not sessionBlocked and
                                         strategy.position_size == 0 and
                                         not placedTrades and
                                         not issuedLongOrder and
                                         not issuedShortOrder and
                                         // >>> CHANGE: block base placement while OppAdd is active
                                         oppOutstanding == 0 and
                                         (na(waitUntilBar) or bar_index >= waitUntilBar) and
                                         (na(postTradeLock) or bar_index >= postTradeLock) and
                                         priceGateOK and
                                         (tradeLimit == 0 or lastIssuedTradeNumber < tradeLimit) and
                                         (not requireMidpointReturn or tradesToday == 0 or (scoped_isNearMidpoint and barstate.isconfirmed)) // >>> CHANGE: midpoint gate close-confirmed post-Trade1 Double fire post profit bug

// Allow re-arming when we come back to midpoint during deferred starts Only before the first issuance and while flat â€” prevents per-bar re-arming spam
if scoped_inBreakoutWindow and midpointStartTolerancePct > 0 and scoped_isNearMidpoint and lastIssuedTradeNumber == 0 and strategy.position_size == 0
    placedTrades := false

// 17.0a) Safety: clear any stale placement latch for the very first issuance
if inBreakoutWindow and scoped_officialRangeStarted and lastIssuedTradeNumber == 0 and strategy.position_size == 0
    placedTrades := false

if inBreakoutWindow and scoped_officialRangeStarted
    // ðŸ”’ Session Invalid Lock
    if not sessionValid and not placedTrades
        strategy.cancel(idLong)
        strategy.cancel(idShort)
        placedTrades := true

    // ðŸ”’ Trade Limit Lock (by set count)
    if tradeLimit > 0 and lastIssuedTradeNumber >= tradeLimit and not placedTrades
        strategy.cancel(idLong)
        strategy.cancel(idShort)
        placedTrades := true


    // â”€â”€ ENTRY PLACEMENT (trade-number gating) â”€â”€
    int nextTradeNum = lastIssuedTradeNumber + 1
    bool wasZeroIssued = not issuedLongOrder and not issuedShortOrder

    if allConditionsMetForTradePlacement and bar_index != lastEntryBar and nextTradeNum > lastIssuedTradeNumber
        lastEntryBar := bar_index
        bool placedL = f_placeBracket(idLong,  strategy.long,  useLongEntry,  useLongStop,  useLongTP,  lastIssuedTradeNumber, issuedLongOrder,  true, curLossDollars)
        bool placedS = f_placeBracket(idShort, strategy.short, useShortEntry, useShortStop, useShortTP, lastIssuedTradeNumber, issuedShortOrder, true, curLossDollars)

        bool anyPlaced = placedL or placedS

        if placedL
            issuedLongOrder := true
            placedTrades := true
        if placedS
            issuedShortOrder := true
            placedTrades := true

        // Bump ONLY when leaving the 0-order state; set reason here (not earlier)
        int _prevNum = lastIssuedTradeNumber
        if wasZeroIssued and anyPlaced
            lastIssuedTradeNumber_reason := _prevNum == 0 ? "initial-place" : "cycle-start"
            lastIssuedTradeNumber := nextTradeNum
        else
            lastIssuedTradeNumber_reason := "no-bump-not-zero"
            lastIssuedTradeNumber := lastIssuedTradeNumber

        // latch Â§12 invariants only when a side actually places
        if placedL and na(scoped_actualRangeStart)
            scoped_actualRangeStart := time
        if placedL and not scoped_officialRangeStarted
            scoped_officialRangeStarted := true
        if placedS and na(scoped_actualRangeStart)
            scoped_actualRangeStart := time
        if placedS and not scoped_officialRangeStarted
            scoped_officialRangeStarted := true

        // Auto-clear the post-trade lock once elapsed
        if not na(postTradeLock) and bar_index >= postTradeLock
            postTradeLock := na
            issuedLongOrder := false
            issuedShortOrder := false


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 17.2) OPEN TRADE HANDLER â€” Immediate Opposite Reissue (Single-Policy)
//       â€¢ No N+1 scheduler; issue on entry bar if guards pass
//       â€¢ Uses adjusted entry/SL and scaled TP via oppositeTpOverride (if >= 0)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Position transition detection (declare once; update each bar)
var int  posNow172 = 0
var int  posPrev172 = 0
var bool wasFlat172 = false
var bool enteredLongNow172 = false
var bool enteredShortNow172 = false
var bool reattached172 = false

posNow172 := int(math.round(nz(strategy.position_size)))
posPrev172 := int(math.round(nz(strategy.position_size[1])))
wasFlat172 := posPrev172 == 0
enteredLongNow172  := (posPrev172 <= 0) and posNow172 > 0
enteredShortNow172 := (posPrev172 >= 0) and posNow172 < 0
// >>> CHANGE: clear outstanding flag the moment any new entry fills (includes OppAdd fill at 06:38)
if oppOutstanding != 0 and (enteredLongNow172 or enteredShortNow172)
    oppOutstanding := 0

// --- Intra-bar entry pulse hardening (chart-only; no proxy) ---//for single bar flips
var int  barId172 = na
var int  posAtBarOpen172 = 0
var bool seenNonZeroThisBar172 = false
var int  entryQtySnap172 = na

if na(barId172) or bar_index != barId172
    barId172 := bar_index
    posAtBarOpen172 := int(math.round(nz(strategy.position_size[1])))
    seenNonZeroThisBar172 := false
    entryQtySnap172 := na

bool enteredLongNow172_ib  = false
bool enteredShortNow172_ib = false
if posAtBarOpen172 == 0 and not seenNonZeroThisBar172 and strategy.position_size != 0
    seenNonZeroThisBar172 := true
    int _snapPos172 = int(math.round(nz(strategy.position_size)))
    enteredLongNow172_ib  := _snapPos172 > 0
    enteredShortNow172_ib := _snapPos172 < 0
    entryQtySnap172 := int(math.abs(_snapPos172))

enteredLongNow172  := enteredLongNow172  or enteredLongNow172_ib
enteredShortNow172 := enteredShortNow172 or enteredShortNow172_ib


// PROFIT stand-down detection (compute every bar; lets 17.4 reissue both if profit close just happened)
int  ct172 = strategy.closedtrades
bool ctChanged172 = ta.change(ct172) != 0
bool profitClosedThisBar172 = false
if ctChanged172 and ct172 > 0
    float _exitP172  = strategy.closedtrades.exit_price(ct172 - 1)
    float _entryP172 = strategy.closedtrades.entry_price(ct172 - 1)
    bool  _long172   = strategy.closedtrades.size(ct172 - 1) > 0
    profitClosedThisBar172 := _long172 ? (_exitP172 > _entryP172) : (_exitP172 < _entryP172)

// >>> CHANGE: synthesize entry pulse for historical same-bar STOP (entry+STOP on one candle)
// Only when we were flat at bar open and flat at close, and the close was a STOP (not profit)
bool stopClosedThisBar172 = ctChanged172 and ct172 > 0 and not profitClosedThisBar172
bool fallbackPulse172 = false
int  fallbackDir172 = 0
if stopClosedThisBar172 and wasFlat172 and strategy.position_size == 0
    float _szClosed172 = strategy.closedtrades.size(ct172 - 1)
    fallbackDir172 := _szClosed172 > 0.0 ? -1 : 1
    fallbackPulse172 := true

// Shared locals (17.2-scoped)
var float reOppEntry172 = na
var float reOppStop172  = na
var float reOppTP172    = na
var float reOppQty172   = na
var string reOppId172   = ""
var string reOppExitId172 = ""

float mt172 = syminfo.mintick != 0.0 ? syminfo.mintick : 0.01
bool  capOK172 = true

// Unified block flag: honor Sev/news-day block, invalid session, and global halt
bool oppBlocked172 = not sessionValidFrozen or sessionBlocked or not sessionValid or tradingHalted
// >>> CHANGE: precompute adjusted OppAdd stops from original entryâ†”stop distances; entry & TP unchanged
float _oppAddFrac172 = oppAddStopPct / 100.0
float _longDist172 = not na(useLongEntry) and not na(useLongStop) ? math.abs(useLongEntry - useLongStop) : na
float _shortDist172 = not na(useShortEntry) and not na(useShortStop) ? math.abs(useShortStop - useShortEntry) : na
float oppLongStopAdj172 = not na(_longDist172) and not na(useLongEntry) ? useLongEntry - (_longDist172 * _oppAddFrac172) : na
float oppShortStopAdj172 = not na(_shortDist172) and not na(useShortEntry) ? useShortEntry + (_shortDist172 * _oppAddFrac172) : na

// >>> CHANGE: visibility-gated adjusted OppAdd stop guides (show only when OppAdd TP lines are active)
bool  _showAdjStops172 = oppTPLineActive
float pOppLongStopAdj172  = _showAdjStops172 ? oppLongStopAdj172  : na
float pOppShortStopAdj172 = _showAdjStops172 ? oppShortStopAdj172 : na

// >>> CHANGE: Data Window field for active Recoup Trade Stop (mirrors OppAdd visibility)
bool  _showRecoupDW172 = oppTPLineActive
float recoupTradeStop172 = _showRecoupDW172 ? (not na(pOppLongStopAdj172) ? pOppLongStopAdj172 : not na(pOppShortStopAdj172) ? pOppShortStopAdj172 : na) : na


// Entry-bar pulse: true only on the bar a real position opens (your current detector)
bool entryPulse172 = enteredLongNow172 or enteredShortNow172

// Â§17.2 â€” effective start is live start OR a recorded actualRangeStart (latch w/out new globals)
bool officialStartEffective = scoped_officialRangeStarted or not na(scoped_actualRangeStart)
bool ctxOKBase172 = inBreakoutWindow and officialStartEffective and sessionValidFrozen
int dirOpp172 = enteredShortNow172 ? 1 : enteredLongNow172 ? -1 : 0
//  Apply fallback pulse for same-bar STOP
if not entryPulse172 and fallbackPulse172 and dirOpp172 == 0
    dirOpp172 := fallbackDir172
    entryPulse172 := true
// >>>   H1: intra-bar flip fallback â€” INSERTED
if dirOpp172 == 0 and posNow172 != 0
    dirOpp172 := posNow172 < 0 ? 1 : -1
// >>>   H1 â€” END

//    define effective opposite-entry offset (negative => auto-match legacy entryOff - stopOff)
float effOppOffsetPts172 = oppositeReissueEntryOffsetPts >= 0.0 ? oppositeReissueEntryOffsetPts : (entryOff - stopOff)
effOppOffsetPts172 := math.max(0.0, effOppOffsetPts172)  //    : non-negative guard

bool ctxOKOppAdd172 = ctxOKBase172 and not oppTPLineActive
if dirOpp172 != 0 and ctxOKOppAdd172
    // If profit close detected on this bar, stand down and let 17.4 handle both sides
    if profitClosedThisBar172
        reOppTP172 := reOppTP172  // no-op to satisfy non-empty branch rule
    else
        if true
            if oppBlocked172
                if showOppositeDebugLabels
                    label.new(bar_index, close, "Immediate: Skipped (blocked/invalid/halt)", style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white)
            else
                // LONG add on proxy when we just entered SHORT micro
                if dirOpp172 == 1
                    //reOppEntry172 := useLongEntry //revert because getting greedy on the entry doesnt respect the levels
                    reOppEntry172 := math.round((useShortStop + effOppOffsetPts172) / mt172) * mt172  //    Opp LONG entry Î” above short stop
                    
                    reOppStop172  := oppLongStopAdj172  // >>> CHANGE: scaled OppAdd stop
                    reOppTP172    := reOppEntry172 + useTpSizeOpp

                    bool haveAllL172 = not na(reOppEntry172) and not na(reOppStop172) and not na(reOppTP172)
                    bool distOKL172 = true
                    // Size from the EXISTING short leg's actual $ risk; hit target = baseRisk Ã— oppositeQtyMultiplier
                    int   qtyExistMicroL   = int(math.abs(posNow172))
                    if entryPulse172 and qtyExistMicroL <= 0
                        qtyExistMicroL := int(math.abs(nz(entryQtySnap172, 0)))
                    // >>> CHANGE: same-bar STOP fallback â€” use actual closed trade size if latch is empty
                    float _qtyClosedThisBarL172 = ct172 > 0 ? math.abs(strategy.closedtrades.size(ct172 - 1)) : 0.0
                    if entryPulse172 and stopClosedThisBar172 and qtyExistMicroL <= 0
                        qtyExistMicroL := int(_qtyClosedThisBarL172)

                    // Size from the EXISTING short leg's risk (unchanged logic up to intended qty) â€¦
                    float baseRiskExistL   = f_calcTradeRiskDollars(useShortEntry, useShortStop, qtyExistMicroL)
                    float riskPerMicroOppL = f_calcTradeRiskDollars(useLongEntry,  useLongStop,  1)
                    float addRiskL         = baseRiskExistL * oppositeQtyMultiplier - baseRiskExistL
                    int   qMicroAddL_raw   = addRiskL > 0 and riskPerMicroOppL > 0 ? int(math.ceil(addRiskL / riskPerMicroOppL)) : 0
                    if minimumOneContract and addRiskL > 0 and qMicroAddL_raw <= 0
                        qMicroAddL_raw := 1

                    //    backtest-only neutralizer â€” subtract the opposite position seen *now*
                    int qMicroAddL = qMicroAddL_raw                                         //    start with intended qty
                    if not barstate.isrealtime and posNow172 < 0 and qMicroAddL > 0                      //    only when LONG add would reverse a SHORT
                        qMicroAddL := math.max(0, qMicroAddL - math.abs(posNow172))         //    request less so freeze == intended
                    int   qFullAddL_pre    = int(math.floor(qMicroAddL * proxyQtyMul))                                          //    
                    int   qFullAddL        = (oppAddMinOneYM and useProxyRealtimeOnly and realtimeEffective and qMicroAddL > 0) //    
                         ? int(math.max(1, qFullAddL_pre))                                                                        //    
                         : int(math.max(0, qFullAddL_pre))    
                    float microEqQtyForGateL = (useProxyRealtimeOnly and realtimeEffective and oppAddMinOneYM and proxyQtyMul > 0) ? float(qFullAddL) / proxyQtyMul : float(qMicroAddL)  //    
                    bool riskOKL172 = f_projectedRiskOK(reOppEntry172, reOppStop172, microEqQtyForGateL, curLossDollars)  //    

                    if haveAllL172 and distOKL172 and capOK172 and riskOKL172 and ((barstate.isrealtime and qFullAddL > 0) or (not barstate.isrealtime and qMicroAddL > 0))
                        // Arm the opposite-TP overlay line for plotting
                        oppTPLineActive := true
                        oppTPLineIsLong := true
                        oppTPLinePrice  := reOppTP172
                        string labelTkrL172 = useProxyRealtimeOnly and realtimeEffective ? f_get_proxy_ticker(syminfo.ticker) : syminfo.ticker
                        bool _placedL172 = f_send_opposite_on_proxy(labelTkrL172, true, reOppEntry172, reOppStop172, reOppTP172, qMicroAddL, proxyQtyMul, oppBlocked172)
                        // >>> CHANGE: mark opposite order as outstanding so base placer stands down
                        if _placedL172
                            oppOutstanding := 1
                        if _placedL172 and useProxyRealtimeOnly and realtimeEffective
                            proxyPosActive := true
                            proxyTickerPos := labelTkrL172
                            proxyPosDir    := 1
                            proxyPosQty    := qFullAddL

                        if showOppositeDebugLabels
                            int shownQtyL172 = useProxyRealtimeOnly and realtimeEffective ? qFullAddL : qMicroAddL
                            label.new(bar_index, close, "Opp Add LONG " + labelTkrL172 + " x" + str.tostring(shownQtyL172), style=label.style_label_up, color=color.new(color.green, 20), textcolor=color.white)
                    else
                        if showOppositeDebugLabels and entryPulse172 and not oppTPLineActive
                            string why =
                                 oppBlocked172 ? "blocked" :
                                 not haveAllL172 ? "levels" :
                                 not capOK172 ? "limit" :
                                 not riskOKL172 ? "risk" :
                                 ((barstate.isrealtime and qFullAddL <= 0) or (not barstate.isrealtime and qMicroAddL <= 0)) ? "qty=0" :
                                 "unknown"
                            label.new(bar_index, close,
                                 "Opp Add LONG skipped: " + why,
                                 style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white)
                // SHORT add on proxy when we just entered LONG micro
                if dirOpp172 == -1
                    //reOppEntry172 := useShortEntry //reverted to get less greedy
                    reOppEntry172 := math.round((useLongStop - effOppOffsetPts172) / mt172) * mt172  //    Opp SHORT entry Î” below long stop
                    reOppStop172  := useShortStop
                    reOppStop172  := oppShortStopAdj172 // >>> CHANGE: scaled OppAdd stop
                    reOppTP172    := reOppEntry172 - useTpSizeOpp
                    bool haveAllS172 = not na(reOppEntry172) and not na(reOppStop172) and not na(reOppTP172)
                    bool distOKS172 = true
                    // Size from the EXISTING long leg's actual $ risk; hit target = baseRisk Ã— oppositeQtyMultiplier
                    int   qtyExistMicroS   = int(math.abs(posNow172))
                    if entryPulse172 and qtyExistMicroS <= 0
                        qtyExistMicroS := int(math.abs(nz(entryQtySnap172, 0)))
                    // >>> CHANGE: same-bar STOP fallback â€” use actual closed trade size if latch is empty
                    float _qtyClosedThisBarS172 = ct172 > 0 ? math.abs(strategy.closedtrades.size(ct172 - 1)) : 0.0
                    if entryPulse172 and stopClosedThisBar172 and qtyExistMicroS <= 0
                        qtyExistMicroS := int(_qtyClosedThisBarS172)
            
                    float baseRiskExistS   = f_calcTradeRiskDollars(useLongEntry, useLongStop, qtyExistMicroS)
                    float riskPerMicroOppS = f_calcTradeRiskDollars(useShortEntry, useShortStop, 1)
                    float addRiskS         = baseRiskExistS * oppositeQtyMultiplier - baseRiskExistS
                    int   qMicroAddS_raw   = addRiskS > 0 and riskPerMicroOppS > 0 ? int(math.ceil(addRiskS / riskPerMicroOppS)) : 0
                    if minimumOneContract and addRiskS > 0 and qMicroAddS_raw <= 0
                        qMicroAddS_raw := 1

                    //    backtest-only neutralizer â€” subtract the opposite position seen *now*
                    int qMicroAddS = qMicroAddS_raw                                         //    start with intended qty
                    if not barstate.isrealtime and posNow172 > 0 and qMicroAddS > 0                      //    only when SHORT add would reverse a LONG
                        qMicroAddS := math.max(0, qMicroAddS - math.abs(posNow172))         //    request less so freeze == intended

                    int   qFullAddS_pre    = int(math.floor(qMicroAddS * proxyQtyMul))                                          //    
                    int   qFullAddS        = (oppAddMinOneYM and useProxyRealtimeOnly and realtimeEffective and qMicroAddS > 0) //    
                         ? int(math.max(1, qFullAddS_pre))                                                                        //    
                         : int(math.max(0, qFullAddS_pre))                                                                        //    

                    float microEqQtyForGateS = (useProxyRealtimeOnly and realtimeEffective and oppAddMinOneYM and proxyQtyMul > 0) ? float(qFullAddS) / proxyQtyMul : float(qMicroAddS)  //    

                    bool riskOKS172 = f_projectedRiskOK(reOppEntry172, reOppStop172, microEqQtyForGateS, curLossDollars)  //    
                    if haveAllS172 and distOKS172 and capOK172 and riskOKS172 and ((barstate.isrealtime and qFullAddS > 0) or (not barstate.isrealtime and qMicroAddS > 0))
                        // Arm the opposite-TP overlay line for plotting
                        oppTPLineActive := true
                        oppTPLineIsLong := false
                        oppTPLinePrice  := reOppTP172
                        string labelTkrS172 = useProxyRealtimeOnly and realtimeEffective ? f_get_proxy_ticker(syminfo.ticker) : syminfo.ticker
                        bool _placedS172 = f_send_opposite_on_proxy(labelTkrS172, false, reOppEntry172, reOppStop172, reOppTP172, qMicroAddS, proxyQtyMul, oppBlocked172)
                        // >>> CHANGE: mark opposite order as outstanding so base placer stands down
                        if _placedS172
                            oppOutstanding := 1
                        if _placedS172 and useProxyRealtimeOnly and realtimeEffective
                            proxyPosActive := true
                            proxyTickerPos := labelTkrS172
                            proxyPosDir    := -1
                            proxyPosQty    := qFullAddS
                        if showOppositeDebugLabels
                            int shownQtyS172 = useProxyRealtimeOnly and realtimeEffective ? qFullAddS : qMicroAddS
                            label.new(bar_index, close, "Opp Add SHORT " + labelTkrS172 + " x" + str.tostring(shownQtyS172), style=label.style_label_down, color=color.new(color.green, 20), textcolor=color.white)
                    else
                        if showOppositeDebugLabels and entryPulse172
                            string why =
                                 oppBlocked172 ? "blocked" :
                                 not haveAllS172 ? "levels" :
                                 not capOK172 ? "limit" :
                                 not riskOKS172 ? "risk" :
                                 ((barstate.isrealtime and qFullAddS <= 0) or (not barstate.isrealtime and qMicroAddS <= 0)) ? "qty=0" :
                                 "unknown"
                            label.new(bar_index, close,
                                 "Opp Add SHORT skipped: " + why,
                                 style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white)

else
    // Only emit a reason label on actual entry bars; avoids label buffer burn on other bars
    if showLowLevelTrace and entryPulse172
        string miss172 =
                 not inBreakoutWindow       ? "inBreakoutWindow=false" :
                 not officialStartEffective ? "officialStartEffective=false" :
                 not sessionValidFrozen     ? "sessionValidFrozen=false" :
                 oppBlocked172              ? "oppBlocked" :
                 oppTPLineActive            ? "oppTPActive" :
                                           "unknown"

        label.new(bar_index, close,
                  "Opp Add skipped (ctx): " + miss172,
                  style=label.style_label_down, color=color.new(color.gray, 20), textcolor=color.white)

// >>>   B: Â§17.2 Entry Snapshot â€” BEGIN
// On the bar a real position opens, record initial side and how many opposite orders are now â€œin flightâ€
if entryPulse172
    cycleSide := enteredLongNow172 ? 1 : -1
    oppOutstanding := 1
    bool _oppIssued172 = oppTPLineActive
    if _oppIssued172
        oppOutstanding := oppOutstanding + 1
// >>>   B: Â§17.2 Entry Snapshot â€” END

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 17.2a) OPPOSITE RISK DEBUG (data-window only; no behavior changes)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

//   toggle to show on-chart one-liners only on actual OppAdd attempt bars
bool showOppRiskDebug = input.bool(false, "Debug: Show Opposite Risk Diagnostics", group="Display Settings")  //   

// Derive the exact OppAdd entry/stop the engine would use on this bar (direction-aware)
float dbg_entryOpp = dirOpp172 == 1 ? math.round((useShortStop + effOppOffsetPts172) / mt172) * mt172 : dirOpp172 == -1 ? math.round((useLongStop - effOppOffsetPts172) / mt172) * mt172 : na  //    
float dbg_stopOpp  = dirOpp172 == 1 ? oppLongStopAdj172 : dirOpp172 == -1 ? oppShortStopAdj172 : na  //    

//    : per-contract risk ($) for each side, using frozen brackets; 1 micro contract
float dbg_riskPerMicroOppL = (not na(useLongEntry)  and not na(useLongStop))  ? f_calcTradeRiskDollars(useLongEntry,  useLongStop, 1) : na  //    
float dbg_riskPerMicroOppS = (not na(useShortEntry) and not na(useShortStop)) ? f_calcTradeRiskDollars(useShortEntry, useShortStop, 1) : na  //    

//    : position snapshot (micro units on chart)
int   dbg_posNow = int(math.round(nz(strategy.position_size)))  //    
int   dbg_posLong  = math.max(dbg_posNow, 0)  //    
int   dbg_posShort = -math.min(dbg_posNow, 0) //    

//    existing-leg base risk ($) from current position â€” always a positive magnitude
float dbg_baseRiskFromLong  = not na(dbg_riskPerMicroOppL) ? dbg_riskPerMicroOppL * float(dbg_posLong)  : na  //    
float dbg_baseRiskFromShort = not na(dbg_riskPerMicroOppS) ? dbg_riskPerMicroOppS * float(dbg_posShort) : na  //    
float dbg_baseRiskExist     = dbg_posNow > 0 ? nz(dbg_baseRiskFromLong, 0.0) : dbg_posNow < 0 ? nz(dbg_baseRiskFromShort, 0.0) : 0.0  //    

//    : target and incremental add risk ($) via oppositeQtyMultiplier
float dbg_targetRisk = dbg_baseRiskExist * oppositeQtyMultiplier  //    
float dbg_addRiskRaw = dbg_targetRisk - dbg_baseRiskExist         //    
float dbg_addRisk    = math.max(dbg_addRiskRaw, 0.0)              //    

//    : pick opposite side per-contract risk for sizing add
// Recompute â€œrisk per 1 microâ€ using the SAME entry/stop as the realtime OppAdd gate
float dbg_riskPerMicroOpp = (not na(dbg_entryOpp) and not na(dbg_stopOpp)) ? f_calcTradeRiskDollars(dbg_entryOpp, dbg_stopOpp, 1) : na  //    


//    : micro add size (ceil to reach target); honor minimumOneContract
int   dbg_qMicroAdd_raw = (dbg_addRisk > 0 and not na(dbg_riskPerMicroOpp) and dbg_riskPerMicroOpp > 0) ? int(math.ceil(dbg_addRisk / dbg_riskPerMicroOpp)) : 0  //    
int   dbg_qMicroAdd     = (minimumOneContract and dbg_addRisk > 0 and dbg_qMicroAdd_raw <= 0) ? 1 : dbg_qMicroAdd_raw  //    

//    : live proxy full-size add qty (YM) derived from micro qty; min 1 only if we actually have an add
int   dbg_qFullAdd = dbg_qMicroAdd > 0 ? int(math.max(1, math.floor(dbg_qMicroAdd * proxyQtyMul))) : 0  //    

//    : projected risk dollars (micro vs real-proxy)
float dbg_projRiskMicro = (not na(dbg_riskPerMicroOpp) and dbg_qMicroAdd > 0) ? dbg_riskPerMicroOpp * float(dbg_qMicroAdd) : na  //    
float dbg_microPerFull  = proxyQtyMul > 0 ? (1.0 / proxyQtyMul) : na
float dbg_qMicroEqReal  = (dbg_qFullAdd > 0 and not na(dbg_microPerFull)) ? float(dbg_qFullAdd) * dbg_microPerFull : na
float dbg_projRiskReal  = (not na(dbg_riskPerMicroOpp) and not na(dbg_qMicroEqReal)) ? dbg_riskPerMicroOpp * dbg_qMicroEqReal : na  //    

//    : current loss snapshot and gates
float dbg_curLoss  = dayPL < 0 ? -dayPL : 0.0  //    
bool  dbg_gateMicro = (not na(dbg_entryOpp) and not na(dbg_stopOpp)) ? f_projectedRiskOK(dbg_entryOpp, dbg_stopOpp, float(dbg_qMicroAdd), dbg_curLoss) : false  //    
bool  dbg_gateReal  = not na(dbg_projRiskReal) and (maxDailyLoss <= 0 or (dbg_curLoss + dbg_projRiskReal <= maxDailyLoss))  // (existing)

//    label only when the OppAdd decision is being evaluated (entry/fallback pulse + opposite dir)
//           do NOT include ctxOKOppAdd172 here so we still see the mismatch when the real gate blocks it
bool  dbg_oppPulseCore = ((enteredLongNow172 or enteredShortNow172) or fallbackPulse172) and (dirOpp172 != 0)  //    
bool  dbg_labelThisBar = showOppRiskDebug and dbg_oppPulseCore and dbg_gateMicro and not dbg_gateReal and (dbg_qMicroAdd > 0 and dbg_qFullAdd > 0 and dbg_addRisk > 0)  //    

//    : one-per-bar latch for the callout
var int lastOppDbgBar172 = na  //    


//    : on-chart callout â€” only when OppAdd is actually being evaluated and qty>0; includes leading spaces for readability
if dbg_labelThisBar and (na(lastOppDbgBar172) or lastOppDbgBar172 != bar_index)
    label.new(
         bar_index, close,
         "OppAdd micro OK, REAL would fail risk\n" +  //    
         "add=$" + str.tostring(dbg_addRisk) +        //    
         " qÂµ=" + str.tostring(dbg_qMicroAdd) +       //    
         " qF=" + str.tostring(dbg_qFullAdd),         //    
         style=label.style_label_down, color=color.new(color.red, 30), textcolor=color.white)  //    
    lastOppDbgBar172 := bar_index  //    

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 17.4)â”€â”€ CLOSED TRADE HANDLER: split PROFIT vs STOP, and respect aggressiveFlip toggle â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if strategy.closedtrades > closedTrades
    closedTrades := strategy.closedtrades
    tradesToday := tradesToday + 1
    int _nextNum = lastIssuedTradeNumber + 1
    placedTrades := placedTrades

    float _exit  = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float _entry = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    bool  _long  = strategy.closedtrades.size(strategy.closedtrades - 1) > 0
    bool  wasProfit = _long ? (_exit > _entry) : (_exit < _entry)

    // >>>   C: Â§17.4 Opposite-cycle gate â€” BEGIN
    int  lastIdx174 = strategy.closedtrades - 1
    int  lastDir174 = strategy.closedtrades.size(lastIdx174) > 0 ? 1 : -1
    if lastDir174 == -cycleSide
        oppOutstanding := math.max(oppOutstanding - 1, 0)
    bool allowProfitRearm174 = lastDir174 == cycleSide or (lastDir174 == -cycleSide and oppOutstanding == 0)
    // >>>   C: Â§17.4 Opposite-cycle gate â€” END

    // capture context BEFORE any resets so we can reissue on PROFIT
    bool _ctxAny = inBreakoutWindow and scoped_officialRangeStarted and not earlyExitFired and not emergencyExitSent and not sessionBlocked and not tradingHalted
    bool _tradeLimitOK = tradeLimit == 0 or lastIssuedTradeNumber < tradeLimit

    // midpoint + early-exit guard
    bool _midOK  = not requireMidpointReturn or tradesToday == 0 or (scoped_isNearMidpoint and barstate.isconfirmed) // >>> CHANGE: midpoint gate close-confirmed post-Trade1
    bool _ctxGate = _ctxAny and _midOK and not inEarlyWindow

    // decouple emit vs re-arm; always EXIT on profit, re-arm policy still uses allowProfitRearm174
    bool profitExitGate174 = wasProfit 
    bool profitRearmGate174 = wasProfit and allowProfitRearm174 and _ctxGate and _tradeLimitOK 


    if profitExitGate174
        // â–º PROFIT (or toggle OFF): original cleanup + early-exit scheduling preserved
        if not earlyExitFired
            emergencyExitBar := bar_index + 1
            emergencyExitSent := false
            waitUntilBar := bar_index + 2
            postTradeLock := bar_index + 3
        issuedLongOrder := false
        issuedShortOrder := false

        //  derive IDs from the CLOSED trade's direction (current position is flat on TP)
        bool _closedWasLong_pf = _long 
        string _thisEntry_pf = _closedWasLong_pf ? idLong : idShort 
        string _thisExit_pf = _closedWasLong_pf ? idLong + "_Exit" : idShort + "_Exit" 
        string _oppPrim_pf = _closedWasLong_pf ? idShort : idLong 
        string _oppPrimEx_pf = _closedWasLong_pf ? idShort + "_Exit" : idLong + "_Exit" 

        //  rely on f_exit_atomic for cancel+JSON (no mid-block strategy.cancel)
        
        // Atomic profit flatten + emits (chart + proxy when live)
        string chartTkr_pf = syminfo.ticker
        string proxyTkr_pf = proxyTickerPos != "" ? proxyTickerPos : f_get_proxy_ticker(chartTkr_pf)
        bool emitLabel_pf = true
        bool allowCancelSweep_pf = na(lastCancelSweepBar) or lastCancelSweepBar != bar_index  // ProfitTP may request CancelSweep once per bar
        bool doCancelAll_pf = allowCancelSweep_pf  // gate _doCancelAllBefore by per-bar latch

        bool posIsLong_pf = strategy.position_size > 0
        string thisEntry_pf = posIsLong_pf ? idLong : idShort
        string thisExit_pf  = posIsLong_pf ? idLong + "_Exit" : idShort + "_Exit"
        string oppPrim_pf   = posIsLong_pf ? idShort : idLong
        string oppPrimEx_pf = posIsLong_pf ? idShort + "_Exit" : idLong + "_Exit"

        // Single-latch de-dupe for this bar
        bool allowExit_pf = na(lastExitEmitBar) or lastExitEmitBar != bar_index
        bool allowChart_pf = allowExit_pf
        bool allowProxy_pf = allowExit_pf
        
        [didExit_pf_tmp, proxySent_pf_tmp] =
             f_exit_atomic("ProfitTP","Profit Path Flatten",close,time,tzInput,chartTkr_pf,proxyTkr_pf,emitLabel_pf,doCancelAll_pf,thisEntry_pf,thisExit_pf,oppPrim_pf,oppPrimEx_pf,allowChart_pf,allowProxy_pf)
        if allowCancelSweep_pf and doCancelAll_pf  // latch CancelSweep usage for this bar
            lastCancelSweepBar := bar_index  // 
        if didExit_pf_tmp
            lastExitEmitBar := bar_index
        if proxySent_pf_tmp and proxyTickerPos != ""
            proxyPosActive := false
            proxyTickerPos := ""
            proxyPosDir    := 0
            proxyPosQty    := 0

        // Drop any stale Opp TP overlay so next OppAdd can arm
        oppTPLineActive := false
        oppTPLineIsLong := false
        oppTPLinePrice  := na

        rearmAfterProfitPending := true        //    all PROFIT exits now use deferred re-arm (17.6)
        rearmEligibleFromBar    := bar_index + 2  //    earliest possible re-arm is bar N+2
        cycleSide               := 0           //    reset cycle state on profit before deferred re-arm
        oppOutstanding          := 0           //    reset opposite-count after profit

        // Reissue both brackets immediately on PROFIT â€” midpoint-gated downstream
        placedTrades := false
        bool _placedL = false
        bool _placedS = false

        if _ctxGate and _tradeLimitOK and oppOutstanding == 0
            _placedL := f_placeBracket(idLong,  strategy.long,  longEntry,  longStop,  longTP,  lastIssuedTradeNumber, false, _ctxGate, curLossDollars)
            _placedS := f_placeBracket(idShort, strategy.short, shortEntry, shortStop, shortTP, lastIssuedTradeNumber, false, _ctxGate, curLossDollars)

            if _placedL or _placedS
                lastIssuedTradeNumber_reason := "closed-trade-reissue"
                lastIssuedTradeNumber := lastIssuedTradeNumber + 1
                lastEntryBar := bar_index
                placedTrades := true
                rearmAfterProfitPending := false
                rearmEligibleFromBar    := na
                if showLowLevelTrace
                    label.new(bar_index, low - syminfo.mintick * 120, "Exit: Profit â€” reissued both brackets", style=label.style_label_down, color=color.teal, textcolor=color.white)
            // >>>   E1: reset cycle state after profit re-arm â€” BEGIN
            cycleSide := 0
            oppOutstanding := 0
            // >>>   E1: reset cycle state after profit re-arm â€” END

        else
            if showLowLevelTrace
                label.new(bar_index, low - syminfo.mintick * 120, "Exit: Profit â€” gating blocked reissue", style = label.style_label_down, color = color.new(color.green, 60), textcolor = color.white)
            //bool needProxyOnly_e174 = useProxyRealtimeOnly and realtimeEffective and proxyPosActive and str.length(proxyTickerPos) > 0
            bool needProxyOnly_e174 = useProxyRealtimeOnly and realtimeEffective and proxyPosActive and str.length(proxyTickerPos) > 0 and (na(lastCancelSweepBar) or lastCancelSweepBar != bar_index)  //   Skip ProfitTP-Guard if a CancelSweep already ran this bar
            if needProxyOnly_e174
                bool allowExit_guard = na(lastExitEmitBar) or lastExitEmitBar != bar_index
                bool allowChart_guard = false
                bool allowProxy_guard = allowExit_guard
                [_, proxySent_pf_guard] = f_exit_atomic("ProfitTP-Guard", "Proxy Only Exit", close, time, tzInput, "", proxyTickerPos, false, false, "", "", "", "", allowChart_guard, allowProxy_guard)
                if proxySent_pf_guard
                    lastExitEmitBar := bar_index
                if proxySent_pf_guard and proxyTickerPos != ""
                    proxyPosActive := false
                if proxySent_pf_guard and proxyTickerPos != ""
                    proxyTickerPos := ""
                if proxySent_pf_guard and proxyTickerPos != ""
                    proxyPosDir := 0
                if proxySent_pf_guard and proxyTickerPos != ""
                    proxyPosQty := 0
            oppTPLineActive := false
            oppTPLineIsLong := false
            oppTPLinePrice := na
            rearmAfterProfitPending := true
            rearmEligibleFromBar := bar_index + 1
            // >>>   E2: reset cycle state after deferred profit â€” BEGIN
            cycleSide := 0
            oppOutstanding := 0
            // >>>   E2: reset cycle state after deferred profit â€” END

    else
       // â–º STOP (toggle ON): keep opposite eligible â€” re-arm only when both sides have failed
        waitUntilBar := bar_index + 1
        postTradeLock := bar_index + 1

        // Clear the side that just stopped; leave the opposite side as-is.
        // First stop â†’ opposite side remains issued; second stop â†’ both become false â†’ re-arm.
        if _long
            issuedLongOrder := false
        else
            issuedShortOrder := false

        // Re-arm only when neither side is currently issued (i.e., after the opposite also stops).
        if not issuedLongOrder and not issuedShortOrder
            placedTrades := false
            // Optional whipsaw safety: wait 1 more bar before any new placement.
            waitUntilBar := bar_index + 1

        if _long
            strategy.cancel(idLong)
            strategy.cancel(idLong + "_Exit")
        else
            strategy.cancel(idShort)
            strategy.cancel(idShort + "_Exit")

        // NEW: inside early-exit window, do NOT keep/reissue the opposite â€” cancel it too and stand down
        if inEarlyWindow
            strategy.cancel_all()
            strategy.cancel(idLong)
            strategy.cancel(idLong + "_Exit")
            strategy.cancel(idShort)
            strategy.cancel(idShort + "_Exit")
            placedTrades := true
            if showLowLevelTrace
                label.new(bar_index, high + syminfo.mintick * 120, "Exit: Stop â€” Early Window â†’ no opposite", style=label.style_label_down, color=color.new(color.red, 10), textcolor=color.white)
        else
            if showLowLevelTrace
                label.new(bar_index, high + syminfo.mintick * 120, "Exit: Stop-Out â€” opposite left in place", style=label.style_label_down, color=color.teal, textcolor=color.white)
            
    // (Optional) immediate lock clears if already elapsed
    if not na(waitUntilBar) and bar_index >= waitUntilBar
        waitUntilBar := na
    if not na(postTradeLock) and bar_index >= postTradeLock
        postTradeLock := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 17.6) Deferred re-arm after PROFIT (midpoint-gated)
//      If immediate reissue was blocked by midpoint gating, wait until:
//      â€¢ flat, â€¢ locks cleared, â€¢ trade limit OK, â€¢ midpoint OK, â€¢ still inside session
//      Then place both brackets via f_placeBracket (restores orange label).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool _rearmLocksClear  = (na(waitUntilBar) or bar_index >= waitUntilBar) and (na(postTradeLock) or bar_index >= postTradeLock)
bool _rearmCtx         = inBreakoutWindow and scoped_officialRangeStarted and not inEarlyWindow and not earlyExitFired and not emergencyExitSent and not sessionBlocked and not tradingHalted
bool _rearmMidOK       = not requireMidpointReturn or scoped_isNearMidpoint
bool _rearmLimitOK     = tradeLimit == 0 or  lastIssuedTradeNumber < tradeLimit
bool _rearmCanPlace = rearmAfterProfitPending
                      and strategy.position_size == 0
                      and not placedTrades
                      and oppOutstanding == 0
                      and not issuedLongOrder and not issuedShortOrder
                      and _rearmCtx and _rearmMidOK and _rearmLimitOK and _rearmLocksClear
                      and (na(rearmEligibleFromBar) or bar_index >= rearmEligibleFromBar)
                      and barstate.isconfirmed

if _rearmCanPlace
    bool _wasZero = not issuedLongOrder and not issuedShortOrder
    bool _pL2 = f_placeBracket(idLong,  strategy.long,  longEntry,  longStop,  longTP,  lastIssuedTradeNumber, false, true, curLossDollars)
    bool _pS2 = f_placeBracket(idShort, strategy.short, shortEntry, shortStop, shortTP, lastIssuedTradeNumber, false, true, curLossDollars)
    if _pL2 or _pS2
        if _wasZero
            lastIssuedTradeNumber_reason := "deferred-rearm-from-zero"
            lastIssuedTradeNumber := lastIssuedTradeNumber + 1
        else
            lastIssuedTradeNumber_reason := "deferred-rearm"
        lastEntryBar := bar_index
        placedTrades := true
    rearmAfterProfitPending := false
    rearmEligibleFromBar    := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 17.7) PAIRED EXIT: when the proxy (YM) recoup hits its TP, exit the MYM leg too
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool oppTPHitLong  = oppTPLineActive and  oppTPLineIsLong and not na(oppTPLinePrice) and high >= oppTPLinePrice
bool oppTPHitShort = oppTPLineActive and not oppTPLineIsLong and not na(oppTPLinePrice) and low  <= oppTPLinePrice
bool oppTPHitNow   = oppTPHitLong or oppTPHitShort

if oppTPHitNow
    string chartTkr_px = syminfo.ticker
    string proxyTkr_px = proxyTickerPos != "" ? proxyTickerPos : f_get_proxy_ticker(chartTkr_px)
    bool emitLabel_px = true
    bool allowCancelSweep_px = na(lastCancelSweepBar) or lastCancelSweepBar != bar_index  //  allow exactly one CancelSweep per bar across all helpers
    bool doCancelAll_px = allowCancelSweep_px  // PairedExit requests cancel-all only if this bar has not swept yet

    bool inPos_px = strategy.position_size != 0  // local flag to know if chart still has an open position
    bool posIsLong_px = strategy.position_size > 0
    string thisEntry_px = posIsLong_px ? idLong : idShort
    string thisExit_px  = posIsLong_px ? idLong + "_Exit" : idShort + "_Exit"
    string oppPrim_px   = posIsLong_px ? idShort : idLong
    string oppPrimEx_px = posIsLong_px ? idShort + "_Exit" : idLong + "_Exit"

    bool allowExit_px = na(lastExitEmitBar) or lastExitEmitBar != bar_index
    bool allowChart_px = allowExit_px and inPos_px  // only emit chart Exit JSON if we still have a position at bar open
    bool allowProxy_px = allowExit_px and inPos_px  //  only emit proxy Exit JSON if we still have a position at bar open


    [didExit_px_tmp, proxySent_px_tmp] = f_exit_atomic("PairedExit: Proxy TP", "Paired Exit", nz(oppTPLinePrice, close), time, tzInput, chartTkr_px, proxyTkr_px, emitLabel_px, doCancelAll_px, thisEntry_px, thisExit_px, oppPrim_px, oppPrimEx_px, allowChart_px, allowProxy_px)

    if allowCancelSweep_px and doCancelAll_px  //  first helper that actually requested CancelSweep claims this bar
        lastCancelSweepBar := bar_index  // block further CancelSweeps from other helpers on this bar

    if didExit_px_tmp
        lastExitEmitBar := bar_index
    if proxySent_px_tmp and proxyTickerPos != ""
        proxyPosActive := false
    if proxySent_px_tmp and proxyTickerPos != ""
        proxyTickerPos := ""
    if proxySent_px_tmp and proxyTickerPos != ""
        proxyPosDir := 0
    if proxySent_px_tmp and proxyTickerPos != ""
        proxyPosQty := 0

    oppTPLineActive := false
    oppTPLineIsLong := false
    oppTPLinePrice  := na
    waitUntilBar := bar_index + 1
    postTradeLock := bar_index + 2
    rearmAfterProfitPending := true
    rearmEligibleFromBar := bar_index + 1
    placedTrades := false

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 17.8) Abort if we are nearing the end of session and are postive, bail!!
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

earlyExitTime = exitTime - earlyExitMinutes * 60000
// â”€â”€ DEBUG: show when the early-exit window opens (once)
if showLowLevelTrace and not na(earlyExitTime) and time >= earlyExitTime and time[1] < earlyExitTime
    label.new(bar_index, high + syminfo.mintick * 40, "Early Window Open â†’ " + f_iso_local(earlyExitTime, tzInput), style=label.style_label_down, color=color.new(color.gray, 20), textcolor=color.white)

if not earlyExitFired and time >= earlyExitTime and time < exitTime and strategy.position_size != 0
    float avgPrice = strategy.position_avg_price
    bool isLongPos = strategy.position_size > 0
    //If youâ€™re long (isLongPos == true), it tests close > avgPrice.
    //If youâ€™re short (isLongPos == false), it tests close < avgPrice.
    bool inProfit  = isLongPos ? close > avgPrice : close < avgPrice
    if inProfit
        if showLowLevelTrace
            label.new(bar_index, high + syminfo.mintick * 60, "Hit Strategy Close_allâ†’ " + f_iso_local(earlyExitTime, tzInput), style = label.style_label_down, color = color.new(color.gray, 20), textcolor = color.white)

        // >>>   B (FINAL): Â§17.8 Early Exit â€” REPLACE ACTION BLOCK BEGIN
        string chartTkr_e178_b3 = syminfo.ticker
        string epProxyTicker_e178_b3 = proxyTickerPos != "" ? proxyTickerPos : f_get_proxy_ticker(chartTkr_e178_b3)
        bool emitLabel_e178_b3 = true
        bool doCancelAllBefore_e178_b3 = true

        bool posIsLong_e178_b3 = strategy.position_size > 0
        string thisEntryId_e178_b3 = posIsLong_e178_b3 ? idLong : idShort
        string thisExitId_e178_b3  = posIsLong_e178_b3 ? idLong + "_Exit" : idShort + "_Exit"
        string oppPrimId_e178_b3   = posIsLong_e178_b3 ? idShort : idLong
        string oppPrimEx_e178_b3   = posIsLong_e178_b3 ? idShort + "_Exit" : idLong + "_Exit"

        bool allowExit_e178 = na(lastExitEmitBar) or lastExitEmitBar != bar_index
        bool allowChart_e178 = allowExit_e178
        bool allowProxy_e178 = allowExit_e178

        [didExit_e178_b7_tmp, proxySent_e178_b7_tmp] = f_exit_atomic("EarlyExit", "Early Positive Close Exit", close, time, tzInput, chartTkr_e178_b3, epProxyTicker_e178_b3, emitLabel_e178_b3, doCancelAllBefore_e178_b3, thisEntryId_e178_b3, thisExitId_e178_b3, oppPrimId_e178_b3, oppPrimEx_e178_b3, allowChart_e178, allowProxy_e178)

        if didExit_e178_b7_tmp
            lastExitEmitBar := bar_index
        if didExit_e178_b7_tmp
            earlyExitFired := true
        if proxySent_e178_b7_tmp and proxyTickerPos != ""
            proxyPosActive := false
        if proxySent_e178_b7_tmp and proxyTickerPos != ""
            proxyTickerPos := ""
        if proxySent_e178_b7_tmp and proxyTickerPos != ""
            proxyPosDir := 0
        if proxySent_e178_b7_tmp and proxyTickerPos != ""
            proxyPosQty := 0

        oppTPLineActive := false
        oppTPLineIsLong := false
        oppTPLinePrice  := na
    // >>>   B (FINAL): Â§17.8 Early Exit â€” REPLACE ACTION BLOCK END


        // >>>   B (FINAL): Â§17.8 Early Exit â€” REPLACE ACTION BLOCK END

        // >>>   C: remove old unconditional latch â€” BEGIN
        // Find this line inside Â§17.8 (after the label) and replace it:
        //     earlyExitFired := true
        // with this single line (re-uses didExit_178 from   B, which is in scope):
        earlyExitFired := didExit_e178_b7_tmp ? true : earlyExitFired
        // >>>   C: remove old unconditional latch â€” END


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 17.9) Extra Exit Code (clean up bad state, it happens!)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Cleanup: executes on every bar at or after exit
// Cleanup: single-shot EOS cleanup on first bar at or after exit  // gate EOS to session-cross only
if time[0] >= exitTime 
    bool eosCleanupArmed = tradesToday > 0 or strategy.position_size != 0 or proxyPosActive or issuedLongOrder or issuedShortOrder or placedTrades or oppOutstanding != 0  //    only send EOS CancelSweep/Exit when something could still be live
    if eosCleanupArmed
        string chartTkr_eos = syminfo.ticker
        string proxyTkr_eos = proxyTickerPos != "" ? proxyTickerPos : f_get_proxy_ticker(chartTkr_eos)
        bool emitLabel_eos = true
        bool allowCancelSweep_eos = na(lastCancelSweepBar) or lastCancelSweepBar != bar_index  //    EOS may request CancelSweep once per bar
        bool doCancelAll_eos = allowCancelSweep_eos  //    gate _doCancelAllBefore by per-bar latch


        bool posIsLong_eos = strategy.position_size > 0
        string thisEntry_eos = posIsLong_eos ? idLong : idShort
        string thisExit_eos  = posIsLong_eos ? idLong + "_Exit" : idShort + "_Exit"
        string oppPrim_eos   = posIsLong_eos ? idShort : idLong
        string oppPrimEx_eos = posIsLong_eos ? idShort + "_Exit" : idLong + "_Exit"

        bool allowExit_eos = na(lastExitEmitBar) or lastExitEmitBar != bar_index
        bool allowChart_eos = allowExit_eos
        bool allowProxy_eos = allowExit_eos

        [didExit_eos_tmp, proxySent_eos_tmp] = f_exit_atomic("EOS", "End Of Session", close, time, tzInput, chartTkr_eos, proxyTkr_eos, emitLabel_eos, doCancelAll_eos, thisEntry_eos, thisExit_eos, oppPrim_eos, oppPrimEx_eos, allowChart_eos, allowProxy_eos)

        if allowCancelSweep_eos and doCancelAll_eos  //    latch CancelSweep usage for this bar
            lastCancelSweepBar := bar_index  //    

        //if didExit_eos_tmp
        //    lastExitEmitBar := bar_index

        if allowExit_eos
            lastExitEmitBar := bar_index  // block duplicate helper calls on same bar even when didExit_eos_tmp is false

        if proxySent_eos_tmp and proxyTickerPos != ""
            proxyPosActive := false
        if proxySent_eos_tmp and proxyTickerPos != ""
            proxyTickerPos := ""
        if proxySent_eos_tmp and proxyTickerPos != ""
            proxyPosDir := 0
        if proxySent_eos_tmp and proxyTickerPos != ""
            proxyPosQty := 0

    resetTimes := true
    lastIssuedTradeNumber_reason := "session-reset"
    lastIssuedTradeNumber := 0
    sizingSnapTaken := false
    sLongEntry := na
    sShortEntry := na
    sLongStop := na
    sShortStop := na
    sLongTP := na
    sShortTP := na
    sessionSnapTaken := false
    sessionValidFrozen := true
    sessionInvalidReasonFrozen := ""
    oppTPLineActive := false
    oppTPLineIsLong := false
    oppTPLinePrice := na
    scoped_officialRangeStarted := false
    scoped_actualRangeStart := na
    rearmAfterProfitPending := false
    rearmEligibleFromBar := na

    // >>>   I: EOS â€” reset cycle state
    cycleSide := 0
    oppOutstanding := 0


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 18) PLOTS/Data Windows (precompute series, no ternaries inside plot())
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
plot(longEntry,  title="Long Entry",  style=plot.style_linebr, color=color.aqua)
plot(shortEntry, title="Short Entry", style=plot.style_linebr, color=color.aqua)
plot(longTP,    title="Long TP",    style=plot.style_linebr,   color=color.green)
plot(shortTP,   title="Short TP",   style=plot.style_linebr,   color=color.green)

// Opposite-side TP overlay (persists until session reset)
// Precompute visibility
bool drawOppLongTP = oppTPLineActive and oppTPLineIsLong
bool drawOppShortTP = oppTPLineActive and not oppTPLineIsLong
float pOppLongTP  = drawOppLongTP  ? oppTPLinePrice : na
float pOppShortTP = drawOppShortTP ? oppTPLinePrice : na
plot(pOppLongTP,  title="Opp Long TP (Opposite Taken)",  style=plot.style_linebr, color=color.new(color.green, 50))
plot(pOppShortTP, title="Opp Short TP (Opposite Taken)", style=plot.style_linebr, color=color.new(color.green, 50))

plot(longStop, style=plot.style_linebr, color=color.yellow, title="Long Stop")
plot(shortStop, style=plot.style_linebr, color=color.orange, title="Short Stop")
plot(tpSize / syminfo.mintick, title="TP Ticks", style=plot.style_linebr, color=color.green, display=display.data_window)
plot(stopSize  / syminfo.mintick, title="Stop Ticks", style=plot.style_linebr, color=color.red, display=display.data_window)
plot(longEntry - shortEntry, title="Range Size", style=plot.style_linebr, color=color.yellow, display=display.data_window)
plot(f_calcPositionSize(longEntry, longStop), title="Position Size", style=plot.style_linebr, color=color.orange, display=display.data_window)
plot(inBreakoutWindow ? tradeLimit : na, title="Active Trade Limit", color=color.orange, display=display.data_window)

// VWAP/VWMA plotting guard
//bool drawVW = showVWAPComponents and (inDefine or inBreakoutWindow) and realtimeEffective
//float vwmaRaw = ta.vwma(close, vwapLen)
//float vwapRaw = ta.vwap(hlc3)
//float vwapFallback = na(vwapRaw) ? vwmaRaw : vwapRaw
//float pVWMA = drawVW ? vwmaRaw : na
//float pVWAP = drawVW ? vwapFallback : na
//plot(pVWMA, title="Session VWMA", style=plot.style_linebr, color=color.orange)
//plot(pVWAP, title="Session VWAP", style=plot.style_linebr, color=color.purple)


// === Data Window display only for filters
plot(dayHigh - dayLow, title="Range Width", color=color.blue, display=display.data_window)
plot(minRangePoints, title="Min Allowed Range", color=color.blue, display=display.data_window)
plot(maxRangePoints, title="Max Allowed Range", color=color.blue, display=display.data_window)

// === Data Window Logging of Filter Status ===
plot(sessionValid ? 1 : 0, title="Session Valid", color=color.gray, display=display.data_window)
plotchar(na(sessionInvalidReason) ? na : 1, title="Session Reason Exists", char='âŸ¶', location=location.top, display=display.data_window)

// AFTER â€” Data Window helpers for override status/value (no chart clutter)
plot(oppTPOverrideActive ? 1 : na, title="Opp TP Override Active", display=display.data_window)
plot(oppTPOverrideActive ? oppositeTpOverride : na, title="Opp TP Override Value", display=display.data_window)
plot(pOppLongStopAdj172,  title = "Opp Add Long Stop (Adj)",  style = plot.style_linebr, color = color.new(color.yellow, 60))
plot(pOppShortStopAdj172, title = "Opp Add Short Stop (Adj)", style = plot.style_linebr, color = color.new(color.orange, 60))
plot(recoupTradeStop172, title = "Recoup Trade Stop", display = display.data_window, color = color.new(color.gray, 0))
// â”€â”€ Data Window: everything needed to reconcile live vs backtest
plot(dbg_baseRiskExist,       title="OppDbg Base Risk ($)",       display=display.data_window)  //   
plot(dbg_targetRisk,          title="OppDbg Target Risk ($)",     display=display.data_window)  //   
plot(dbg_addRisk,             title="OppDbg Add Risk Need ($)",   display=display.data_window)  //   
plot(dbg_riskPerMicroOpp,     title="OppDbg Risk/1 Micro ($)",    display=display.data_window)  //   
plot(dbg_qMicroAdd,           title="OppDbg qMicroAdd (int)",     display=display.data_window)  //   
plot(dbg_qFullAdd,            title="OppDbg qFullAdd (live)",     display=display.data_window)  //   
plot(dbg_projRiskMicro,       title="OppDbg ProjRisk Micro ($)",  display=display.data_window)  //   
plot(dbg_projRiskReal,        title="OppDbg ProjRisk Real ($)",   display=display.data_window)  //   
plot(dbg_gateMicro ? 1 : 0,   title="OppDbg Gate Micro OK",       display=display.data_window)  //   
plot(dbg_gateReal  ? 1 : 0,   title="OppDbg Gate Real OK",        display=display.data_window)  //   
plotchar(barstate.isrealtime, title="OppDbg Live Flag", char='â—', location=location.top, display=display.data_window)  //   

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“Š Data Window Debug Plots for Deferred Start
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
plot(scoped_officialRangeStarted ? 1 : 0, title="Scoped Official Range Started", color=color.purple, display=display.data_window)
plot(midpointStartTolerancePct > 0 ? 1 : 0, title="Deferred Start Proximity Filter Enabled", color=color.fuchsia, display=display.data_window)
plot(midpointStartTolerancePct, title = "Midpoint Proximity Percent %", display = display.data_window, color = na)
plot(scoped_inBreakoutWindow ? 1 : 0, title="Scoped In Breakout Window", color=color.red, display=display.data_window)
plot(scoped_inDeferredBreakout ? 1 : 0, title="Scoped Deferred Breakout", color=color.orange, display=display.data_window)
plot(scoped_isNearMidpoint ? 1 : 0, title="Scoped Near Midpoint", color=color.yellow, display=display.data_window)
plot(scoped_rangeMidpoint, title="Scoped Range Midpoint", color=color.gray, display=display.data_window)
plot(scoped_rangeWidth, title="Scoped Range Width", color=color.blue, display=display.data_window)
plot(tradingHalted ? 1 : 0, title="Trading Halted", display=display.data_window)

plot(math.abs(close - scoped_rangeMidpoint), title="Midpoint Distance", color=color.fuchsia, display=display.data_window)
plot(scoped_rangeWidth * midpointStartTolerancePct / 100, title="Allowed Deviation", color=color.teal, display=display.data_window)
// Data-window helpers
plot(_midEligible_now ? 1 : 0, title="Midpoint Eligible Now", display=display.data_window, color=color.purple)
plot(_midWouldLatch ? 1 : 0, title="Midpoint Would Latch (on close)", display=display.data_window, color=color.purple)
plot(_entryCtxAllOK ? 1 : 0, title="Entry Context OK (post-latch)", display=display.data_window, color=color.teal)


bool officialStartEffectiveDW = scoped_officialRangeStarted or not na(scoped_actualRangeStart)
plot(officialStartEffectiveDW ? 1 : 0, title="Official Start Effective", color=color.purple, display=display.data_window)
plot(lastIssuedTradeNumber, title="Last Issued Trade #", display=display.data_window)


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 19) SESSION INFO PANEL (lightweight; day-by-day)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var float lastEntryPrice = na
var bool lastWasLong = false
var bool lastWasLongValid = false
var int lastClosedTrades = 0
var float plPoints = na
var float qty = na

var float debugLastEntry = na
var bool debugLastWasLong = false
var bool debugTradeArmed = false

showSessionBox = input.bool(true, "Show Session Info Box", tooltip="Displays session stats", group="Display Settings")

//  performance â€” cache & recompute only when session/policy changes; single-pass future scan

// policy signature (sev toggles + policyByTypeId checksum)
f_policySig() =>
    int _sevBits = (useSev1Filter ? 1 : 0) + (useSev2Filter ? 2 : 0) + (useSev3Filter ? 4 : 0)
    int _modeBits = useSev3TimeWindow ? 8 : 0  // ðŸŸ§ PATCH: intraday delay mode participates in cache key
    int _sum = 0
    int _rows = array.size(policyByTypeId)
    for _i = 0 to _rows - 1
        int _pol = array.get(policyByTypeId, _i)
        _sum += (_pol + 1) * (_i + 1)
    (_sevBits + _modeBits) * 1000000 + sev3PostDelayMin * 1000 + _sum

// Tick to point and $ conversion helpers
f_ticksToPoints(_raw) => _raw  //    : price diff already in points for futures; remove hard-coded divisors
f_dollars(_pts, _qty) => (_pts * syminfo.pointvalue * math.abs(_qty)) - strategy.closedtrades.commission(strategy.closedtrades - 1)  // last-closed trade net ($)



// helper â€” convert "YYYY-MM-DD" to comparable int key (YYYYMMDD)
f_dateKeyFromStr(_s) =>
    int _yy = int(str.tonumber(str.substring(_s, 0, 4)))  
    int _mm = int(str.tonumber(str.substring(_s, 5, 7)))  
    int _dd = int(str.tonumber(str.substring(_s, 8, 10))) 
    _yy * 10000 + _mm * 100 + _dd                         

// helper â€” evaluate if a given YYYY-MM-DD is blocked by current toggles; returns [blocked, reasons, maxSev]
f_evalNewsForDate(_dateStr) =>
    bool _blocked = false
    string _reasons = ""
    int _maxSev = 0
    int _rows = array.size(arrDateStr)  // renamed from _N to avoid shadowing
    for _i = 0 to _rows - 1
        string _d = array.get(arrDateStr, _i)
        bool _same = _d == _dateStr
        if _same
            int _tid = array.get(arrTypeId, _i)
            int _sev = array.get(typeSevByTypeId, _tid)
            int _pol = array.get(policyByTypeId, _tid)
            bool _sevEnabled = (_sev == 3 and useSev3Filter) or (_sev == 2 and useSev2Filter) or (_sev == 1 and useSev1Filter)  // severity gate
            bool _blocks = false
            bool _allDay = false
            bool _timed = false
            if _pol == POLICY_ALLDAY
                _blocks := true
                _allDay := true
            if _pol == POLICY_DELAY
                _blocks := true
                _timed := true
            if _pol == POLICY_INHERIT
                _blocks := _sevEnabled
                _timed := _sevEnabled
            bool _timeValid = true
            if useSev3TimeWindow and _blocks and not _allDay and _timed
                int _tMs = array.get(arrTimeMS, _i)
                _timeValid := _tMs > 0 and _tMs < 86400000  // ðŸŸ¦ PATCH: invalid times ignored in intraday delay mode
            bool _invalidate = _timeValid and _blocks and (_allDay or not useSev3TimeWindow)
            if _invalidate
                string _nm = switch _tid
                    TYPE_CPI_m_m => "CPI m/m"
                    TYPE_CPI_y_y => "CPI y/y"
                    TYPE_Core_CPI_m_m => "Core CPI m/m"
                    TYPE_Core_PPI_m_m => "Core PPI m/m"
                    TYPE_FOMC_Economic_Projections => "FOMC Economic Projections"
                    TYPE_FOMC_Meeting_Minutes => "FOMC Meeting Minutes"
                    TYPE_Federal_Funds_Rate => "Federal Funds Rate"
                    TYPE_ISM_Manufacturing_PMI => "ISM Manufacturing PMI"
                    TYPE_ISM_Services_PMI => "ISM Services PMI"
                    TYPE_Non_Farm_Employment_Change => "Non-Farm Employment Change"
                    TYPE_PPI_m_m => "PPI m/m"
                    TYPE_President_Trump_Speaks => "President Trump Speaks"
                    TYPE_Unemployment_Rate => "Unemployment Rate"
                    TYPE_Core_PCE_Price_Index_m_m => "Core PCE Price Index m/m"
                    TYPE_Core_Retail_Sales_m_m => "Core Retail Sales m/m"
                    TYPE_FOMC_Press_Conference => "FOMC Press Conference"
                    TYPE_FOMC_Statement => "FOMC Statement"
                    TYPE_Fed_Chair_Powell_Speaks => "Fed Chair Powell Speaks"
                    TYPE_Fed_Chair_Powell_Testifies => "Fed Chair Testifies"
                    TYPE_Retail_Sales_m_m => "Retail Sales m/m"
                    TYPE_ADP_Non_Farm_Employment_Change => "ADP Non-Farm Employment Change"
                    TYPE_Advance_GDP_q_q => "Advance GDP q/q"
                    TYPE_Average_Hourly_Earnings_m_m => "Average Hourly Earnings m/m"
                    TYPE_Employment_Cost_Index_q_q => "Employment Cost Index q/q"
                    TYPE_Final_GDP_q_q => "Final GDP q/q"
                    TYPE_Flash_Manufacturing_PMI => "Flash Manufacturing PMI"
                    TYPE_Flash_Services_PMI => "Flash Services PMI"
                    TYPE_JOLTS_Job_Openings => "JOLTS Job Openings"
                    TYPE_Jackson_Hole_Symposium => "Jackson Hole Symposium"
                    TYPE_Prelim_GDP_q_q => "Prelim GDP q/q"
                    TYPE_Prelim_UoM_Consumer_Sentiment => "Prelim UoM Consumer Sentiment"
                    TYPE_Prelim_UoM_Inflation_Expectations => "Prelim UoM Inflation Expectations"
                    TYPE_Unemployment_Claims => "Unemployment Claims"
                    TYPE_Business_Inventories_m_m => "Business Inventories m/m"
                    TYPE_Capacity_Utilization_Rate => "Capacity Utilization Rate"
                    TYPE_Crude_Oil_Inventories => "Crude Oil Inventories"
                    TYPE_Existing_Home_Sales => "Existing Home Sales"
                    TYPE_Industrial_Production_m_m => "Industrial Production m/m"
                    TYPE_NAHB_Housing_Market_Index => "NAHB Housing Market Index"
                    TYPE_Natural_Gas_Storage => "Natural Gas Storage"
                    TYPE_Personal_Spending_m_m => "Personal Spending m/m"
                    TYPE_Personal_Income_m_m => "Personal Income m/m"
                    TYPE_Philly_Fed_Manufacturing_Index => "Philly Fed Manufacturing Index"
                    TYPE_Revised_UoM_Inflation_Expectations => "Revised UoM Inflation Expectations"
                    TYPE_Revised_UoM_Consumer_Sentiment => "Revised UoM Consumer Sentiment"
                    TYPE_10_y_Bond_Auction => "10-y Bond Auction"
                    TYPE_30_y_Bond_Auction => "30-y Bond Auction"
                    TYPE_ADP_Weekly_Employment_Change => "ADP Weekly Employment Change"
                    TYPE_API_Weekly_Statistical_Bulletin => "API Weekly Statistical Bulletin"
                    TYPE_Advance_GDP_Price_Index_q_q => "Advance GDP Price Index q/q"
                    TYPE_Bank_Holiday => "Bank Holiday"
                    TYPE_Bank_Stress_Test_Results => "Bank Stress Test Results"
                    TYPE_Beige_Book => "Beige Book"
                    TYPE_Building_Permits => "Building Permits"
                    TYPE_CB_Consumer_Confidence => "CB Consumer Confidence"
                    TYPE_CB_Leading_Index_m_m => "CB Leading Index m/m"
                    TYPE_Challenger_Job_Cuts_y_y => "Challenger Job Cuts y/y"
                    TYPE_Chicago_PMI => "Chicago PMI"
                    TYPE_Cleveland_Fed_Inflation_Expectations => "Cleveland Fed Inflation Expectations"
                    TYPE_Construction_Spending_m_m => "Construction Spending m/m"
                    TYPE_Consumer_Credit_m_m => "Consumer Credit m/m"
                    TYPE_Core_Durable_Goods_Orders_m_m => "Core Durable Goods Orders m/m"
                    TYPE_Current_Account => "Current Account"
                    TYPE_Daylight_Saving_Time_Shift => "Daylight Saving Time Shift"
                    TYPE_Durable_Goods_Orders_m_m => "Durable Goods Orders m/m"
                    TYPE_Empire_State_Manufacturing_Index => "Empire State Manufacturing Index"
                    TYPE_FOMC_Financial_Stability_Report => "FOMC Financial Stability Report"
                    TYPE_FOMC_Member_Barkin_Speaks => "FOMC Member Barkin Speaks"
                    TYPE_FOMC_Member_Barr_Speaks => "FOMC Member Barr Speaks"
                    TYPE_FOMC_Member_Bostic_Speaks => "FOMC Member Bostic Speaks"
                    TYPE_FOMC_Member_Bowman_Speaks => "FOMC Member Bowman Speaks"
                    TYPE_FOMC_Member_Collins_Speaks => "FOMC Member Collins Speaks"
                    TYPE_FOMC_Member_Cook_Speaks => "FOMC Member Cook Speaks"
                    TYPE_FOMC_Member_Daly_Speaks => "FOMC Member Daly Speaks"
                    TYPE_FOMC_Member_Goolsbee_Speaks => "FOMC Member Goolsbee Speaks"
                    TYPE_FOMC_Member_Hammack_Speaks => "FOMC Member Hammack Speaks"
                    TYPE_FOMC_Member_Harker_Speaks => "FOMC Member Harker Speaks"
                    TYPE_FOMC_Member_Jefferson_Speaks => "FOMC Member Jefferson Speaks"
                    TYPE_FOMC_Member_Kashkari_Speaks => "FOMC Member Kashkari Speaks"
                    TYPE_FOMC_Member_Kugler_Speaks => "FOMC Member Kugler Speaks"
                    TYPE_FOMC_Member_Logan_Speaks => "FOMC Member Logan Speaks"
                    TYPE_FOMC_Member_Miran_Speaks => "FOMC Member Miran Speaks"
                    TYPE_FOMC_Member_Musalem_Speaks => "FOMC Member Musalem Speaks"
                    TYPE_FOMC_Member_Paulson_Speaks => "FOMC Member Paulson Speaks"
                    TYPE_FOMC_Member_Schmid_Speaks => "FOMC Member Schmid Speaks"
                    TYPE_FOMC_Member_Waller_Speaks => "FOMC Member Waller Speaks"
                    TYPE_FOMC_Member_Williams_Speaks => "FOMC Member Williams Speaks"
                    TYPE_Factory_Orders_m_m => "Factory Orders m/m"
                    TYPE_Fed_Monetary_Policy_Report => "Fed Monetary Policy Report"
                    TYPE_Federal_Budget_Balance => "Federal Budget Balance"
                    TYPE_Final_GDP_Price_Index_q_q => "Final GDP Price Index q/q"
                    TYPE_Final_Manufacturing_PMI => "Final Manufacturing PMI"
                    TYPE_Final_Services_PMI => "Final Services PMI"
                    TYPE_Final_Wholesale_Inventories_m_m => "Final Wholesale Inventories m/m"
                    TYPE_Goods_Trade_Balance => "Goods Trade Balance"
                    TYPE_HPI_m_m => "HPI m/m"
                    TYPE_Housing_Starts => "Housing Starts"
                    TYPE_ISM_Manufacturing_Prices => "ISM Manufacturing Prices"
                    TYPE_Import_Prices_m_m => "Import Prices m/m"
                    TYPE_Loan_Officer_Survey => "Loan Officer Survey"
                    TYPE_Mortgage_Delinquencies => "Mortgage Delinquencies"
                    TYPE_NFIB_Small_Business_Index => "NFIB Small Business Index"
                    TYPE_New_Home_Sales => "New Home Sales"
                    TYPE_Pending_Home_Sales_m_m => "Pending Home Sales m/m"
                    TYPE_Prelim_Benchmark_Payrolls_Revision => "Prelim Benchmark Payrolls Revision"
                    TYPE_Prelim_GDP_Price_Index_q_q => "Prelim GDP Price Index q/q"
                    TYPE_Prelim_Nonfarm_Productivity_q_q => "Prelim Nonfarm Productivity q/q"
                    TYPE_Prelim_Unit_Labor_Costs_q_q => "Prelim Unit Labor Costs q/q"
                    TYPE_Prelim_Wholesale_Inventories_m_m => "Prelim Wholesale Inventories m/m"
                    TYPE_RCM_TIPP_Economic_Optimism => "RCM/TIPP Economic Optimism"
                    TYPE_Revised_Nonfarm_Productivity_q_q => "Revised Nonfarm Productivity q/q"
                    TYPE_Revised_Unit_Labor_Costs_q_q => "Revised Unit Labor Costs q/q"
                    TYPE_Richmond_Manufacturing_Index => "Richmond Manufacturing Index"
                    TYPE_S_P_CS_Composite_20_HPI_y_y => "S&P/CS Composite-20 HPI y/y"
                    TYPE_TIC_Long_Term_Purchases => "TIC Long-Term Purchases"
                    TYPE_Trade_Balance => "Trade Balance"
                    TYPE_Treasury_Currency_Report => "Treasury Currency Report"
                    TYPE_Wards_Total_Vehicle_Sales => "Wards Total Vehicle Sales"
                    => "News"
                bool _dupe = str.contains("|" + _reasons + "|", "|" + _nm + "|")
                _reasons := _dupe ? _reasons : (_reasons == "" ? _nm : _reasons + ", " + _nm)
                _maxSev := _sev > _maxSev ? _sev : _maxSev
                _blocked := true
    [_blocked, _reasons, _maxSev]
// caches (persist across bars)
var int    _policySig_cache = na                 
var string _sessionDate_cache = ""               
var bool   _willTrade_cache = true               
var string _reasons_cache = ""                   
var int    _sev_cache = 0                      
var string _nextBlockDate_cache = na             
var string _nextBlockReasons_cache = ""          
var int    _nextBlockSev_cache = 0               
var string _nextAllowed_cache = na               

// lightweight outputs (series fed from caches)
bool willTradePreview = false   //bools canâ€™t be na; init with false, then overwrite from cache below
string newsReasonsPreview = ""
int newsMaxSevPreview = 0
string nextBlockingDateStr = na
string nextBlockingReasons = ""
int nextBlockingMaxSev = 0
string nextAllowedDateStr = na
string sev3DelayedUntilText = ""  // Sev 3 intraday resume time formatted as "HH:MM am/pm" for all UI surfaces
int sev3DelayedHHMM = na  // Sev 3 resume time for Data Window (HHMM, e.g., 730 = 7:30)

// recompute only when session date or policy toggles change
int _curSig = f_policySig()
bool _sessionChanged = _sessionDate_cache != sessionDateStr
bool _policyChanged  = na(_policySig_cache) or _curSig != _policySig_cache
bool _needRecompute  = _sessionChanged or _policyChanged

if _needRecompute
    // inside: if _needRecompute
    [ _blockedToday, _reasonsToday, _sevToday ] = f_evalNewsForDate(sessionDateStr)
    _willTrade_cache := not _blockedToday
    _reasons_cache := _reasonsToday
    _sev_cache := _sevToday

    // future scan over event table (order-independent; pick first future blocked date by date key)
    string _earliestDate = na
    string _earliestReasons = ""
    int _earliestSev = 0
    int _rows = array.size(arrDateStr)
    int _sessKey = f_dateKeyFromStr(sessionDateStr)
    int _earliestKey = 0
    for _i = 0 to _rows - 1
        string _d = array.get(arrDateStr, _i)
        if _d != ""
            int _dKey = f_dateKeyFromStr(_d)
            bool _haveEarliest = not na(_earliestDate)
            bool _isFuture = _dKey > _sessKey
            bool _isBetter = not _haveEarliest or _dKey < _earliestKey
            if _isFuture and _isBetter
                [ _blkFuture, _reasonsFuture, _sevFuture ] = f_evalNewsForDate(_d)
                if _blkFuture
                    _earliestDate := _d
                    _earliestReasons := _reasonsFuture
                    _earliestSev := _sevFuture
                    _earliestKey := _dKey

    _nextBlockDate_cache := _earliestDate
    _nextBlockReasons_cache := _earliestReasons
    _nextBlockSev_cache := _earliestSev

    // next allowed â€” only if blocked today; short capped walk (â‰¤14 days)
    _nextAllowed_cache := na
    if _blockedToday
        int _yy = year(rangeEnd, tzInput)
        int _mm = month(rangeEnd, tzInput)
        int _dd = dayofmonth(rangeEnd, tzInput)
        int _baseMid = timestamp(tzInput, _yy, _mm, _dd, 0, 0)
        for _k = 1 to 14
            int _t = _baseMid + _k * 86400000
            int _yN = year(_t, tzInput)
            int _mN = month(_t, tzInput)
            int _dN = dayofmonth(_t, tzInput)
            string _dstr = str.tostring(_yN) + "-" + str.tostring(_mN, "00") + "-" + str.tostring(_dN, "00")
            [ _blk, _ignoredReasons, _ignoredSev ] = f_evalNewsForDate(_dstr)
            if not _blk
                _nextAllowed_cache := _dstr
                break

    _sessionDate_cache := sessionDateStr
    _policySig_cache := _curSig

// feed series outputs from caches (cheap every bar)
willTradePreview := _willTrade_cache
newsReasonsPreview := _reasons_cache
newsMaxSevPreview := _sev_cache
nextBlockingDateStr := _nextBlockDate_cache
nextBlockingReasons := _nextBlockReasons_cache
nextBlockingMaxSev := _nextBlockSev_cache
nextAllowedDateStr := _nextAllowed_cache

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Sev 3 News Resume Time Text (UI + Data Window)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sev3DelayedUntilText := ""  // ðŸŸ¥ PATCH: reset each bar (replay-safe; removes decimal-time bug)
sev3DelayedHHMM := na  // ðŸŸ¥ PATCH: reset each bar (HHMM numeric for Data Window)
int _curMinutesDW = hour(time, tzInput) * 60 + minute(time, tzInput)  // ðŸŸ¥ PATCH: replay-safe current minutes
int _curMsDW = _curMinutesDW * 60000  // ðŸŸ¥ PATCH: current ms from midnight
bool _sev3DelayActive = useSev3TimeWindow and useSev3Filter and not na(sev3ReleaseMs) and _curMsDW < sev3ReleaseMs  // ðŸŸ¥ PATCH: active Sev 3 delay window
if _sev3DelayActive
    int _relMinutesDW = int(math.floor(sev3ReleaseMs / 60000))  // ðŸŸ¥ PATCH: force integer minutes
    int _maxDayMinutesDW = 23 * 60 + 59  // ðŸŸ¥ PATCH
    if _relMinutesDW < 0
        _relMinutesDW := 0
    if _relMinutesDW > _maxDayMinutesDW
        _relMinutesDW := _maxDayMinutesDW
    int _hh24DW = int(math.floor(_relMinutesDW / 60))  // ðŸŸ¥ PATCH
    int _mmDW = _relMinutesDW - _hh24DW * 60  // ðŸŸ¥ PATCH
    int _hh12DW = _hh24DW % 12  // ðŸŸ¥ PATCH
    if _hh12DW == 0
        _hh12DW := 12
    string _suffixDW = _hh24DW >= 12 ? "pm" : "am"  // ðŸŸ¥ PATCH
    sev3DelayedUntilText := str.format("{0}:{1} {2}", str.tostring(_hh12DW), str.tostring(_mmDW, "00"), _suffixDW)  // ðŸŸ¥ PATCH: e.g., "7:04 am"
    sev3DelayedHHMM := _hh24DW * 100 + _mmDW  // ðŸŸ¥ PATCH: e.g., 704 == 07:04


// unify UI strings so label & table always match (single source of truth)
string uiNextBlockDate  = na(nextBlockingDateStr) ? "None" : nextBlockingDateStr
string uiNextBlockEvent = na(nextBlockingDateStr) ? "â€”" : nextBlockingReasons + (nextBlockingMaxSev > 0 ? " â€¢ Sev " + str.tostring(nextBlockingMaxSev) : "")

// telemetry: willTradePreview bit to Data Window
plot(willTradePreview ? 1 : 0, title="Will Trade Today (News Preview)", display=display.data_window, color=color.new(color.green, 0))

// If armed from bracket logic
if debugTradeArmed and na(lastEntryPrice)
    lastEntryPrice := debugLastEntry
    lastWasLong := debugLastWasLong
    lastWasLongValid := true

// Detect trade closed
if strategy.closedtrades > lastClosedTrades
    lastClosedTrades := strategy.closedtrades
    float exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    qty := strategy.closedtrades.size(strategy.closedtrades - 1)

    if showPnLIndicators == "Yes" and qty != 0 and not na(entryPrice) and not na(exitPrice)
        bool isLong = qty > 0
        float rawPL = isLong ? (exitPrice - entryPrice) : (entryPrice - exitPrice)
        plPoints := f_ticksToPoints(rawPL)
        float dollarPL = f_dollars(plPoints, qty)

        string labelText = "P/L: " + str.tostring(plPoints, "#.##") + " pts, $" + str.tostring(dollarPL, "#.##") + " [" + (isLong ? "Long" : "Short") + "]"
        bool isProfit = plPoints > 0
        color labelColor = isProfit ? color.green : color.red
        //float yOffset = syminfo.mintick * 75
        //bool placeAbove = (isLong and isProfit) or (not isLong and not isProfit)
        //float yPos = placeAbove ?  (high + yOffset) : (low - yOffset)
        //labelStyle = placeAbove ? label.style_label_down : label.style_label_up
        // Place profits above the bar, losses below (prevents overlap on same bar)
        float yOffsetProfit = syminfo.mintick * 90
        float yOffsetLoss   = syminfo.mintick * 90
        bool  placeAbove    = isProfit
        float yPos          = isProfit ? (high + yOffsetProfit) : (low - yOffsetLoss)
        labelStyle          = isProfit ? label.style_label_down : label.style_label_up        
        // If the prior bar also had a profit label, bump this one higher to avoid overlap
        int _bumpSteps = isProfit and not na(lastProfitLblBar) and bar_index == lastProfitLblBar + 1 ? 1 : 0
        float _bump = syminfo.mintick * 60 * _bumpSteps
        yPos := isProfit ? (yPos + _bump) : yPos
        label.new(bar_index, yPos, labelText, style=labelStyle, color=labelColor, textcolor=color.white, size=size.small)

        // Track last profit bar index
        if isProfit
            lastProfitLblBar := bar_index

    lastEntryPrice := na
    lastWasLongValid := false
    debugTradeArmed := false

plot(plPoints, title="PL Points", display=display.data_window, color=color.green)
plot(qty, title="Last Trade Qty", display=display.data_window, color=color.orange)
//plot((not na(rangeStart) and not na(exitTime) and time >= rangeStart and time <= exitTime) ? f_calcSessionPL(rangeStart, exitTime) : na, title="Session PnL ($)", color=color.fuchsia, display=display.data_window)

f_getPLTextColor(_pl) => _pl > 0 ? color.green : _pl < 0 ? color.red : color.white

// precompute numeric key for session date (fixes string '>' comparison error)
int sessionDateKey = f_dateKeyFromStr(sessionDateStr)  


// pre-session L1 status label (3pm prior local day; gated by L1/debug labels)
var string _lastStatusDateStr = ""
var int _lastStatusNoticeBar = na
int _yy_lbl = year(rangeEnd, tzInput)
int _mm_lbl = month(rangeEnd, tzInput)
int _dd_lbl = dayofmonth(rangeEnd, tzInput)
int _sess15 = timestamp(tzInput, _yy_lbl, _mm_lbl, _dd_lbl, 15, 0)
int _prevDayMark = _sess15 - 86400000
int _py = year(_prevDayMark, tzInput)
int _pm = month(_prevDayMark, tzInput)
int _pd = dayofmonth(_prevDayMark, tzInput)
int preNoticeTime = timestamp(tzInput, _py, _pm, _pd, 15, 0)
bool _crossedPreNotice = time[1] < preNoticeTime and time >= preNoticeTime  //  : one-bar cross gate
bool _canEmit = showDebugLabels and _crossedPreNotice and _lastStatusDateStr != sessionDateStr  //  

if _canEmit
    string _nextBlockTxtLbl = uiNextBlockDate == "None" ? "None" : uiNextBlockDate + " (" + uiNextBlockEvent + ")"
    string _txt = willTradePreview
         ? ("Trading Today. Next Block: " + _nextBlockTxtLbl)
         : ("Blocked Today (" + newsReasonsPreview + (newsMaxSevPreview > 0 ? " â€¢ Sev " + str.tostring(newsMaxSevPreview) : "") + "). Next Allowed Date: " + (na(nextAllowedDateStr) ? "Unknown" : nextAllowedDateStr))
    color _col = willTradePreview ? color.new(color.green, 20) : color.new(color.red, 20)
    label.new(bar_index, high + syminfo.mintick * 300, _txt, style=label.style_label_down, color=_col, textcolor=color.white, size=size.normal)
    log.info("STATUS " + sessionDateStr + " â€” " + _txt)
    _lastStatusDateStr := sessionDateStr
    _lastStatusNoticeBar := bar_index

// ðŸ›¡ï¸ Snapshot only when trades are present and during session window
if time >= rangeStart and time <= exitTime and tradesToday > 0
    sessionPL_snapshot := f_calcSessionPL(rangeStart, exitTime)
    tradesToday_snapshot := tradesToday
    snapshotRangeStart := rangeStart //added because of prior day bleed over bug

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 20) Trade and Session Cleanup
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

var bool didSessionEnd = false
// Single-line label showing the boolean as text
//label.new(bar_index, high + syminfo.mintick*20, didSessionEnd ? "true" : "false", style=label.style_label_down, color=color.teal, textcolor=color.white)

dayOfWeekNow = dayofweek(time)

if bar_index > 0 and time[1] < exitTime and time >= exitTime and not didSessionEnd and not earlyExitFired and dayOfWeekNow != dayofweek.sunday
    if showDebugLabels
        label.new(bar_index, high + 40, "Exit Alert Fired", style = label.style_label_down, color = color.fuchsia, textcolor = color.white)

    string chartTkr_eoa = syminfo.ticker
    string proxyTkr_eoa = proxyTickerPos != "" ? proxyTickerPos : f_get_proxy_ticker(chartTkr_eoa)
    bool emitLabel_eoa = true
    bool allowCancelSweep_eoa = na(lastCancelSweepBar) or lastCancelSweepBar != bar_index  //    EOS Window may request CancelSweep once per bar
    bool doCancelAll_eoa = allowCancelSweep_eoa  //    gate _doCancelAllBefore by per-bar latch


    bool posIsLong_eoa = strategy.position_size > 0
    string thisEntry_eoa = posIsLong_eoa ? idLong : idShort
    string thisExit_eoa  = posIsLong_eoa ? idLong + "_Exit" : idShort + "_Exit"
    string oppPrim_eoa   = posIsLong_eoa ? idShort : idLong
    string oppPrimEx_eoa = posIsLong_eoa ? idShort + "_Exit" : idLong + "_Exit"

    bool allowExit_eoa = na(lastExitEmitBar) or lastExitEmitBar != bar_index
    bool allowChart_eoa = allowExit_eoa
    bool allowProxy_eoa = allowExit_eoa

    [didExit_eoa_tmp, proxySent_eoa_tmp] = f_exit_atomic("EOS Window", "Exit Alert Fired", close, time, tzInput, chartTkr_eoa, proxyTkr_eoa, emitLabel_eoa, doCancelAll_eoa, thisEntry_eoa, thisExit_eoa, oppPrim_eoa, oppPrimEx_eoa, allowChart_eoa, allowProxy_eoa)

    //if didExit_eoa_tmp
    //    lastExitEmitBar := bar_index
    if allowCancelSweep_eoa and doCancelAll_eoa  //    latch CancelSweep usage for this bar
        lastCancelSweepBar := bar_index  //    
    if allowExit_eoa
        lastExitEmitBar := bar_index  // prevent second EOS helper call on the same bar

    if proxySent_eoa_tmp and proxyTickerPos != ""
        proxyPosActive := false
    if proxySent_eoa_tmp and proxyTickerPos != ""
        proxyTickerPos := ""
    if proxySent_eoa_tmp and proxyTickerPos != ""
        proxyPosDir := 0
    if proxySent_eoa_tmp and proxyTickerPos != ""
        proxyPosQty := 0

    didSessionEnd := true

if didSessionEnd and bar_index > 0
    tradesToday := 0
    placedTrades := false
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    resetTimes := true
    didSessionEnd := false
    sessionBlocked :=false
    issuedLongOrder  := false
    issuedShortOrder := false
    lastIssuedTradeNumber_reason := "session-reset"
    lastIssuedTradeNumber := 0 
    // Reset info box state
    sessionPL_snapshot := na
    tradesToday_snapshot := na
    sessionTable := na
    rearmAfterProfitPending := false
    rearmEligibleFromBar := na
    tradingHalted := false
    // >>>   J: alert-session-end â€” reset cycle state
    cycleSide := 0
    oppOutstanding := 0

// Clear stale snapshot if it belongs to a prior session - added due to prior day bleed over bug
if not na(sessionPL_snapshot) and not na(snapshotRangeStart) and snapshotRangeStart != rangeStart
    sessionPL_snapshot := na
    tradesToday_snapshot := na
    sessionTable := na

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 20.1) Session Info Box
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if showSessionBox
    if not na(sessionTable)
        table.delete(sessionTable)  
    sessionTable := table.new(position=position.top_right, columns=2, rows=9, bgcolor=color.new(color.blue, 90), border_width=1, border_color=color.blue)  //   +1 row for News Delay Until

    // spacer row (row 0) to push the whole panel down by one line
    table.cell(sessionTable, 0, 0, text="", bgcolor=color.new(color.navy, 100), text_color=color.new(color.white, 100))  
    table.cell(sessionTable, 1, 0, text="", bgcolor=color.new(color.navy, 100), text_color=color.new(color.white, 100))  

    //label for display box to last completed to live session
    var string lastSessionLabel = na
    var int lastTradeLimitSnapshot = na
    if bar_index > 0 and time[1] < rangeStart and time >= rangeStart
        lastSessionLabel := rangeSetSnapshot
        lastTradeLimitSnapshot := tradeLimit
    bool isLiveSession = realtimeEffective and time >= rangeStart and time <= exitTime 

    // Session Info Box rows (Status / Next Block use cached values)
    bool _isSev3IntradayDay = useSev3TimeWindow and useSev3Filter and newsMaxSevPreview == 3  //    identify Sev 3 window-style days
    bool _sessionTradingNow = (_isSev3IntradayDay ? not sev3Blocked : willTradePreview) and not tradingHalted and not sessionBlocked  //    : intraday-aware status
    string _statusTxt = _sessionTradingNow ? "Trading" : "Blocked"  //    : drive label from intraday-aware status
    color _statusCol = _sessionTradingNow ? color.green : color.red  //   

    table.cell(sessionTable, 0, 1, text="Status", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 1, text=_statusTxt, bgcolor=color.navy, text_color=_statusCol)

    table.cell(sessionTable, 0, 2, text="Max Sets", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 2, text=((not na(lastTradeLimitSnapshot) ? lastTradeLimitSnapshot : tradeLimit) <= 0 ? "âˆž" : str.tostring(not na(lastTradeLimitSnapshot) ? lastTradeLimitSnapshot : tradeLimit)), bgcolor=color.navy, text_color=color.white)

    table.cell(sessionTable, 0, 3, text="Sets Placed", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 3, text=str.tostring(not na(lastIssuedTradeNumber) ? lastIssuedTradeNumber : 0), bgcolor=color.navy, text_color=color.white)

    table.cell(sessionTable, 0, 4, text="Orders (closes) Today", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 4, text=str.tostring(tradesToday_snapshot), bgcolor=color.navy, text_color=color.white)

    table.cell(sessionTable, 0, 5, text="Trade Risk", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 5, text="$" + str.tostring(riskDollars, "#.##"), bgcolor=color.navy, text_color=color.white)

    table.cell(sessionTable, 0, 6, text="Day PnL", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 6, text="$" + str.tostring(dayPL, "#.##"), bgcolor=color.navy, text_color=f_getPLTextColor(dayPL))

    // use unified UI strings so table matches label exactly
    string _nextBlockDateTxt  = uiNextBlockDate == "None" ? "None (â‰¤ schedule)" : uiNextBlockDate   
    string _nextBlockEventTxt = uiNextBlockEvent                                               

    table.cell(sessionTable, 0, 7, text="Next Block (Date)",  bgcolor=color.navy, text_color=color.white)  
    table.cell(sessionTable, 1, 7, text=_nextBlockDateTxt,     bgcolor=color.navy, text_color=color.white)  

    // New row: Sev 3 news delay information
    string _newsDelayRowTxt = str.length(sev3DelayedUntilText) > 0 ? sev3DelayedUntilText : "â€”"  //   show â€œHH:MM am/pmâ€ or em dash if no Sev 3 delay today
    table.cell(sessionTable, 0, 8, text="News Delay Until", bgcolor=color.navy, text_color=color.white)  //   
    table.cell(sessionTable, 1, 8, text=_newsDelayRowTxt, bgcolor=color.navy, text_color=color.white)  //   

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 21) STRATEGY-CONFIRMED ENTRY & EXIT ALERTS (with full JSON)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Exit Alerts (after strategy exit)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Exit Alerts (after strategy exit)
if strategy.closedtrades > strategy.closedtrades[1] and (na(lastExitEmitBar) or lastExitEmitBar != bar_index)
    float exitPrice  = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    float tradeSize  = strategy.closedtrades.size(strategy.closedtrades - 1)
    bool  wasLong    = tradeSize > 0
    bool  isStop     = wasLong ? (exitPrice <= entryPrice) : (exitPrice >= entryPrice)
    bool  suppress   = isStop and not inEarlyWindow
    if suppress
        exitPrice := exitPrice
    else
        // STATS-ONLY: keep observability without emitting another exit
        log.info("StrategyConfirmed Stats â€” entry=" + str.tostring(entryPrice) + " exit=" + str.tostring(exitPrice) + " size=" + str.tostring(tradeSize))

// Debug Plots
plot(sev3DelayedHHMM, title="Sev3 News Resume (HHMM)", color=color.new(color.yellow, 0), display=display.data_window)  // e.g., 730 = 7:30;  na when no Sev 3 delay
plot(issuedLongOrder ? 1 : 0, title="Debug: Issued Long Order", color=color.blue, display=display.data_window)
plot(issuedShortOrder ? 1 : 0, title="Debug: Issued Short Order", color=color.red, display=display.data_window)
plotshape(time >= exitTime and (issuedLongOrder or issuedShortOrder) and not didSessionEnd and barstate.islastconfirmedhistory
     ? true : false,
     title="EOS Debug", location=location.abovebar,
     style=shape.labeldown, text="EOS")


// === TRACE EMIT (fires only when value changes and debug enabled) ===
if showLowLevelTrace
    bool _changed = lastIssuedTradeNumber != lastIssuedTradeNumber_prev
    if _changed
        label.new(
             x=bar_index,
             y=high + syminfo.mintick * 80,
             text="LITN  " + str.tostring(lastIssuedTradeNumber_prev) + " â†’ " + str.tostring(lastIssuedTradeNumber) + " via " + (lastIssuedTradeNumber_reason == "" ? "unknown" : lastIssuedTradeNumber_reason),
             style=label.style_label_down,
             color=color.new(color.fuchsia, 0),
             textcolor=color.white)
        lastIssuedTradeNumber_prev := lastIssuedTradeNumber
        lastIssuedTradeNumber_reason := ""

//if bar_index == 20253
//    label.new(bar_index, high, "bar 26165 " + f_iso_local(time, tzInput), style=label.style_label_down, color=color.yellow, textcolor=color.black)