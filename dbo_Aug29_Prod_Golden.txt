//@version=6
strategy("BB NextGen DBO", shorttitle="BB_DBO", overlay=true, calc_on_every_tick=true, process_orders_on_close=false, margin_long=0, margin_short=0)
import adam_overton/TradersPostDeluxe/1


// ──────────────────────────────────────────────────────────
// 1) GLOBAL CONFIG
// ────────────────────────────────────────────────────────
string tzInput = input.string("America/Los_Angeles", "Time Zone", options = ["America/New_York", "America/Los_Angeles", "UTC", "Europe/London", "Asia/Tokyo"])
showPnLIndicators = input.string("Yes", "Show Profit/Loss Indicators", options=["Yes", "No"], group="Display Settings")
showDebugLabels = input.bool(false, "Show Debug/Alert Labels", group="Display Settings")
showVWAPComponents = input.bool(false, "Show VWAP Plot", group="Display Settings")
showRSIPlot = input.bool(false, "Show RSI Overlay", group="Display Settings")

var bool resetTimes                     = true
var string rangeSetSnapshot             = "3:10"
var int tradeLimitSnapshot              = na
var int rangeStart                      = na
var int rangeEnd                        = na
var int exitTime                        = na
var bool scoped_officialRangeStarted    = false
var int scoped_actualRangeStart         = na
var int lastEntryBar                    = -1
var bool sessionValid                   = true
bool sessionFlagged                     = false
string sessionInvalidReason             = ""
var bool issuedLongOrder                = false
var bool issuedShortOrder               = false
var bool drew                           = false
var bool sessionBlocked                 = false
var int  emergencyExitBar               = na
var bool emergencyExitSent              = false
var int lastIssuedTradeNumber           = 0
var float sessionPL_snapshot            = na
var int tradesToday_snapshot            = na
var table sessionTable                  = na
var int snapshotRangeStart              = na
var bool earlyExitFired                 = false

// ───────────────────────────────────────────────────────────────
// 2) SINGLE SESSION INPUTS
// ───────────────────────────────────────────────────────────────
riskDollars         = input.float(1000.0, "Per Session Risk Dollars", tooltip="Total amount to risk per trade if not session specfic defined")
maxDailyLoss        = input.float(3500, title="Max Daily Loss", tooltip="Set to 0 for unlimited risk")
string vwapModeInput    = input.string("Session", "VWAP Anchor", options=["Session", "Auto"])
int vwapLenInput        = input.int(14, "VWAP Length (bars, if Auto)", minval=1)
string vwapMode         = vwapModeInput
int vwapLen             = vwapLenInput
int rangeEndHour        = input.int(3, "Range End Hour") 
int rangeEndMin         = input.int(34, "Range End Min")
int lookbackH           = input.int(4, "Lookback Hour") 
int lookbackM           = input.int(0, "Lookback Min")
int exitDurH            = input.int(9, "Exit Duration Hour")
int exitDurM            = input.int(35, "Exit Duration Min")
int tradeLimit          = input.int(3, "Trade Limit")
float entryOff          = input.float(10.0, "Entry Offset")
float stopOff           = input.float(2.0, "Stop Offset")
float tpRatio           = input.float(0.55, "TP Ratio")
float rrRatio           = input.float(1.7, "SL:TP Ratio/R:R Inverted")
float ptsSL             = input.float(14.0, "Stop Loss (pts)")
float vwOffset          = input.float(0.5, "VWAP Offset")
midpointStartTolerancePct = input.float(35.0, "Midpoint Start Proximity (%)", group="Quality Filters", minval = -1, maxval = 100,tooltip="-1 default to use global setting")
requireMidpointReturn = input.bool(true, "Require Midpoint Quality after Trade 1", group="Quality Filters")

// ───────────────────────────────────────────────────────────────
// 3) RISK / HALT / BEHAVIOR
// ───────────────────────────────────────────────────────────────
minimumOneContract  = input.bool(true, "Minimum One Contract", tooltip="Force at least one contract even if risk% yields 0")
haltAfterProfit     = input.bool(false, "Halt Trading After Day is Green", tooltip="If we are green, stop trading, then exit")
earlyExitMinutes    = input.int(10, "Early Exit Minutes Before Session End", minval=0, tooltip="If we are green right before session then exit")
trailStop           = input.bool(false, "Trailing Stop")
trailStopTrigger    = input.int(50, "Percentage of trailing stop to start the trail")
slType              = input.string("RR", "Stop Loss Type", options=["RR","Points","VWAP","ATR"])
aggressiveFlip      = input.bool(true, "Allow opposite entry after stop ala DBO", group="Quality Filters", tooltip="OFF = original behavior. ON = do not cancel the opposite bracket while in a trade, and after a stop only clear the failed side so the opposite can trigger immediately.")

// ───────────────────────────────────────────────
// 3.1) Opposite Trade Behavior (3-way)
// ───────────────────────────────────────────────
oppositeTradeMode = input.string("Keep Opposite (Scaled Qty + Adjusted Entry)", "Opposite Trade Behavior", options=["Cancel Opposite", "Keep Opposite (Same Qty)", "Keep Opposite (Scaled Qty + Adjusted Entry)"], group="Execution Settings")
oppositeQtyMultiplier = input.float(2.0, "Opposite Trade Quantity Multiplier", step=0.1, group="Execution Settings")
oppositeReissueEntryOffsetPts = input.float(1.0, "Opposite Reissue Entry Offset (pts)", step=0.25, group="Execution Settings")


// ───────────────────────────────────────────────────────────────
// 4) QUALITY FILTERS
// ───────────────────────────────────────────────────────────────
useVWAPDistanceFilter = input.bool(false, "Enable VWAP Distance Filter", group="Quality Filters")
minVWAPDistance = input.float(2.0, "Minimum Distance from VWAP (pts)", group="Quality Filters")
minRangePoints = input.float(50, "Minimum Range Width (pts)", group="Quality Filters", tooltip="-1 default to disable")
maxRangePoints = input.float(350, "Maximum Range Width (pts)", group="Quality Filters", tooltip="-1 default to disable")
useEMASlopeFilter = input.bool(false, "Enable EMA Slope Filter", group="Quality Filters")
emaSlopeLength = input.int(21, "EMA Length", group="Quality Filters")
emaSlopeLookback = input.int(5, "EMA Slope Lookback Bars", group="Quality Filters")
minEMASlope = input.float(2.0, "Minimum EMA Slope", group="Quality Filters")
useRSIFilter = input.bool(false, "Enable RSI Filter", group="Quality Filters")
rsiLength = input.int(20, "RSI Length", group="Quality Filters")
rsiMin = input.float(45.0, "RSI Min Threshold", group="Quality Filters")
rsiMax = input.float(75.0, "RSI Max Threshold", group="Quality Filters")

// ───────────────────────────────────────────────────────────────
// 4.1) ATR Settings & Helpers ◄
// ───────────────────────────────────────────────────────────────
fixATRDuringBreakout = input.string("Yes", "Fixed ATR for Breakout Range", options=["Yes", "No"], group="ATR Settings", tooltip="If Yes, locks ATR for the entire breakout session at breakout start")
atrLength         = input.int(14,   "ATR Length",         group="ATR Settings", tooltip="Periods for session ATR")
atrFallbackLength = input.int(50,   "Fallback ATR Length",group="ATR Settings", tooltip="Periods for global ATR if session ATR not ready")
maxATRMult        = input.float(2.5, "Max ATR Multiplier", group="ATR Settings", tooltip="Cap on ATR scaling")

// ───────────────────────────────────────────────────────────────
// 4.2) ATR Calculation Logic
// ───────────────────────────────────────────────────────────────
var float snapATR = na
var float snapATRRatio = na
var float snapAdjPtsSL = na
var float snapAdjTPSize = na

atrSession = ta.atr(atrLength)
atrGlobal = ta.atr(atrFallbackLength)
barsSinceStart = bar_index - ta.valuewhen(time == rangeStart, bar_index, 0)
useSessionATR = not na(barsSinceStart) and barsSinceStart >= atrLength
atrLive = useSessionATR ? atrSession : atrGlobal
atrUsed = (fixATRDuringBreakout == "Yes" and not na(snapATR)) ? snapATR : atrLive

// Snap ATR at breakout start
if time[1] < rangeEnd and time >= rangeEnd
    snapATR := atrLive
    snapATRRatio := math.min(snapATR / atrGlobal, maxATRMult)
    snapAdjPtsSL := slType == "ATR" ? ptsSL * snapATRRatio : ptsSL
    snapAdjTPSize := snapAdjPtsSL * (tpRatio / rrRatio)

// ────────────────
// 4.3) Sev 3 News Date Filter
// ────────────────
useSev3Filter = input.bool(true, "Skip Trading on Sev 3 News Days", group="Quality Filters")

var sev3Dates = array.new_string()
if bar_index == 0
    array.push(sev3Dates, "2025-06-02"), array.push(sev3Dates, "2025-06-04"), array.push(sev3Dates, "2025-06-06")
    array.push(sev3Dates, "2025-06-12"), array.push(sev3Dates, "2025-06-18"), array.push(sev3Dates, "2025-07-01")
    array.push(sev3Dates, "2025-07-02"), array.push(sev3Dates, "2025-07-03"), array.push(sev3Dates, "2025-07-09")
    array.push(sev3Dates, "2025-07-16"), array.push(sev3Dates, "2025-07-30"), array.push(sev3Dates, "2025-08-01")
    array.push(sev3Dates, "2025-08-05"), array.push(sev3Dates, "2025-08-14"), array.push(sev3Dates, "2025-08-20")
    array.push(sev3Dates, "2025-09-02"), array.push(sev3Dates, "2025-09-04"), array.push(sev3Dates, "2025-09-05")
    array.push(sev3Dates, "2025-09-10"), array.push(sev3Dates, "2025-09-17"), array.push(sev3Dates, "2025-10-01")
    array.push(sev3Dates, "2025-10-03"), array.push(sev3Dates, "2025-10-08"), array.push(sev3Dates, "2025-10-16")
    array.push(sev3Dates, "2025-10-29"), array.push(sev3Dates, "2025-11-03"), array.push(sev3Dates, "2025-11-05")
    array.push(sev3Dates, "2025-11-07"), array.push(sev3Dates, "2025-11-14"), array.push(sev3Dates, "2025-11-19")
    array.push(sev3Dates, "2025-12-01"), array.push(sev3Dates, "2025-12-03"), array.push(sev3Dates, "2025-12-05")
    array.push(sev3Dates, "2025-12-10"), array.push(sev3Dates, "2025-12-11")

todayStr = str.tostring(year(time, tzInput)) + "-" + str.tostring(month(time, tzInput), "00") + "-" + str.tostring(dayofmonth(time, tzInput), "00")
sev3Blocked = useSev3Filter and array.includes(sev3Dates, todayStr)

// ───────────────────────────────────────────────────────────────
// 5) FRESHNESS WATCHERS (rebuild window on TZ / input change)
// ───────────────────────────────────────────────────────────────

// NEW: detect user TZ changes (string-safe) and trigger a window rebuild
var string _tzPrev = na
if na(_tzPrev)
    _tzPrev := tzInput
if tzInput != _tzPrev
    resetTimes := true
    _tzPrev := tzInput

// Rebuild window if key config flips mid-session (string/int/hash-safe)
var string _cfgUID = ""
string _cfgNow = str.format("{0}", tzInput)
if _cfgNow != _cfgUID
    resetTimes := true
    _cfgUID := _cfgNow

// ───────────────────────────────────────────────────────────────
// 6) Internal State  LEVELS, TP & STOPS
// ───────────────────────────────────────────────────────────────
// declare each var separately
var float dayHigh = na
var float dayLow  = na
var bool placedTrades = false

longEntry   = dayHigh + entryOff
shortEntry  = dayLow  - entryOff
longStop    = dayLow  - stopOff
shortStop   = dayHigh + stopOff
rangeSize   = math.abs(longEntry - longStop)
tpSizeLive   = rangeSize * tpRatio
tpSizeSnap   = slType == "ATR" ? snapAdjTPSize : tpSizeLive
tpSizeUsed   = time < rangeEnd ? tpSizeLive : tpSizeSnap
tpSize       = tpSizeUsed
longTP      = longEntry  + tpSize
shortTP     = shortEntry - tpSize

// Derived keep/cancel flag aligned to 3-way mode (do not remove aggressiveFlip; we map behavior below)
bool keepOpposite = oppositeTradeMode != "Cancel Opposite"

// Working vars for scaled reissue (declare once; update with :=)
var float reOppQty = na
var float reOppEntry = na
var float reOppStop = na
var float reOppTP = na
var string reOppId = ""
var string reOppExitId = ""


// ───────────────────────────────────────────────────────────────
// 7) ORDER HELPERS
// ───────────────────────────────────────────────────────────────
// Position Size Calculation
f_calcPositionSize(_entry, _stop) =>
    float priceDiff = math.abs(_entry - _stop)
    float tickCount = syminfo.mintick != 0 ? priceDiff / syminfo.mintick : priceDiff
    costPerContract = tickCount * syminfo.pointvalue
    contractCount = math.floor(riskDollars / costPerContract)
    if minimumOneContract and contractCount <= 0
        contractCount := 1
    contractCount

f_placeBracket(id, dir, entry, stop, limit, tradesCount, alreadyIssued, rangeConfirmed) =>
    qty = f_calcPositionSize(entry, stop)
    isLong = dir == strategy.long
    orderPlaced = false

    if qty > 0 and rangeConfirmed
        if not alreadyIssued
            labelText = "Trade " + str.tostring(tradesCount + 1) + " Issued"
            if showDebugLabels
                label.new(x=bar_index, y=dayHigh + syminfo.mintick * 100, text=labelText, style=label.style_label_down, color=color.orange, textcolor=color.white)   
            strategy.entry(id, dir, stop=entry, qty=qty)
            TradersPostDeluxe.SendEntryAlert(action=isLong ? TradersPostDeluxe.Action.buy : TradersPostDeluxe.Action.sell, quantity=qty, orderType=TradersPostDeluxe.OrderType.stop, takeProfit=limit, price=entry, stopLoss=stop, id=id)
            orderPlaced := true

        trailSize = math.abs(entry - stop) * 4
        trailTrigger = trailSize * trailStopTrigger / 100
        strategy.exit(id + "_Exit", from_entry=id, stop=stop, limit=trailStop ? na : limit, trail_points=trailStop ? trailTrigger : na, trail_offset=trailStop ? trailSize : na)

    orderPlaced

isPriceInsideRange() =>
   close[0] < longEntry and close[0] > shortEntry

// ───────────────────────────────────────────────────────────────
// 8) DST-SAFE WINDOW BUILDER (single 3:10 session)
// ───────────────────────────────────────────────────────────────
// ──────────────────────────────────────────────
// Midnight-proof range window (Pine v6 standalone)
// Requirements in scope (types shown for clarity):
//   string tzInput
//   int    rangeEndHour, rangeEndMin
//   int    lookbackH, lookbackM, exitDurH, exitDurM
//   var int rangeStart = na, rangeEnd = na, exitTime = na
//   var bool resetTimes = false
// ──────────────────────────────────────────────
if resetTimes
    // If overrides not ready, keep previous window (prevents “epoch lines”)
    if na(rangeEndHour) or na(rangeEndMin)
        rangeEnd   := rangeEnd
        rangeStart := rangeStart
        exitTime   := exitTime
    else
        // Build today's end-of-range anchor in tzInput
        int yy = year(time, tzInput)
        int mm = month(time, tzInput)
        int dd = dayofmonth(time, tzInput)
        int nowH = hour(time, tzInput)
        int nowM = minute(time, tzInput)

        int baseEnd = timestamp(tzInput, yy, mm, dd, rangeEndHour, rangeEndMin)
        bool pastCut = nowH > rangeEndHour or (nowH == rangeEndHour and nowM >= rangeEndMin)

        // If we’re already past the cut today, roll anchor to the next calendar day (DST-safe)
        if pastCut
            int ny = year(baseEnd + 86400000, tzInput)
            int nm = month(baseEnd + 86400000, tzInput)
            int nd = dayofmonth(baseEnd + 86400000, tzInput)
            baseEnd := timestamp(tzInput, ny, nm, nd, rangeEndHour, rangeEndMin)

        int lookbackMS = lookbackH * 3600000 + lookbackM * 60000
        int exitDurMS  = exitDurH * 3600000 + exitDurM * 60000

        rangeEnd   := baseEnd
        rangeStart := baseEnd - lookbackMS
        exitTime   := baseEnd + exitDurMS

        // Safety: ensure strictly increasing times even for 0h / 24h lookbacks
        if rangeStart >= rangeEnd
            rangeStart := rangeEnd - 60000

        // Commit window + clear reset flag atomically
        drew := false
        resetTimes := false


// ───────────────────────────────────────────────────────────────
// 9) WINDOW FLAGS
// ───────────────────────────────────────────────────────────────
bool inDefine   = time >= rangeStart and time < rangeEnd
bool inBreakoutWindow = time >= rangeEnd and time < exitTime
// 9.1) Early-exit window flag (derived every bar)
int earlyMS = earlyExitMinutes * 60000
int earlyStart = exitTime - earlyMS
bool inEarlyWindow = not na(exitTime) and not na(earlyStart) and time >= earlyStart and time < exitTime

/// ───────────────────────────────────────────────────────────────
// 10) INDICATORS (compute every bar; no stateful calls in branches)
// ───────────────────────────────────────────────────────────────

float vwapSource = inDefine or inBreakoutWindow ? hlc3 : na
float sessionVWAP = ta.vwap(vwapSource)
float sessionVWMA = ta.vwma(close, vwapLen)
anchoredVWAP = vwapMode == "Session" ? (na(sessionVWAP) ? sessionVWMA : sessionVWAP) : sessionVWMA

// ───────────────────────────────────────────────────────────────
// 11) QUALITY FILTERS EVAL (once when window shifts to breakout)
// ───────────────────────────────────────────────────────────────
float emaNow = ta.ema(close, emaSlopeLength)
float emaThen = na
if emaSlopeLookback > 0 and bar_index >= emaSlopeLookback
    emaThen := nz(emaNow[emaSlopeLookback])
else
    emaThen := emaNow
emaSlope = math.abs(emaNow - emaThen)
emaSlopeOk = emaSlope >= minEMASlope
sessionRSI = ta.rsi(close, rsiLength)
rsiValid = sessionRSI > rsiMin and sessionRSI < rsiMax

// === Rescale RSI to price chart
rsiOverlayBase = dayLow
rsiOverlayScale = (dayHigh - dayLow) / 100
validRange = inBreakoutWindow and not na(dayHigh) and not na(dayLow) and dayHigh != dayLow
rsiOverlay = (showRSIPlot and validRange) ? dayLow + sessionRSI * ((dayHigh - dayLow) / 100) : na

// === Session Filter Evaluation ===
filterVWAP = anchoredVWAP
vwapDistanceOk = na(filterVWAP) or math.abs(close - filterVWAP) > minVWAPDistance
rangeWidth = dayHigh - dayLow
rangeWidthOk = rangeWidth >= minRangePoints
//Adding support for max range as well as min range
rangeWidthMaxOk = maxRangePoints > 0 ? (rangeWidth <= maxRangePoints) : true

if time[1] < rangeEnd and time >= rangeEnd and not na(dayHigh) and not na(dayLow) and dayHigh != dayLow
    sessionValid := true
    sessionInvalidReason := ""

    if sev3Blocked
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "Sev 3 News Day"

    if useVWAPDistanceFilter and not vwapDistanceOk
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "VWAP"

    if minRangePoints > 0 and not rangeWidthOk
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "Min Range Size"

    if maxRangePoints > 0 and not rangeWidthMaxOk
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "Max Range Size"

    if useEMASlopeFilter and not emaSlopeOk
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "EMA"

    if useRSIFilter and not rsiValid
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "RSI"

    sessionFlagged := true
    if showDebugLabels
        string _mode = oppositeTradeMode
        label.new(bar_index, dayHigh + syminfo.mintick * 60, "Mode: " + _mode, style=label.style_label_down, color=color.new(color.blue, 20), textcolor=color.white)

    // ───────────────────────────────────────────────────────────────
    // Visual: Label invalid sessions at the first post-range bar
    // ───────────────────────────────────────────────────────────────
    if showDebugLabels and time[1] < rangeEnd and time >= rangeEnd and not sessionValid
        label.new(bar_index, low, "Skipped: "+sessionInvalidReason, style=label.style_label_up, textcolor=color.black, color=color.yellow, xloc=xloc.bar_index, yloc=yloc.belowbar)


// ───────────────────────────────────────────────────────────────
// 12) OPTIONAL DEFERRED START (midpoint proximity) 
// ───────────────────────────────────────────────────────────────
scoped_rangeMidpoint = not na(dayHigh) and not na(dayLow) ? (dayHigh + dayLow) / 2 : na
scoped_rangeWidth = not na(dayHigh) and not na(dayLow) ? (dayHigh - dayLow) : na
scoped_inBreakoutWindow = not na(exitTime) and time >= rangeEnd and time < exitTime and time > rangeStart
scoped_inDeferredBreakout = scoped_inBreakoutWindow and not scoped_officialRangeStarted
scoped_isNearMidpoint = not na(scoped_rangeMidpoint) and scoped_rangeWidth > 0 and math.abs(close - scoped_rangeMidpoint) <= (scoped_rangeWidth * midpointStartTolerancePct / 100)
if not sessionBlocked
    
    // === LEGITIMATE TRIGGERS
    //isValidMidpointTrigger = scoped_inBreakoutWindow and midpointStartTolerancePct > 0 and scoped_isNearMidpoint
    isValidMidpointTrigger   = scoped_inBreakoutWindow 
                         and midpointStartTolerancePct > 0 
                         and scoped_isNearMidpoint 
                         and barstate.isconfirmed //after so many issue, I finally make it require a bar close, flipping values mid bar etc
    isValidFallbackTrigger = scoped_inBreakoutWindow and midpointStartTolerancePct <= 0

    // ✅ Proximity activation
    if isValidMidpointTrigger and not scoped_officialRangeStarted
        scoped_officialRangeStarted := true
        scoped_actualRangeStart := time
        //label.new(bar_index, high+40, "Midpoint", style=label.style_label_down, color=color.purple, textcolor=color.white)

    // ✅ Fallback activation
    if isValidFallbackTrigger and not scoped_officialRangeStarted
        scoped_officialRangeStarted := true
        scoped_actualRangeStart := time
   
   //// 🔒 LOCKDOWN GUARD — prevent external or leaked triggers
   // if not (isValidMidpointTrigger or isValidFallbackTrigger)
   //     scoped_officialRangeStarted := false

    var label deferredStartLabel = na
    if showDebugLabels and scoped_inBreakoutWindow and not scoped_officialRangeStarted and time == rangeEnd and not na(dayHigh)
        deferredStartLabel := label.new(x=bar_index, y=dayHigh + syminfo.mintick * 40, text="Deferred Start", style=label.style_label_down, color=color.new(color.red, 85), textcolor=color.white)


// ───────────────────────────────────────────────────────────────
// 13) ENTRY ENGINE (dual lock: session validity + trade limit)
// ───────────────────────────────────────────────────────────────
if inBreakoutWindow and not drew and not na(dayHigh) and scoped_officialRangeStarted
    int boxLeft = scoped_actualRangeStart < rangeEnd ? rangeEnd : scoped_actualRangeStart
    box.new(left=boxLeft, top=dayHigh, right=exitTime, bottom=dayLow, xloc=xloc.bar_time, bgcolor=sessionValid ? color.new(color.yellow, 80) : color.new(color.red, 85), border_width=0)
    drew := true

if time[0] < rangeStart or time[0] > exitTime
    dayHigh := na
    dayLow  := na

if inDefine
    dayHigh := na(dayHigh) ? high : math.max(dayHigh, high)
    dayLow  := na(dayLow)  ? low  : math.min(dayLow, low)

if (not inBreakoutWindow)
    drew := false

// ───────────────────────────────────────────────────────────────
// 14) FLEXIBLE STOP LOSS OPTIONS
// ───────────────────────────────────────────────────────────────
longStop := switch slType
    "RR"     => longEntry - tpSize * rrRatio                
    "Points" => longEntry - ptsSL
    "VWAP"   => anchoredVWAP - vwOffset
    "ATR"    => longEntry - math.min(atrUsed, atrGlobal * maxATRMult)
    => longStop
             

shortStop := switch slType
    "RR"     => shortEntry + tpSize * rrRatio                 
    "Points" => shortEntry + ptsSL
    "VWAP"   => anchoredVWAP + vwOffset
    "ATR"    => shortEntry + math.min(atrUsed, atrGlobal * maxATRMult)
    => shortStop

stopSize = longEntry - longStop


// ───────────────────────────────────────────────────────────────
// 15) DAILY HALTS
// ───────────────────────────────────────────────────────────────
// Session PnL Calculation
f_calcSessionPL(_startTime, _endTime) =>
    var float totalPL = 0.0
    if not na(_startTime) and not na(_endTime) and strategy.closedtrades > 0
        totalPL := 0.0
        for i = 0 to strategy.closedtrades - 1
            float eTime = strategy.closedtrades.entry_time(i)
            if eTime >= _startTime and eTime <= _endTime
                float entryPrice = strategy.closedtrades.entry_price(i)
                float exitPrice = strategy.closedtrades.exit_price(i)
                float tradeQty = math.abs(strategy.closedtrades.size(i))
                bool isLong = strategy.closedtrades.size(i) > 0
                float points = isLong ? (exitPrice - entryPrice) : (entryPrice - exitPrice)
                float dollars = points / syminfo.mintick / 4 * 2 * tradeQty
                totalPL := totalPL + dollars
    totalPL

f_calcDayPL() =>
    var float totalDayPL = 0.0
    yy = year(time, tzInput)
    mm = month(time, tzInput)
    dd = dayofmonth(time, tzInput)

    // Calculate today's 15:00
    dayStart = timestamp(tzInput, yy, mm, dd, 15, 0)

    // If current time is before today's 15:00, get prior day's 15:00 using timestamp math
    if time < dayStart
        dayStart := dayStart - 86400000  // Subtract 1 day in milliseconds

    totalDayPL := f_calcSessionPL(dayStart, time)

dayPL = f_calcDayPL()
var bool tradingHalted = false
// Evaluate trading halt condition
if maxDailyLoss > 0 and dayPL < -maxDailyLoss
    tradingHalted := true

if haltAfterProfit and dayPL > 0
    tradingHalted := true
    
// Reset flag at next global open (15:00)
int globalOpen = timestamp(tzInput, year(time, tzInput), month(time, tzInput), dayofmonth(time, tzInput), 15, 0)
if time >= globalOpen and time[1] < globalOpen
    tradingHalted := false


// ───────────────────────────────────────────────────────────────
// 16) ENTRY & EXIT LOGIC (Dual Lock: Session Validity + Trade Limit)
// ───────────────────────────────────────────────────────────────
//clears per-session gates before the engine arms entries (e.g., placedTrades, 
// waitUntilBar, postTradeLock).
// zeroes counters (tradesToday) and snapshot vars so the data window/panel shows fresh values.
// pairs with your EOS cleanup (which cancels orders and sets resetTimes := true) by 
// resetting counters/flags that the EOS block doesn’t touch. see your EOS cleanup: 
// it triggers on the first bar at/after exitTime, cancels orders, closes all, and sets resetTimes := true.
// ───────────────────────────────────────────────────────────────
var tradesToday = 0
var closedTrades = 0
var int waitUntilBar = na
var int postTradeLock = na

// Start-of-session reset — fires once at the first bar inside the new session
if bar_index > 0 and time[1] < rangeStart and time >= rangeStart
    placedTrades := false
    tradesToday := 0
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    postTradeLock := na
    issuedLongOrder := false
    issuedShortOrder := false
    lastIssuedTradeNumber := 0
    emergencyExitSent := false
    earlyExitFired := false
    sessionPL_snapshot := na
    tradesToday_snapshot := na
    sessionTable := na
    drew := false

// Reset just after session ends ✅ Executes once, on the first bar after the session ends - Ideal for resetting session state (e.g., flags, counters, UI values)
if bar_index > 0 and time[1] < exitTime and time[0] >= exitTime
    tradesToday := 0
    placedTrades := false
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    issuedLongOrder := false
    issuedShortOrder := false
    // ◄◄◄ clear our trade-number gating for next session
    lastIssuedTradeNumber := 0
    emergencyExitSent      := false
    sessionPL_snapshot := na
    tradesToday_snapshot := na
    sessionTable := na


// ───────────────────────────────────────────────────────────────
// 17) ENTRY ENGINE (dual lock: session validity + trade limit)
// ───────────────────────────────────────────────────────────────
idLong = "Long"
idShort = "Short"
canceledLong = false
canceledShort = false

// Emergency exit block — must run BEFORE entry logic
if barstate.isrealtime and not emergencyExitSent and bar_index == emergencyExitBar
    strategy.cancel(idLong)
    strategy.cancel(idLong + "_Exit")
    strategy.cancel(idShort)
    strategy.cancel(idShort + "_Exit")
    strategy.close_all(comment="Emergency Market Exit")
    TradersPostDeluxe.SendExitAlert(price=close)
    if showDebugLabels
        label.new(bar_index,low - syminfo.mintick * 40, "Emergency Exit Fired", style=label.style_label_down, color=color.fuchsia, textcolor=color.white)
    emergencyExitSent := true

// Evaluate entry conditions each bar
bool currentPriceIsInsideRange_check = isPriceInsideRange()
bool allConditionsMetForTradePlacement = not tradingHalted and
                                         sessionValid and
                                         strategy.position_size == 0 and
                                         not placedTrades and
                                         (na(waitUntilBar) or bar_index >= waitUntilBar) and
                                         (na(postTradeLock) or bar_index >= postTradeLock) and
                                         currentPriceIsInsideRange_check and
                                         (tradeLimit == 0 or tradesToday < tradeLimit) and
                                         (not requireMidpointReturn or tradesToday == 0 or scoped_isNearMidpoint)  
                                  

// Allow re-arming when we come back to midpoint during deferred starts Only before the first issuance and while flat — prevents per-bar re-arming spam
if scoped_inBreakoutWindow and midpointStartTolerancePct > 0 and scoped_isNearMidpoint and lastIssuedTradeNumber == 0 and strategy.position_size == 0
    placedTrades := false

if inBreakoutWindow and scoped_officialRangeStarted
    // 🔒 Session Invalid Lock
    if not sessionValid and not placedTrades
        strategy.cancel(idLong)
        strategy.cancel(idShort)
        placedTrades := true

    // 🔒 Trade Limit Lock
    if tradesToday >= tradeLimit and not placedTrades
        strategy.cancel(idLong)
        strategy.cancel(idShort)
        placedTrades := true

    // Cancel opposing orders while in position (respect 3-way mode)
    // Cancel only when user selected "Cancel Opposite". Otherwise, keep opposite (same or scaled handled on stop in closed-trade handler).
    if strategy.position_size > 0 and not keepOpposite
        strategy.cancel(idShort)
        canceledShort := true
    if strategy.position_size < 0 and not keepOpposite
        strategy.cancel(idLong)
        canceledLong := true

    // ── ENTRY PLACEMENT (trade-number gating) ──
    int nextTradeNum = lastIssuedTradeNumber + 1
    if allConditionsMetForTradePlacement and bar_index != lastEntryBar and nextTradeNum > lastIssuedTradeNumber
        lastEntryBar := bar_index
        bool placedL = f_placeBracket(idLong,  strategy.long,  longEntry,  longStop,  longTP,  lastIssuedTradeNumber, issuedLongOrder,  true)
        bool placedS = f_placeBracket(idShort, strategy.short, shortEntry,  shortStop, shortTP,  lastIssuedTradeNumber, issuedShortOrder, true)
        if placedL
            issuedLongOrder := true
            placedTrades := true
            lastIssuedTradeNumber := nextTradeNum
        if placedS
            issuedShortOrder := true
            placedTrades := true
            lastIssuedTradeNumber := nextTradeNum

    // Auto-clear the post-trade lock once elapsed
    if not na(postTradeLock) and bar_index >= postTradeLock
        postTradeLock := na
        issuedLongOrder := false
        issuedShortOrder := false


// ───────────────────────────────────────────────────────────────
// 17.2) OPEN TRADE HANDLER — two-phase: CANCEL → (wait 1 bar) → REISSUE
//     • Detect flat→position transition, arm Phase 1 for bar_index+1
//     • Phase 1: send broker cancel for opposite *entry* only; clean sim (entry+exit)
//     • Phase 2: issue scaled opposite on the NEXT bar (guarded with barstate.isconfirmed)
//     • Stand-down: if a PROFIT close happens on this bar, clear pending (let 17.4 handle)
//     • Uses raw JSON alert() for cancel; TradersPostDeluxe for entries (no sentiment)
//     • All identifiers are 17.2-scoped (…172) to avoid collisions
// ───────────────────────────────────────────────────────────────

// Cancel helper (explicit ticker+action)
f_tp_cancel172(string id) =>
    string js172 = '{"ticker":"' + syminfo.ticker + '","action":"cancel","entryId":"' + id + '"}'
    alert(js172, alert.freq_once_per_bar)

// Position transition detection (declare once; update each bar)
var int  posNow172 = 0
var int  posPrev172 = 0
var bool wasFlat172 = false
var bool enteredLongNow172 = false
var bool enteredShortNow172 = false
posNow172 := int(math.round(nz(strategy.position_size)))
posPrev172 := int(math.round(nz(strategy.position_size[1])))
wasFlat172 := posPrev172 == 0
enteredLongNow172 := wasFlat172 and posNow172 > 0
enteredShortNow172 := wasFlat172 and posNow172 < 0

// Two-phase scheduler
var bool pendReissue172 = false
var int  pendDir172 = 0              // +1 => reissue LONG, -1 => reissue SHORT
var int  pendBar172 = na
var int  pendStage172 = 0            // 0 none, 1 cancel phase, 2 issue phase

// Base context gate (precomputed every bar)
bool ctxOKBase172 = inBreakoutWindow and scoped_officialRangeStarted and not earlyExitFired and not emergencyExitSent and not sessionBlocked and not tradingHalted and not inEarlyWindow

// if already pending and we roll into the early window, clear it, consistent with not entering a new trade near end of session
if pendReissue172 and inEarlyWindow
    pendReissue172 := false
    pendDir172 := 0
    pendBar172 := na
    pendStage172 := 0

// Arm Phase 1 (cancel) only in opposite-scaled mode, one bar after fill
if (enteredLongNow172 or enteredShortNow172) and oppositeTradeMode == "Keep Opposite (Scaled Qty + Adjusted Entry)"
    pendReissue172 := true
    pendDir172 := enteredLongNow172 ? -1 : 1
    pendBar172 := bar_index + 1
    pendStage172 := 1

// ── PROFIT stand-down detection (compute every bar)
int  ct172 = strategy.closedtrades
bool ctChanged172 = ta.change(ct172) != 0
bool profitClosedThisBar172 = false
if ctChanged172 and ct172 > 0
    float _exitP172  = strategy.closedtrades.exit_price(ct172 - 1)
    float _entryP172 = strategy.closedtrades.entry_price(ct172 - 1)
    bool  _long172   = strategy.closedtrades.size(ct172 - 1) > 0
    profitClosedThisBar172 := _long172 ? (_exitP172 > _entryP172) : (_exitP172 < _entryP172)

// If PROFIT close detected this bar, stand down and let 17.4 reissue both
if profitClosedThisBar172 and pendReissue172
    pendReissue172 := false
    pendDir172 := 0
    pendBar172 := na
    pendStage172 := 0

// Phase trigger flags — strict equality avoids same-bar double firing
bool due172 = pendReissue172 and not na(pendBar172) and bar_index == pendBar172
bool ctxOK172 = due172 and ctxOKBase172

// Shared locals (17.2-scoped)
var float reOppEntry172 = na
var float reOppStop172 = na
var float reOppTP172 = na
var float reOppQty172 = na
var string reOppId172 = ""
var string reOppExitId172 = ""

// Distance guard
float mt172 = syminfo.mintick != 0 ? syminfo.mintick : 0.01

if ctxOK172
    // ── PHASE 1: CANCEL OPPOSITE ENTRY AT BROKER, CLEAN SIM BOTH, THEN ARM PHASE 2 (NEXT BAR)
    if pendStage172 == 1
        if pendDir172 == 1
            bool okCancelLong172 = posNow172 < 0
            if okCancelLong172
                f_tp_cancel172(idLong)            // broker: cancel opposite entry
                strategy.cancel(idLong)           // sim: entry
                strategy.cancel(idLong + "_Exit") // sim: exit
                if showDebugLabels
                    label.new(bar_index, high + mt172 * 120, "Phase 1: Cancel Long (opp) sent", style=label.style_label_down, color=color.new(color.teal, 0), textcolor=color.white)
            else
                if showDebugLabels
                    label.new(bar_index, high + mt172 * 120, "Phase 1: Skip cancel (not short)", style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white)
        else if pendDir172 == -1
            bool okCancelShort172 = posNow172 > 0
            if okCancelShort172
                f_tp_cancel172(idShort)
                strategy.cancel(idShort)
                strategy.cancel(idShort + "_Exit")
                if showDebugLabels
                    label.new(bar_index, high + mt172 * 120, "Phase 1: Cancel Short (opp) sent", style=label.style_label_down, color=color.new(color.teal, 0), textcolor=color.white)
            else
                if showDebugLabels
                    label.new(bar_index, high + mt172 * 120, "Phase 1: Skip cancel (not long)", style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white)
        pendBar172 := bar_index + 1
        pendStage172 := 2

    // ── PHASE 2: ISSUE SCALED OPPOSITE ORDER (NEXT BAR ONLY, and only at bar close)
    else if pendStage172 == 2 and barstate.isconfirmed
        if pendDir172 == 1
            reOppEntry172 := shortStop - oppositeReissueEntryOffsetPts
            reOppStop172 := longStop
            reOppTP172 := longTP
            reOppQty172 := math.floor(f_calcPositionSize(reOppEntry172, reOppStop172) * oppositeQtyMultiplier)
            reOppQty172 := minimumOneContract and reOppQty172 < 1 ? 1 : reOppQty172
            bool haveAllL172 = not na(reOppEntry172) and not na(reOppStop172) and not na(reOppTP172) and reOppQty172 > 0
            float dHiL172 = math.abs(reOppEntry172 - high)
            float dLoL172 = math.abs(reOppEntry172 - low)
            float minDL172 = math.min(dHiL172, dLoL172)
            bool distOKL172 = minDL172 >= mt172
            if haveAllL172 and distOKL172
                reOppId172 := idLong
                reOppExitId172 := idLong + "_Exit"
                strategy.entry(reOppId172, strategy.long, stop=reOppEntry172, qty=int(reOppQty172))
                strategy.exit(reOppExitId172, from_entry=reOppId172, stop=reOppStop172, limit=reOppTP172)
                TradersPostDeluxe.SendEntryAlert(action=TradersPostDeluxe.Action.buy, quantity=int(reOppQty172), orderType=TradersPostDeluxe.OrderType.stop, takeProfit=reOppTP172, price=reOppEntry172, stopLoss=reOppStop172, id=reOppId172)
                if showDebugLabels
                    label.new(bar_index, reOppEntry172, "Phase 2: Scaled Opposite → Long", style=label.style_label_up, color=color.fuchsia, textcolor=color.white)
            else
                if showDebugLabels
                    label.new(bar_index, reOppEntry172, "Phase 2: Skipped reissue (guard/qty)", style=label.style_label_up, color=color.new(color.red, 20), textcolor=color.white)

        else if pendDir172 == -1
            reOppEntry172 := longStop + oppositeReissueEntryOffsetPts
            reOppStop172 := shortStop
            reOppTP172 := shortTP
            reOppQty172 := math.floor(f_calcPositionSize(reOppEntry172, reOppStop172) * oppositeQtyMultiplier)
            reOppQty172 := minimumOneContract and reOppQty172 < 1 ? 1 : reOppQty172
            bool haveAllS172 = not na(reOppEntry172) and not na(reOppStop172) and not na(reOppTP172) and reOppQty172 > 0
            float dHiS172 = math.abs(reOppEntry172 - high)
            float dLoS172 = math.abs(reOppEntry172 - low)
            float minDS172 = math.min(dHiS172, dLoS172)
            bool distOKS172 = minDS172 >= mt172
            if haveAllS172 and distOKS172
                reOppId172 := idShort
                reOppExitId172 := idShort + "_Exit"
                strategy.entry(reOppId172, strategy.short, stop=reOppEntry172, qty=int(reOppQty172))
                strategy.exit(reOppExitId172, from_entry=reOppId172, stop=reOppStop172, limit=reOppTP172)
                TradersPostDeluxe.SendEntryAlert(action=TradersPostDeluxe.Action.sell, quantity=int(reOppQty172), orderType=TradersPostDeluxe.OrderType.stop, takeProfit=reOppTP172, price=reOppEntry172, stopLoss=reOppStop172, id=reOppId172)
                if showDebugLabels
                    label.new(bar_index, reOppEntry172, "Phase 2: Scaled Opposite → Short", style=label.style_label_down, color=color.fuchsia, textcolor=color.white)
            else
                if showDebugLabels
                    label.new(bar_index, reOppEntry172, "Phase 2: Skipped reissue (guard/qty)", style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white)

        // Clear pending after Phase 2
        pendReissue172 := false
        pendDir172 := 0
        pendBar172 := na
        pendStage172 := 0


// ───────────────────────────────────────────────────────────────
// 17.4)── CLOSED TRADE HANDLER: split PROFIT vs STOP, and respect aggressiveFlip toggle ──
// ───────────────────────────────────────────────────────────────

if strategy.closedtrades > closedTrades
    closedTrades := strategy.closedtrades
    tradesToday := tradesToday + 1
    //lastIssuedTradeNumber := tradesToday
    placedTrades := false

    float _exit  = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float _entry = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    bool  _long  = strategy.closedtrades.size(strategy.closedtrades - 1) > 0
    bool  wasProfit = _long ? (_exit > _entry) : (_exit < _entry)

    // CHG: capture context BEFORE any resets so we can reissue on PROFIT
    bool _ctxAny = inBreakoutWindow and scoped_officialRangeStarted and not earlyExitFired and not emergencyExitSent and not sessionBlocked and not tradingHalted
    bool _tradeLimitOK = tradeLimit == 0 or tradesToday < tradeLimit
    int _nextNum = lastIssuedTradeNumber + 1

    if wasProfit or not aggressiveFlip
        // ► PROFIT (or toggle OFF): original cleanup + early-exit scheduling preserved
        if not earlyExitFired
            emergencyExitBar := bar_index + 1
            emergencyExitSent := false
            waitUntilBar := bar_index + 1
            postTradeLock := bar_index + 3
        issuedLongOrder := false
        issuedShortOrder := false
        strategy.cancel(idLong)
        strategy.cancel(idLong + "_Exit")
        strategy.cancel(idShort)
        strategy.cancel(idShort + "_Exit")

        // CHG: DO NOT tear down range/session here; we need it to reissue immediately
        // scoped_officialRangeStarted := false        // REMOVED
        // scoped_actualRangeStart := na               // REMOVED

        // CHG: reissue both brackets immediately on PROFIT (original intent) — NOW midpoint-gated
        bool _placedL = false
        bool _placedS = false
        bool _midOK = not requireMidpointReturn or tradesToday == 0 or scoped_isNearMidpoint
        bool _ctxGate = _ctxAny and _midOK
        if _ctxGate and _tradeLimitOK
            _placedL := f_placeBracket(idLong,  strategy.long,  longEntry,  longStop,  longTP,  lastIssuedTradeNumber, false, _ctxGate)
            _placedS := f_placeBracket(idShort, strategy.short, shortEntry, shortStop, shortTP, lastIssuedTradeNumber, false, _ctxGate)
            if _placedL or _placedS
                lastIssuedTradeNumber := _nextNum
                lastEntryBar := bar_index
                placedTrades := true
                if showDebugLabels
                    label.new(bar_index, low - syminfo.mintick * 120, "Exit: Profit — reissued both brackets", style=label.style_label_down, color=color.teal, textcolor=color.white)
        else
            if showDebugLabels
                label.new(bar_index, low - syminfo.mintick * 120, "Exit: Profit — gating blocked reissue", style=label.style_label_down, color=color.new(color.green, 60), textcolor=color.white)

    else
        // ► STOP (toggle ON): keep opposite eligible — 17.5 will arm/issue on next bar
        waitUntilBar := bar_index + 1
        postTradeLock := bar_index + 1
        issuedLongOrder := false
        issuedShortOrder := false
        if _long
            strategy.cancel(idLong)
            strategy.cancel(idLong + "_Exit")
        else
            strategy.cancel(idShort)
            strategy.cancel(idShort + "_Exit")
        // NEW: inside early-exit window, do NOT keep/reissue the opposite — cancel it too and stand down
        if inEarlyWindow
            strategy.cancel(idLong)
            strategy.cancel(idLong + "_Exit")
            strategy.cancel(idShort)
            strategy.cancel(idShort + "_Exit")
            pendReissue172 := false
            pendDir172 := 0
            pendBar172 := na
            pendStage172 := 0
            placedTrades := true
            if showDebugLabels
                label.new(bar_index, high + syminfo.mintick * 120, "Exit: Stop — Early Window → no opposite", style=label.style_label_down, color=color.new(color.red, 10), textcolor=color.white)
        else
            if showDebugLabels
                label.new(bar_index, high + syminfo.mintick * 120, "Exit: Stop-Out — opposite left in place", style=label.style_label_down, color=color.teal, textcolor=color.white)
            
    // (Optional) immediate lock clears if already elapsed
    if not na(waitUntilBar) and bar_index >= waitUntilBar
        waitUntilBar := na
    if not na(postTradeLock) and bar_index >= postTradeLock
        postTradeLock := na


// ───────────────────────────────────────────────────────────────
// 17.8) Abort if we are nearing the end of session and are postive, bail!!
// ───────────────────────────────────────────────────────────────

earlyExitTime = exitTime - earlyExitMinutes * 60000
if not earlyExitFired and tradesToday > 0 and time >= earlyExitTime and time < exitTime and strategy.position_size != 0
    float avgPrice = strategy.position_avg_price
    bool isLongPos = strategy.position_size > 0
    //If you’re long (isLongPos == true), it tests close > avgPrice.
    //If you’re short (isLongPos == false), it tests close < avgPrice.
    bool inProfit  = isLongPos ? close > avgPrice : close < avgPrice
    if inProfit
        strategy.close_all(comment="Early Positive Exit")
        TradersPostDeluxe.SendExitAlert(price=close)
        if showDebugLabels
            label.new(bar_index, low - syminfo.mintick * 40, "Early Exit Fired", style=label.style_label_down, color=color.green, textcolor=color.white)
        earlyExitFired := true

// ───────────────────────────────────────────────────────────────
// 17.9) Extra Exit Code (clean up bad state, it happens!)
// ───────────────────────────────────────────────────────────────

// Cleanup: executes on every bar at or after exit
if time[0] >= exitTime
    // Primary cancels
    strategy.cancel(idShort)
    strategy.cancel(idShort + "_Exit")
    strategy.cancel(idLong)
    strategy.cancel(idLong + "_Exit")

    // FIX: double-cancel sweep for any leftover reissued orders
    strategy.cancel(reOppId)
    strategy.cancel(reOppExitId)

    // Hard flatten
    strategy.close_all(comment="EOS")

    resetTimes := true

// ───────────────────────────────────────────────────────────────
// 18) PLOTS/Data Windows (precompute series, no ternaries inside plot())
// ───────────────────────────────────────────────────────────────
plot(longEntry,  title="Long Entry",  style=plot.style_linebr, color=color.aqua)
plot(shortEntry, title="Short Entry", style=plot.style_linebr, color=color.aqua)
plot(longTP,    title="Long TP",    style=plot.style_linebr,   color=color.green)
plot(shortTP,   title="Short TP",   style=plot.style_linebr,   color=color.green)
plot(longStop, style=plot.style_linebr, color=color.yellow, title="Long Stop")
plot(shortStop, style=plot.style_linebr, color=color.orange, title="Short Stop")
plot(tpSize / syminfo.mintick, title="TP Ticks", style=plot.style_linebr, color=color.green, display=display.data_window)
plot(stopSize  / syminfo.mintick, title="Stop Ticks", style=plot.style_linebr, color=color.red, display=display.data_window)
plot(longEntry - shortEntry, title="Range Size", style=plot.style_linebr, color=color.yellow, display=display.data_window)
plot(f_calcPositionSize(longEntry, longStop), title="Position Size", style=plot.style_linebr, color=color.orange, display=display.data_window)
plot(inBreakoutWindow ? tradeLimit : na, title="Active Trade Limit", color=color.orange, display=display.data_window)
plot(showVWAPComponents and (inDefine or inBreakoutWindow) ? sessionVWMA : na, title="Session VWMA", style=plot.style_linebr, color=color.orange)
plot(showVWAPComponents and (inDefine or inBreakoutWindow) ? sessionVWAP : na, title="Session VWAP", style=plot.style_linebr, color=color.purple)

// === Data Window display only for filters
plot(emaSlope, title="EMA Slope", color=color.orange, display=display.data_window)
plot(dayHigh - dayLow, title="Range Width", color=color.blue, display=display.data_window)
plot(minRangePoints, title="Min Allowed Range", color=color.blue, display=display.data_window)
plot(maxRangePoints, title="Max Allowed Range", color=color.blue, display=display.data_window)
plot(math.abs(close - ta.vwap), title="VWAP Distance", color=color.purple, display=display.data_window)
plot(sessionRSI, title="RSI Raw", color=color.green, display=display.data_window)
plot((showRSIPlot and validRange) ? rsiOverlay : na, title="RSI (Overlay)", color=color.green, linewidth=1, style=plot.style_linebr)

// === Data Window Logging of Filter Status ===
plot(sessionValid ? 1 : 0, title="Session Valid", color=color.gray, display=display.data_window)
plot(useVWAPDistanceFilter ? (vwapDistanceOk ? 1 : 0) : na, title="VWAP OK", color=color.purple, display=display.data_window)
plot(useEMASlopeFilter ? (emaSlopeOk ? 1 : 0) : na, title="EMA Slope OK", color=color.orange, display=display.data_window)
plot(useRSIFilter ? (rsiValid ? 1 : 0) : na, title="RSI OK", color=color.green, display=display.data_window)
plotchar(na(sessionInvalidReason) ? na : 1, title="Session Reason Exists", char='⟶', location=location.top, display=display.data_window)

//New TP2/Oppsite side trade mode
plot(oppositeTradeMode == "Keep Opposite (Scaled Qty + Adjusted Entry)" ? 1 : na, title="Opposite Mode: Scaled Reissue", display=display.data_window)

// ─────────────────────────────
// 📊 Data Window Debug Plots for Deferred Start
// ─────────────────────────────
plot(scoped_officialRangeStarted ? 1 : 0, title="Scoped Official Range Started", color=color.purple, display=display.data_window)
plot(midpointStartTolerancePct > 0 ? 1 : 0, title="Deferred Start Proximity Filter Enabled", color=color.fuchsia, display=display.data_window)
plot(midpointStartTolerancePct, title = "Midpoint Proximity Percent %", display = display.data_window, color = na)
plot(scoped_inBreakoutWindow ? 1 : 0, title="Scoped In Breakout Window", color=color.red, display=display.data_window)
plot(scoped_inDeferredBreakout ? 1 : 0, title="Scoped Deferred Breakout", color=color.orange, display=display.data_window)
plot(scoped_isNearMidpoint ? 1 : 0, title="Scoped Near Midpoint", color=color.yellow, display=display.data_window)
plot(scoped_rangeMidpoint, title="Scoped Range Midpoint", color=color.gray, display=display.data_window)
plot(scoped_rangeWidth, title="Scoped Range Width", color=color.blue, display=display.data_window)
plot(math.abs(close - scoped_rangeMidpoint), title="Midpoint Distance", color=color.fuchsia)
plot(scoped_rangeWidth * midpointStartTolerancePct / 100, title="Allowed Deviation", color=color.teal)

// ────────────────────────────────────────────────────────────
// Map sessionInvalidReason → numeric code, and plot to Data Window
// (must be at top–level scope, not nested inside an if)
// ────────────────────────────────────────────────────────────
// 1=Range too narrow, 2=Too close to VWAP, 3=EMA slope too flat, 4=RSI out of bounds
reasonCode = sessionInvalidReason == "Range too narrow"    ? 1 :
             sessionInvalidReason == "Too close to VWAP"   ? 2 :
             sessionInvalidReason == "EMA slope too flat"  ? 3 :
             sessionInvalidReason == "RSI out of bounds"    ? 4 : 0
plot(reasonCode, title="Session Invalid Reason", display=display.data_window)

// ───────────────────────────────────────────────────────────────
// 19) SESSION INFO PANEL (lightweight; day-by-day)
// ───────────────────────────────────────────────────────────────
var float lastEntryPrice = na
var bool lastWasLong = false
var bool lastWasLongValid = false
var int lastClosedTrades = 0
var float plPoints = na
var float qty = na

var float debugLastEntry = na
var bool debugLastWasLong = false
var bool debugTradeArmed = false

showSessionBox = input.bool(true, "Show Session Info Box", tooltip="Displays session stats", group="Display Settings")

// Tick to point and $ conversion helpers
f_ticksToPoints(_raw) => syminfo.mintick != 0 ? (_raw / syminfo.mintick) / 4 : _raw
f_dollars(_pts, _qty) => _pts * 2 * math.abs(_qty)

// If armed from bracket logic
if debugTradeArmed and na(lastEntryPrice)
    lastEntryPrice := debugLastEntry
    lastWasLong := debugLastWasLong
    lastWasLongValid := true

// Detect trade closed
if strategy.closedtrades > lastClosedTrades
    lastClosedTrades := strategy.closedtrades
    float exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    qty := strategy.closedtrades.size(strategy.closedtrades - 1)

    if showPnLIndicators == "Yes" and qty != 0 and not na(entryPrice) and not na(exitPrice)
        bool isLong = qty > 0
        float rawPL = isLong ? (exitPrice - entryPrice) : (entryPrice - exitPrice)
        plPoints := f_ticksToPoints(rawPL)
        float dollarPL = f_dollars(plPoints, qty)

        string labelText = "P/L: " + str.tostring(plPoints, "#.##") + " pts, $" + str.tostring(dollarPL, "#.##") + " [" + (isLong ? "Long" : "Short") + "]"
        bool isProfit = plPoints > 0
        color labelColor = isProfit ? color.green : color.red
        //float yOffset = syminfo.mintick * 75
        //bool placeAbove = (isLong and isProfit) or (not isLong and not isProfit)
        //float yPos = placeAbove ?  (high + yOffset) : (low - yOffset)
        //labelStyle = placeAbove ? label.style_label_down : label.style_label_up
        // Place profits above the bar, losses below (prevents overlap on same bar)
        float yOffsetProfit = syminfo.mintick * 90
        float yOffsetLoss   = syminfo.mintick * 90
        bool  placeAbove    = isProfit
        float yPos          = isProfit ? (high + yOffsetProfit) : (low - yOffsetLoss)
        labelStyle          = isProfit ? label.style_label_down : label.style_label_up
        label.new(bar_index, yPos, labelText, style=labelStyle, color=labelColor, textcolor=color.white, size=size.small)

    lastEntryPrice := na
    lastWasLongValid := false
    debugTradeArmed := false

plot(plPoints, title="PL Points", display=display.data_window, color=color.green)
plot(qty, title="Last Trade Qty", display=display.data_window, color=color.orange)
plot((not na(rangeStart) and not na(exitTime) and time >= rangeStart and time <= exitTime) ? f_calcSessionPL(rangeStart, exitTime) : na, title="Session PnL ($)", color=color.fuchsia, display=display.data_window)

f_getPLTextColor(_pl) => _pl > 0 ? color.green : _pl < 0 ? color.red : color.white

// 🛡️ Snapshot only when trades are present and during session window
if time >= rangeStart and time <= exitTime and tradesToday > 0
    sessionPL_snapshot := f_calcSessionPL(rangeStart, exitTime)
    tradesToday_snapshot := tradesToday
    snapshotRangeStart := rangeStart //added because of prior day bleed over bug

// ───────────────────────────────────────────────────────────────
// 20) Trade and Session Cleanup
// ───────────────────────────────────────────────────────────────

var bool didSessionEnd = false
// Single-line label showing the boolean as text
//label.new(bar_index, high + syminfo.mintick*20, didSessionEnd ? "true" : "false", style=label.style_label_down, color=color.teal, textcolor=color.white)

dayOfWeekNow = dayofweek(time)

if bar_index > 0 and time[1] < exitTime and time >= exitTime and not didSessionEnd and not earlyExitFired and dayOfWeekNow != dayofweek.sunday

    if showDebugLabels
        label.new(bar_index, high + 40, "Exit Alert Fired", style=label.style_label_down, color=color.fuchsia, textcolor=color.white)
    TradersPostDeluxe.SendExitAlert(price = close)
    didSessionEnd := true

if didSessionEnd and bar_index > 0
    tradesToday := 0
    placedTrades := false
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    resetTimes := true
    didSessionEnd := false
    sessionBlocked :=false
    issuedLongOrder  := false
    issuedShortOrder := false
    // 🔄 Reset info box state
    sessionPL_snapshot := na
    tradesToday_snapshot := na
    sessionTable := na

// Clear stale snapshot if it belongs to a prior session - added due to prior day bleed over bug
if not na(sessionPL_snapshot) and not na(snapshotRangeStart) and snapshotRangeStart != rangeStart
    sessionPL_snapshot := na
    tradesToday_snapshot := na
    sessionTable := na

if showSessionBox and not na(sessionPL_snapshot)
    table.delete(sessionTable[1])
    sessionTable := table.new(position=position.top_right, columns=2, rows=6, bgcolor=color.new(color.blue, 90), border_width=1, border_color=color.blue)

    //label for display box to last completed to live session
    var string lastSessionLabel = na
    var int lastTradeLimitSnapshot = na
    if bar_index > 0 and time[1] < rangeStart and time >= rangeStart
        lastSessionLabel := rangeSetSnapshot
        lastTradeLimitSnapshot := tradeLimit
    bool isLiveSession = barstate.isrealtime and time >= rangeStart and time <= exitTime
    string contextText = "3:10"

    table.cell(sessionTable, 0, 0, text="Context", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 0, text=contextText, bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 0, 1, text="Max Trades", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 1, text=str.tostring(not na(lastTradeLimitSnapshot) ? lastTradeLimitSnapshot : tradeLimit), bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 0, 2, text="Trades Today", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 2, text=str.tostring(tradesToday_snapshot), bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 0, 3, text="Session Risk", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 3, text="$" + str.tostring(riskDollars, "#.##"), bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 0, 4, text="Session PnL", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 4, text="$" + str.tostring(sessionPL_snapshot, "#.##"), bgcolor=color.navy, text_color=f_getPLTextColor(sessionPL_snapshot))
    table.cell(sessionTable, 0, 5, text="Day PnL", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 5, text="$" + str.tostring(dayPL, "#.##"), bgcolor=color.navy, text_color=f_getPLTextColor(dayPL))


// ───────────────────────────────────────────────────────────────
// 21) STRATEGY-CONFIRMED ENTRY & EXIT ALERTS (with full JSON)
// ───────────────────────────────────────────────────────────────

// ───────────────────────
// Exit Alerts (after strategy exit)
// ───────────────────────
// Exit Alerts (after strategy exit) — suppress only for stop + aggressiveFlip when NOT in early window
if strategy.closedtrades > strategy.closedtrades[1]
    float exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    float tradeSize = strategy.closedtrades.size(strategy.closedtrades - 1)
    bool  wasLong   = tradeSize > 0
    bool  isStop    = wasLong ? (exitPrice <= entryPrice) : (exitPrice >= entryPrice)
    bool  suppress  = aggressiveFlip and isStop and not inEarlyWindow
    if suppress
        exitPrice := exitPrice  // no-op; required non-empty branch
    else
        TradersPostDeluxe.SendExitAlert(price = exitPrice)

//safer version to test later 
//
//if strategy.closedtrades > lastClosedTrades
//    float exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
//    float entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
//    string exitType = exitPrice > entryPrice ? "target" : "stop"
//    TradersPostDeluxe.SendExitAlert(price = exitPrice)

// Debug Plots (Line ~900)
plot(issuedLongOrder ? 1 : 0, title="Debug: Issued Long Order", color=color.blue, display=display.data_window)
plot(issuedShortOrder ? 1 : 0, title="Debug: Issued Short Order", color=color.red, display=display.data_window)

plotshape(time >= exitTime and (issuedLongOrder or issuedShortOrder) and not didSessionEnd and barstate.islastconfirmedhistory
     ? true : false,
     title="EOS Debug", location=location.abovebar,
     style=shape.labeldown, text="EOS")