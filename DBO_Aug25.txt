//@version=6
strategy("BB NextGen DBO", shorttitle="BB_DBO", overlay=true, calc_on_every_tick=true, process_orders_on_close=false, margin_long=0, margin_short=0)
import adam_overton/TradersPostDeluxe/1

// ──────────────────────────────────────────────────────────
// MULTI-SESSION CONFIGURATION BLOCK
// ────────────────────────────────────────────────────────
string tzInput = "America/New_York"
bool enable310  = input.bool(true, "Enable 3:10",  group="Time Slots")
bool enable645  = input.bool(false, "Enable 6:45",  group="Time Slots")
bool enable1045 = input.bool(false, "Enable 10:45", group="Time Slots")
bool enable1240 = input.bool(false, "Enable 12:40", group="Time Slots")
bool enable1605 = input.bool(false, "Enable 16:05", group="Time Slots")
bool enable1835 = input.bool(false, "Enable 18:35", group="Time Slots")
bool enable2300 = input.bool(false, "Enable 23:00", group="Time Slots")
showPnLIndicators = input.string("Yes", "Show Profit/Loss Indicators", options=["Yes", "No"], group="Display Settings")
showDebugLabels = input.bool(true, "Show Debug/Alert Labels", group="Display Settings")
showVWAPComponents = input.bool(true, "Show VWAP Plot", group="Display Settings")
showRSIPlot = input.bool(false, "Show RSI Overlay", group="Display Settings")

f_getRangeSlot() =>
    h = hour(time, tzInput)
    m = minute(time, tzInput)
    t = h * 60 + m
    if t < 190
        "3:10"
    else if t < 405
        "6:45"
    else if t < 645
        "10:45"
    else if t < 760
        "12:40"
    else if t < 965
        "16:05"
    else if t < 1115
        "18:35"
    else
        "23:00"

// helper to build timestamps in user TZ
f_ts(y, m, d, h, mi) =>
    timestamp(tzInput, y, m, d, h, mi)

var bool resetTimes = true
var string rangeSetSnapshot = na
var int tradeLimitSnapshot = na
var int rangeStart = na
var int rangeEnd = na
var int exitTime = na
var bool scoped_officialRangeStarted = false
var int scoped_actualRangeStart   = na
var int lastEntryBar               = -1

// Dynamic configuration variables
string vwapModeInput = input.string("Session", "VWAP Anchor", options=["Session", "Auto"])
int vwapLenInput = input.int(14, "VWAP Length (bars, if Auto)", minval=1)
int rangeEndHour = 6, rangeEndMin = 45
int lookbackH = 0, lookbackM = 15
int exitDurH = 1, exitDurM = 15
int tradeLimit = 1
float entryOff = 0.0
float stopOff = 0.0
float tpRatio = 0.28
float rrRatio = 0.5
float ptsSL = 11.0
float vwOffset = 0.5
string vwapMode = vwapModeInput
int vwapLen = vwapLenInput
var bool sessionValid = true
bool sessionFlagged = false
string sessionInvalidReason = ""
var bool issuedLongOrder = false
var bool issuedShortOrder = false
var bool drew = false
var bool sessionBlocked = false
var int  emergencyExitBar   = na
var bool emergencyExitSent  = false
var int lastIssuedTradeNumber = 0



// ─────────── Trade‐risk inputs ───────────
riskDollars        = input.float(500.0, "Per Session Risk Dollars", tooltip="Total amount to risk per trade if not session specfic defined")
maxDailyLoss       = input.float(0.0, title="Max Daily Loss", tooltip="Set to 0 for unlimited risk")
haltAfterProfit = input.bool(false, "Halt Trading After Day is Green", tooltip="If we are green, stop trading, then exit")
earlyExitMinutes = input.int(10, "Early Exit Minutes Before Session End", minval=0, tooltip="If we are green right before session then exit")
var bool earlyExitFired = false
minimumOneContract = input.bool(true, "Minimum One Contract", tooltip="Force at least one contract even if risk% yields 0")
trailStop          = input.bool(false, "Trailing Stop")
trailStopTrigger   = input.int(50, "Percentage of trailing stop to start the trail")
slType   = input.string("RR", "Stop Loss Type", options=["RR","Points","VWAP","ATR"])
aggressiveFlip = input.bool(true, "Allow opposite entry after stop ala DBO", group="Quality Filters", tooltip="OFF = original behavior. ON = do not cancel the opposite bracket while in a trade, and after a stop only clear the failed side so the opposite can trigger immediately.")

// === Session Quality Filter Settings ===
useVWAPDistanceFilter = input.bool(false, "Enable VWAP Distance Filter", group="Quality Filters")
minVWAPDistance = input.float(2.0, "Minimum Distance from VWAP (pts)", group="Quality Filters")

minRangePoints = input.float(25, "Minimum Range Width (pts)", group="Quality Filters", tooltip="-1 default to disable")
maxRangePoints = input.float(-1, "Maximum Range Width (pts)", group="Quality Filters", tooltip="-1 default to disable")


useEMASlopeFilter = input.bool(false, "Enable EMA Slope Filter", group="Quality Filters")
emaSlopeLength = input.int(21, "EMA Length", group="Quality Filters")
emaSlopeLookback = input.int(5, "EMA Slope Lookback Bars", group="Quality Filters")
minEMASlope = input.float(2.0, "Minimum EMA Slope", group="Quality Filters")

useRSIFilter = input.bool(false, "Enable RSI Filter", group="Quality Filters")
rsiLength = input.int(20, "RSI Length", group="Quality Filters")
rsiMin = input.float(45.0, "RSI Min Threshold", group="Quality Filters")
rsiMax = input.float(75.0, "RSI Max Threshold", group="Quality Filters")

// ───────────────────────────────────────────────────────────────
// ► ATR Settings & Helpers ◄
// ───────────────────────────────────────────────────────────────
fixATRDuringBreakout = input.string("Yes", "Fixed ATR for Breakout Range", options=["Yes", "No"], group="ATR Settings", tooltip="If Yes, locks ATR for the entire breakout session at breakout start")
atrLength         = input.int(14,   "ATR Length",         group="ATR Settings", tooltip="Periods for session ATR")
atrFallbackLength = input.int(50,   "Fallback ATR Length",group="ATR Settings", tooltip="Periods for global ATR if session ATR not ready")
maxATRMult        = input.float(2.5, "Max ATR Multiplier", group="ATR Settings", tooltip="Cap on ATR scaling")

// ───────────────────────────────────────────────────────────────
// ► ATR Calculation Logic
// ───────────────────────────────────────────────────────────────
var float snapATR = na
var float snapATRRatio = na
var float snapAdjPtsSL = na
var float snapAdjTPSize = na

atrSession = ta.atr(atrLength)
atrGlobal = ta.atr(atrFallbackLength)

barsSinceStart = bar_index - ta.valuewhen(time == rangeStart, bar_index, 0)
useSessionATR = not na(barsSinceStart) and barsSinceStart >= atrLength
atrLive = useSessionATR ? atrSession : atrGlobal
atrUsed = (fixATRDuringBreakout == "Yes" and not na(snapATR)) ? snapATR : atrLive

// Snap ATR at breakout start
if time[1] < rangeEnd and time >= rangeEnd
    snapATR := atrLive
    snapATRRatio := math.min(snapATR / atrGlobal, maxATRMult)
    snapAdjPtsSL := slType == "ATR" ? ptsSL * snapATRRatio : ptsSL
    snapAdjTPSize := snapAdjPtsSL * (tpRatio / rrRatio)

// ───────────────────────────────────────────────────────────────

if resetTimes
    slot = f_getRangeSlot()
    enableSlot = (slot == "3:10" and enable310) or (slot == "6:45" and enable645) or (slot == "10:45" and enable1045) or (slot == "12:40" and enable1240) or (slot == "16:05" and enable1605) or (slot == "18:35" and enable1835) or (slot == "23:00" and enable2300)
    rangeSetSnapshot := enableSlot ? slot : na
    rangeEnd := na
    rangeStart := na
    exitTime := na

    rangeEndHour := na, rangeEndMin := na



//“Delay range tracking until price nears VWAP”.
//useMidpointProximityStart = input.bool(false, "Defer Range Start Until Near Midpoint", group="Quality Filters")
midpointStartTolerancePct = input.float(25.0, "Midpoint Start Proximity (%)", group="Quality Filters", minval = -1, maxval = 100,tooltip="-1 default to use global setting")
requireMidpointReturn = input.bool(true, "Require Midpoint Quality after Trade 1", group="Quality Filters")


// ────────────────
// 📅 Sev 3 News Date Filter
// ────────────────
useSev3Filter = input.bool(true, "Skip Trading on Sev 3 News Days", group="Quality Filters")

var sev3Dates = array.new_string()
if bar_index == 0
    array.push(sev3Dates, "2025-06-02"), array.push(sev3Dates, "2025-06-04"), array.push(sev3Dates, "2025-06-06")
    array.push(sev3Dates, "2025-06-12"), array.push(sev3Dates, "2025-06-18"), array.push(sev3Dates, "2025-07-01")
    array.push(sev3Dates, "2025-07-02"), array.push(sev3Dates, "2025-07-03"), array.push(sev3Dates, "2025-07-09")
    array.push(sev3Dates, "2025-07-16"), array.push(sev3Dates, "2025-07-30"), array.push(sev3Dates, "2025-08-01")
    array.push(sev3Dates, "2025-08-05"), array.push(sev3Dates, "2025-08-14"), array.push(sev3Dates, "2025-08-20")
    array.push(sev3Dates, "2025-09-02"), array.push(sev3Dates, "2025-09-04"), array.push(sev3Dates, "2025-09-05")
    array.push(sev3Dates, "2025-09-10"), array.push(sev3Dates, "2025-09-17"), array.push(sev3Dates, "2025-10-01")
    array.push(sev3Dates, "2025-10-03"), array.push(sev3Dates, "2025-10-08"), array.push(sev3Dates, "2025-10-16")
    array.push(sev3Dates, "2025-10-29"), array.push(sev3Dates, "2025-11-03"), array.push(sev3Dates, "2025-11-05")
    array.push(sev3Dates, "2025-11-07"), array.push(sev3Dates, "2025-11-14"), array.push(sev3Dates, "2025-11-19")
    array.push(sev3Dates, "2025-12-01"), array.push(sev3Dates, "2025-12-03"), array.push(sev3Dates, "2025-12-05")
    array.push(sev3Dates, "2025-12-10"), array.push(sev3Dates, "2025-12-11")

todayStr = str.tostring(year(time, tzInput)) + "-" + str.tostring(month(time, tzInput), "00") + "-" + str.tostring(dayofmonth(time, tzInput), "00")
sev3Blocked = useSev3Filter and array.includes(sev3Dates, todayStr)


// ─────────────────────────────
// 🧩 Session-Specific Inputs (Grouped)
// ─────────────────────────────

// 3:10 Session
group310 = "Session: 3:10"
riskDollars_310 = input.float(500, "Risk ($)", group=group310, tooltip="-1 default to use global setting")
midpointStartProximityOverride_310 = input.int(35, group=group310, title="Override: Midpoint Start Proximity (%)", minval = -1, maxval = 100, tooltip="-1 default to use global setting")
minRangePointsOverride_310 = input.int(defval = 50, group=group310, title = "Override: Use Range Width Filter", minval = -1, tooltip="-1 default to use global setting")
maxRangePointsOverride_310 = input.int(defval = -1, group=group310, title = "Override: Max Range Width (pts)", minval = -1, tooltip="-1 default to use global setting")
rangeEndHour_310 = input.int(6, "Range End Hour", group=group310)
rangeEndMin_310 = input.int(34, "Range End Min", group=group310)
lookbackH_310 = input.int(4, "Lookback Hour", group=group310)
lookbackM_310 = input.int(0, "Lookback Min", group=group310)
exitDurH_310 = input.int(9, "Exit Duration Hour", group=group310)
exitDurM_310 = input.int(35, "Exit Duration Min", group=group310)
tradeLimit_310 = input.int(3, "Trade Limit", group=group310)
entryOff_310 = input.float(10.0, "Entry Offset", group=group310)
stopOff_310 = input.float(2.0, "Stop Offset", group=group310)
tpRatio_310 = input.float(0.55, "TP Ratio", group=group310)
rrRatio_310 = input.float(1.7, "SL:TP Ratio/R:R Inverted", group=group310)
ptsSL_310 = input.float(14.0, "Stop Loss (pts)", group=group310)
vwOffset_310 = input.float(0.5, "VWAP Offset", group=group310)

// 6:45 Session
group645 = "Session: 6:45"
riskDollars_645 = input.float(-1, "Risk ($)", group=group645, tooltip="-1 default to use global setting" )
midpointStartProximityOverride_645 = input.int(-1, group=group645, title="Override: Midpoint Start Proximity (%)", minval = -1, maxval = 100, tooltip="-1 default to use global setting")
minRangePointsOverride_645 = input.int(defval = -1, group=group645, title = "Override: Use Range Width Filter", minval = -1, tooltip="-1 default to use global setting")
maxRangePointsOverride_645 = input.int(defval = -1, group=group645, title = "Override: Max Range Width (pts)", minval = -1, tooltip="-1 default to use global setting")
rangeEndHour_645 = input.int(6, "Range End Hour", group=group645)
rangeEndMin_645 = input.int(45, "Range End Min", group=group645)
lookbackH_645 = input.int(0, "Lookback Hour", group=group645)
lookbackM_645 = input.int(15, "Lookback Min", group=group645)
exitDurH_645 = input.int(1, "Exit Duration Hour", group=group645)
exitDurM_645 = input.int(15, "Exit Duration Min", group=group645)
tradeLimit_645 = input.int(1, "Trade Limit", group=group645)
entryOff_645 = input.float(0.0, "Entry Offset", group=group645)
stopOff_645 = input.float(0.0, "Stop Offset", group=group645)
tpRatio_645 = input.float(0.28, "TP Ratio", group=group645)
rrRatio_645 = input.float(1, "SL:TP Ratio/R:R Inverted", group=group645)
ptsSL_645 = input.float(11.0, "Stop Loss (pts)", group=group645)

// 10:45 Session
group1045 = "Session: 10:45"
riskDollars_1045 = input.float(-1, "Risk ($)", group=group1045, tooltip="-1 default to use global setting")
midpointStartProximityOverride_1045 = input.int(25, group=group1045, title="Override: Midpoint Start Proximity (%)", minval = -1, maxval = 100, tooltip="-1 default to use global setting")
maxRangePointsOverride_1045 = input.int(defval = -1, group=group1045, title = "Override: Max Range Width (pts)", minval = -1, tooltip="-1 default to use global setting")
minRangePointsOverride_1045 = input.int(defval = 25, group=group1045, title = "Override: Use Range Width Filter", minval = -1, tooltip="-1 default to use global setting")
rangeEndHour_1045 = input.int(10, "Range End Hour", group=group1045)
rangeEndMin_1045 = input.int(45, "Range End Min", group=group1045)
lookbackH_1045 = input.int(0, "Lookback Hour", group=group1045)
lookbackM_1045 = input.int(15, "Lookback Min", group=group1045)
exitDurH_1045 = input.int(1, "Exit Duration Hour", group=group1045)
exitDurM_1045 = input.int(45, "Exit Duration Min", group=group1045)
tradeLimit_1045 = input.int(1, "Trade Limit", group=group1045)
entryOff_1045 = input.float(0.0, "Entry Offset", group=group1045)
stopOff_1045 = input.float(0.0, "Stop Offset", group=group1045)
tpRatio_1045 = input.float(0.44, "TP Ratio", group=group1045)
rrRatio_1045 = input.float(1, "SL:TP Ratio/R:R Inverted", group=group1045)
ptsSL_1045 = input.float(21.0, "Stop Loss (pts)", group=group1045)

// 12:40 Session
group1240 = "Session: 12:40"
riskDollars_1240 = input.float(-1, "Risk ($)", group=group1240, tooltip="-1 default to use global setting")
midpointStartProximityOverride_1240 = input.int(25, group=group1240, title="Override: Midpoint Start Proximity (%)", minval = -1, maxval = 100, tooltip="-1 default to use global setting")
minRangePointsOverride_1240 = input.int(defval = 1, group=group1240, title = "Override: Use Range Width Filter", minval = -1, tooltip="-1 default to use global setting")
maxRangePointsOverride_1240 = input.int(defval = -1, group=group1240, title = "Override: Max Range Width (pts)", minval = -1, tooltip="-1 default to use global setting")
rangeEndHour_1240 = input.int(12, "Range End Hour", group=group1240)
rangeEndMin_1240 = input.int(40, "Range End Min", group=group1240)
lookbackH_1240 = input.int(0, "Lookback Hour", group=group1240)
lookbackM_1240 = input.int(5, "Lookback Min", group=group1240)
exitDurH_1240 = input.int(0, "Exit Duration Hour", group=group1240)
exitDurM_1240 = input.int(30, "Exit Duration Min", group=group1240)
tradeLimit_1240 = input.int(1, "Trade Limit", group=group1240)
entryOff_1240 = input.float(1.0, "Entry Offset", group=group1240)
stopOff_1240 = input.float(0.0, "Stop Offset", group=group1240)
tpRatio_1240 = input.float(0.21, "TP Ratio", group=group1240)
rrRatio_1240 = input.float(1, "SL:TP Ratio/R:R Inverted", group=group1240)
ptsSL_1240 = input.float(14.0, "Stop Loss (pts)", group=group1240)

// 16:05 Session - moved to 3:40 need to update label
group1605 = "Session: 16:05"
riskDollars_1605 = input.float(-1, "Risk ($)", group=group1605, tooltip="-1 default to use global setting")
midpointStartProximityOverride_1605 = input.int(25, group=group1605, title="Override: Midpoint Start Proximity (%)", minval = -1, maxval = 100, tooltip="-1 default to use global setting")
minRangePointsOverride_1605 = input.int(defval = 25, group=group1605, title = "Override: Use Range Width Filter", minval = -1, tooltip="-1 default to use global setting")
maxRangePointsOverride_1605 = input.int(defval = -1, group=group1605, title = "Override: Max Range Width (pts)", minval = -1, tooltip="-1 default to use global setting")
rangeEndHour_1605 = input.int(15, "Range End Hour", group=group1605)
rangeEndMin_1605 = input.int(40, "Range End Min", group=group1605)
lookbackH_1605 = input.int(0, "Lookback Hour", group=group1605)
lookbackM_1605 = input.int(40, "Lookback Min", group=group1605)
exitDurH_1605 = input.int(2, "Exit Duration Hour", group=group1605)
exitDurM_1605 = input.int(15, "Exit Duration Min", group=group1605)
tradeLimit_1605 = input.int(1, "Trade Limit", group=group1605)
entryOff_1605 = input.float(0.0, "Entry Offset", group=group1605)
stopOff_1605 = input.float(0.0, "Stop Offset", group=group1605)
tpRatio_1605 = input.float(0.44, "TP Ratio", group=group1605)
rrRatio_1605 = input.float(1, "SL:TP Ratio/R:R Inverted", group=group1605)
ptsSL_1605 = input.float(40.0, "Stop Loss (pts)", group=group1605)

// 18:35 Session
group1835 = "Session: 18:35"
riskDollars_1835 = input.float(-1, "Risk ($)", group=group1835, tooltip="-1 default to use global setting")
midpointStartProximityOverride_1835 = input.int(50, group=group1835, title="Override: Midpoint Start Proximity (%)", minval = -1, maxval = 100, tooltip="-1 default to use global setting")
minRangePointsOverride_1835 = input.int(defval = 25, group=group1835, title = "Override: Use Range Width Filter", minval = -1, tooltip="-1 default to use global setting")
maxRangePointsOverride_1835 = input.int(defval = -1, group=group1835, title = "Override: Max Range Width (pts)", minval = -1, tooltip="-1 default to use global setting")
rangeEndHour_1835 = input.int(18, "Range End Hour", group=group1835)
rangeEndMin_1835 = input.int(35, "Range End Min", group=group1835)
lookbackH_1835 = input.int(0, "Lookback Hour", group=group1835)
lookbackM_1835 = input.int(36, "Lookback Min", group=group1835)
exitDurH_1835 = input.int(3, "Exit Duration Hour", group=group1835)
exitDurM_1835 = input.int(23, "Exit Duration Min", group=group1835)
tradeLimit_1835 = input.int(2, "Trade Limit", group=group1835)
entryOff_1835 = input.float(0.0, "Entry Offset", group=group1835)
stopOff_1835 = input.float(0.0, "Stop Offset", group=group1835)
tpRatio_1835 = input.float(0.26, "TP Ratio", group=group1835)
rrRatio_1835 = input.float(1, "SL:TP Ratio/R:R Inverted", group=group1835)
ptsSL_1835 = input.float(19.0, "Stop Loss (pts)", group=group1835)

// 23:00 Session
group2300 = "Session: 23:00"
riskDollars_2300 = input.float(-1, "Risk ($)", group=group2300, tooltip="-1 default to use global setting")
midpointStartProximityOverride_2300 = input.int(50, group=group2300, title="Override: Midpoint Start Proximity (%)", minval = -1, maxval = 100, tooltip="-1 default to use global setting")
minRangePointsOverride_2300 = input.int(defval = 25, group=group2300, title = "Override: Use Range Width Filter", minval = -1, tooltip="-1 default to use global setting")
maxRangePointsOverride_2300 = input.int(defval = -1, group=group2300, title = "Override: Max Range Width (pts)", minval = -1, tooltip="-1 default to use global setting")
rangeEndHour_2300 = input.int(23, "Range End Hour", group=group2300)
rangeEndMin_2300 = input.int(0, "Range End Min", group=group2300)
lookbackH_2300 = input.int(1, "Lookback Hour", group=group2300)
lookbackM_2300 = input.int(0, "Lookback Min", group=group2300)
exitDurH_2300 = input.int(2, "Exit Duration Hour", group=group2300)
exitDurM_2300 = input.int(0, "Exit Duration Min", group=group2300)
tradeLimit_2300 = input.int(2, "Trade Limit", group=group2300)
entryOff_2300 = input.float(0.0, "Entry Offset", group=group2300)
stopOff_2300 = input.float(0.0, "Stop Offset", group=group2300)
tpRatio_2300 = input.float(0.27, "TP Ratio", group=group2300)
rrRatio_2300 = input.float(1, "SL:TP Ratio/R:R Invertedo", group=group2300)
ptsSL_2300 = input.float(15.0, "Stop Loss (pts)", group=group2300)
vwOffset_2300 = input.float(0.5, "VWAP Offset", group=group2300)

// ─────────────────────────────
// 🧠 Apply Session Overrides
// ─────────────────────────────

if not na(rangeSetSnapshot) and rangeSetSnapshot == "3:10" and enable310
    rangeEndHour := rangeEndHour_310, rangeEndMin := rangeEndMin_310
    lookbackH := lookbackH_310, lookbackM := lookbackM_310
    exitDurH := exitDurH_310, exitDurM := exitDurM_310
    tradeLimit := tradeLimit_310, entryOff := entryOff_310, stopOff := stopOff_310
    tpRatio := tpRatio_310, rrRatio := rrRatio_310, ptsSL := ptsSL_310, vwOffset := vwOffset_310
    riskDollars := riskDollars_310 != -1.0 ? riskDollars_310 : riskDollars
    minRangePoints := minRangePointsOverride_310 == -1 ? minRangePoints : minRangePointsOverride_310
    maxRangePoints := maxRangePointsOverride_310 == -1 ? maxRangePoints : maxRangePointsOverride_310
    midpointStartTolerancePct := midpointStartProximityOverride_310 == -1 ? midpointStartTolerancePct : midpointStartProximityOverride_310

if not na(rangeSetSnapshot) and rangeSetSnapshot == "6:45" and enable645
    rangeEndHour := rangeEndHour_645, rangeEndMin := rangeEndMin_645
    lookbackH := lookbackH_645, lookbackM := lookbackM_645
    exitDurH := exitDurH_645, exitDurM := exitDurM_645
    tradeLimit := tradeLimit_645, entryOff := entryOff_645, stopOff := stopOff_645
    tpRatio := tpRatio_645, rrRatio := rrRatio_645, ptsSL := ptsSL_645
    riskDollars := riskDollars_645 != -1.0 ? riskDollars_645 : riskDollars
    minRangePoints := minRangePointsOverride_645 == -1 ? minRangePoints : minRangePointsOverride_645
    maxRangePoints := maxRangePointsOverride_645 == -1 ? maxRangePoints : maxRangePointsOverride_645
    midpointStartTolerancePct := midpointStartProximityOverride_645 == -1 ? midpointStartTolerancePct : midpointStartProximityOverride_645

if not na(rangeSetSnapshot) and rangeSetSnapshot == "10:45" and enable1045
    rangeEndHour := rangeEndHour_1045, rangeEndMin := rangeEndMin_1045
    lookbackH := lookbackH_1045, lookbackM := lookbackM_1045
    exitDurH := exitDurH_1045, exitDurM := exitDurM_1045
    tradeLimit := tradeLimit_1045, entryOff := entryOff_1045, stopOff := stopOff_1045
    tpRatio := tpRatio_1045, rrRatio := rrRatio_1045, ptsSL := ptsSL_1045
    riskDollars := riskDollars_1045 != -1.0 ? riskDollars_1045 : riskDollars
    minRangePoints := minRangePointsOverride_1045 == -1 ? minRangePoints : minRangePointsOverride_1045
    maxRangePoints := maxRangePointsOverride_1045 == -1 ? maxRangePoints : maxRangePointsOverride_1045
    midpointStartTolerancePct := midpointStartProximityOverride_1045 == -1 ? midpointStartTolerancePct : midpointStartProximityOverride_1045

if not na(rangeSetSnapshot) and rangeSetSnapshot == "12:40" and enable1240
    rangeEndHour := rangeEndHour_1240, rangeEndMin := rangeEndMin_1240
    lookbackH := lookbackH_1240, lookbackM := lookbackM_1240
    exitDurH := exitDurH_1240, exitDurM := exitDurM_1240
    tradeLimit := tradeLimit_1240, entryOff := entryOff_1240, stopOff := stopOff_1240
    tpRatio := tpRatio_1240, rrRatio := rrRatio_1240, ptsSL := ptsSL_1240
    riskDollars := riskDollars_1240 != -1.0 ? riskDollars_1240 : riskDollars
    minRangePoints := minRangePointsOverride_1240 == -1 ? minRangePoints : minRangePointsOverride_1240
    maxRangePoints := maxRangePointsOverride_1240 == -1 ? maxRangePoints : maxRangePointsOverride_1240
    midpointStartTolerancePct := midpointStartProximityOverride_1240 == -1 ? midpointStartTolerancePct : midpointStartProximityOverride_1240

if not na(rangeSetSnapshot) and rangeSetSnapshot == "16:05" and enable1605
    rangeEndHour := rangeEndHour_1605, rangeEndMin := rangeEndMin_1605
    lookbackH := lookbackH_1605, lookbackM := lookbackM_1605
    exitDurH := exitDurH_1605, exitDurM := exitDurM_1605
    tradeLimit := tradeLimit_1605, entryOff := entryOff_1605, stopOff := stopOff_1605
    tpRatio := tpRatio_1605, rrRatio := rrRatio_1605, ptsSL := ptsSL_1605
    riskDollars := riskDollars_1605 != -1.0 ? riskDollars_1605 : riskDollars
    minRangePoints := minRangePointsOverride_1605 == -1 ? minRangePoints : minRangePointsOverride_1605
    maxRangePoints := maxRangePointsOverride_1605 == -1 ? maxRangePoints : maxRangePointsOverride_1605
    midpointStartTolerancePct := midpointStartProximityOverride_1605 == -1 ? midpointStartTolerancePct : midpointStartProximityOverride_1605

if not na(rangeSetSnapshot) and rangeSetSnapshot == "18:35" and enable1835
    rangeEndHour := rangeEndHour_1835, rangeEndMin := rangeEndMin_1835
    lookbackH := lookbackH_1835, lookbackM := lookbackM_1835
    exitDurH := exitDurH_1835, exitDurM := exitDurM_1835
    tradeLimit := tradeLimit_1835, entryOff := entryOff_1835, stopOff := stopOff_1835
    tpRatio := tpRatio_1835, rrRatio := rrRatio_1835, ptsSL := ptsSL_1835
    riskDollars := riskDollars_1835 != -1.0 ? riskDollars_1835 : riskDollars
    minRangePoints := minRangePointsOverride_1835 == -1 ? minRangePoints : minRangePointsOverride_1835
    maxRangePoints := maxRangePointsOverride_1835 == -1 ? maxRangePoints : maxRangePointsOverride_1835
    midpointStartTolerancePct := midpointStartProximityOverride_1835 == -1 ? midpointStartTolerancePct : midpointStartProximityOverride_1835

if not na(rangeSetSnapshot) and rangeSetSnapshot == "23:00" and enable2300
    rangeEndHour := rangeEndHour_2300, rangeEndMin := rangeEndMin_2300
    lookbackH := lookbackH_2300, lookbackM := lookbackM_2300
    exitDurH := exitDurH_2300, exitDurM := exitDurM_2300
    tradeLimit := tradeLimit_2300, entryOff := entryOff_2300, stopOff := stopOff_2300
    tpRatio := tpRatio_2300, rrRatio := rrRatio_2300, ptsSL := ptsSL_2300, vwOffset := vwOffset_2300
    riskDollars := riskDollars_2300 != -1.0 ? riskDollars_2300 : riskDollars
    minRangePoints := minRangePointsOverride_2300 == -1 ? minRangePoints : minRangePointsOverride_2300
    maxRangePoints := maxRangePointsOverride_2300 == -1 ? maxRangePoints : maxRangePointsOverride_2300
    midpointStartTolerancePct := midpointStartProximityOverride_2300 == -1 ? midpointStartTolerancePct : midpointStartProximityOverride_2300

tradeLimitSnapshot := tradeLimit

// declare each var separately
var float dayHigh = na
var float dayLow  = na
var bool placedTrades = false

// 2) Position Size Calculation
f_calcPositionSize(_entry, _stop) =>
    float priceDiff = math.abs(_entry - _stop)
    float tickCount = syminfo.mintick != 0 ? priceDiff / syminfo.mintick : priceDiff
    costPerContract = tickCount * syminfo.pointvalue
    contractCount = math.floor(riskDollars / costPerContract)
    if minimumOneContract and contractCount <= 0
        contractCount := 1
    contractCount

f_placeBracket(id, dir, entry, stop, limit, tradesCount, alreadyIssued, rangeConfirmed) =>
    qty = f_calcPositionSize(entry, stop)
    isLong = dir == strategy.long
    orderPlaced = false

    if qty > 0 and rangeConfirmed
        if not alreadyIssued
            labelText = "Trade " + str.tostring(tradesCount + 1) + " Issued"
            if showDebugLabels
                label.new(x=bar_index, y=dayHigh + syminfo.mintick * 100, text=labelText, style=label.style_label_down, color=color.orange, textcolor=color.white)   
            strategy.entry(id, dir, stop=entry, qty=qty)
            TradersPostDeluxe.SendEntryAlert(action=isLong ? TradersPostDeluxe.Action.buy : TradersPostDeluxe.Action.sell, quantity=qty, orderType=TradersPostDeluxe.OrderType.stop, takeProfit=limit, price=entry, stopLoss=stop, id=id)
            orderPlaced := true

        trailSize = math.abs(entry - stop) * 4
        trailTrigger = trailSize * trailStopTrigger / 100
        strategy.exit(id + "_Exit", from_entry=id, stop=stop, limit=trailStop ? na : limit, trail_points=trailStop ? trailTrigger : na, trail_offset=trailStop ? trailSize : na)

    orderPlaced

// update range times at start of session
if resetTimes
    yy = year(time, tzInput)
    mm = month(time, tzInput)
    dd = dayofmonth(time, tzInput)
    rangeEnd   := f_ts(yy, mm, dd, rangeEndHour, rangeEndMin)
    rangeStart := rangeEnd - (lookbackH * 3600000 + lookbackM * 60000)
    exitTime   := rangeEnd + (exitDurH * 3600000 + exitDurM * 60000)

    // ← INSERT these three lines **right here**:
    scoped_officialRangeStarted := false
    scoped_actualRangeStart     := na
    lastEntryBar                := -1

    resetTimes := false
//plot(na(rangeEnd) ? 0 : 1, title="Range End Initialized", color=color.green)
//plot(dayHigh, title="Day High", color=color.lime)
//plot(dayLow, title="Day Low", color=color.red)

inDefine   = time >= rangeStart and time < rangeEnd
inBreakoutWindow = time >= rangeEnd and time < exitTime

// ───────────────────────────────────────────────────────────────
// 2) ANCHORED VWAP and ATR
// ───────────────────────────────────────────────────────────────

float vwapSource = inDefine or inBreakoutWindow ? hlc3 : na
float sessionVWAP = ta.vwap(vwapSource)
float sessionVWMA = ta.vwma(close, vwapLen)
anchoredVWAP = vwapMode == "Session" ? (na(sessionVWAP) ? sessionVWMA : sessionVWAP) : sessionVWMA


// ───────────────────────────────────────────────────────────────
// 5.2 Quality Filters
// ───────────────────────────────────────────────────────────────

// === Filter Calculations ===
testEMA_now = ta.ema(close, emaSlopeLength)
testEMA_past = ta.ema(close[emaSlopeLookback], emaSlopeLength)
emaSlope = math.abs(testEMA_now - testEMA_past)
emaSlopeOk = emaSlope >= minEMASlope

sessionRSI = ta.rsi(close, rsiLength)
rsiValid = sessionRSI > rsiMin and sessionRSI < rsiMax

// === Rescale RSI to price chart
rsiOverlayBase = dayLow
rsiOverlayScale = (dayHigh - dayLow) / 100
validRange = inBreakoutWindow and not na(dayHigh) and not na(dayLow) and dayHigh != dayLow
rsiOverlay = (showRSIPlot and validRange) ? dayLow + sessionRSI * ((dayHigh - dayLow) / 100) : na

// === Session Filter Evaluation ===
filterVWAP = anchoredVWAP
vwapDistanceOk = na(filterVWAP) or math.abs(close - filterVWAP) > minVWAPDistance
rangeWidth = dayHigh - dayLow

rangeWidthOk = rangeWidth >= minRangePoints
//Adding support for max range as well as min range
rangeWidthMaxOk = maxRangePoints > 0 ? (rangeWidth <= maxRangePoints) : true


if time[1] < rangeEnd and time >= rangeEnd and not na(dayHigh) and not na(dayLow) and dayHigh != dayLow
    sessionValid := true
    sessionInvalidReason := ""

    if sev3Blocked
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "Sev 3 News Day"

    if useVWAPDistanceFilter and not vwapDistanceOk
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "VWAP"

    if minRangePoints > 0 and not rangeWidthOk
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "Min Range Size"

    if maxRangePoints > 0 and not rangeWidthMaxOk
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "Max Range Size"

    if useEMASlopeFilter and not emaSlopeOk
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "EMA"

    if useRSIFilter and not rsiValid
        sessionValid := false
        sessionBlocked := true
        sessionInvalidReason += (sessionInvalidReason != "" ? " | " : "") + "RSI"

    sessionFlagged := true

    // ───────────────────────────────────────────────────────────────
    // Visual: Label invalid sessions at the first post-range bar
    // ───────────────────────────────────────────────────────────────
    if showDebugLabels and time[1] < rangeEnd and time >= rangeEnd and not sessionValid
        label.new(bar_index, low, "Skipped: "+sessionInvalidReason, style=label.style_label_up, textcolor=color.black, color=color.yellow, xloc=xloc.bar_index, yloc=yloc.belowbar)


scoped_rangeMidpoint = not na(dayHigh) and not na(dayLow) ? (dayHigh + dayLow) / 2 : na
scoped_rangeWidth = not na(dayHigh) and not na(dayLow) ? (dayHigh - dayLow) : na
scoped_inBreakoutWindow = not na(exitTime) and time >= rangeEnd and time < exitTime and time > rangeStart
scoped_inDeferredBreakout = scoped_inBreakoutWindow and not scoped_officialRangeStarted
scoped_isNearMidpoint = not na(scoped_rangeMidpoint) and scoped_rangeWidth > 0 and math.abs(close - scoped_rangeMidpoint) <= (scoped_rangeWidth * midpointStartTolerancePct / 100)

// ───────────────────────────────────────────────
// 🔐 Scoped Breakout Activation Module (Safe, Traceable)
// ───────────────────────────────────────────────
if not sessionBlocked
    
    // === LEGITIMATE TRIGGERS
    //isValidMidpointTrigger = scoped_inBreakoutWindow and midpointStartTolerancePct > 0 and scoped_isNearMidpoint
    isValidMidpointTrigger   = scoped_inBreakoutWindow 
                         and midpointStartTolerancePct > 0 
                         and scoped_isNearMidpoint 
                         and barstate.isconfirmed //after so many issue, I finally make it require a bar close, flipping values mid bar etc
    isValidFallbackTrigger = scoped_inBreakoutWindow and midpointStartTolerancePct <= 0

    // ✅ Proximity activation
    if isValidMidpointTrigger and not scoped_officialRangeStarted
        scoped_officialRangeStarted := true
        scoped_actualRangeStart := time
        //label.new(bar_index, high+40, "Midpoint", style=label.style_label_down, color=color.purple, textcolor=color.white)

    // ✅ Fallback activation
    if isValidFallbackTrigger and not scoped_officialRangeStarted
        scoped_officialRangeStarted := true
        scoped_actualRangeStart := time
   
   //// 🔒 LOCKDOWN GUARD — prevent external or leaked triggers
   // if not (isValidMidpointTrigger or isValidFallbackTrigger)
   //     scoped_officialRangeStarted := false

    var label deferredStartLabel = na
    if showDebugLabels and scoped_inBreakoutWindow and not scoped_officialRangeStarted and time == rangeEnd and not na(dayHigh)
        deferredStartLabel := label.new(x=bar_index, y=dayHigh + syminfo.mintick * 40, text="Deferred Start", style=label.style_label_down, color=color.new(color.red, 85), textcolor=color.white)


//// === Visual Feedback: Red Box for invalid sessions: Yellow for Valid still
//if inBreakoutWindow and not drew and not na(dayHigh)
//    box.new(left=rangeEnd, top=dayHigh, right=exitTime, bottom=dayLow, xloc=xloc.bar_time, bgcolor=sessionValid ? color.new(color.yellow, 80) : color.new(color.red, 85), border_width=0), drew := true

if inBreakoutWindow and not drew and not na(dayHigh) and scoped_officialRangeStarted
    box.new(left=scoped_actualRangeStart, top=dayHigh, right=exitTime, bottom=dayLow, xloc=xloc.bar_time, bgcolor=sessionValid ? color.new(color.yellow, 80) : color.new(color.red, 85), border_width=0)
    drew := true

// ───────────────────────────────────────────────────────────────
// 3) DAILY HIGH/LOW & DRAW RANGE BOX
// ───────────────────────────────────────────────────────────────
if time[0] < rangeStart or time[0] > exitTime
    dayHigh := na
    dayLow  := na

if inDefine
    dayHigh := na(dayHigh) ? high : math.max(dayHigh, high)
    dayLow  := na(dayLow)  ? low  : math.min(dayLow, low)


if (not inBreakoutWindow)
    drew := false


// ───────────────────────────────────────────────────────────────
// 4) ENTRIES, OFFSETS & TPs
// ───────────────────────────────────────────────────────────────
longEntry   = dayHigh + entryOff
shortEntry  = dayLow  - entryOff
longStop    = dayLow  - stopOff
shortStop   = dayHigh + stopOff

rangeSize   = math.abs(longEntry - longStop)

tpSizeLive   = rangeSize * tpRatio
tpSizeSnap   = slType == "ATR" ? snapAdjTPSize : tpSizeLive
tpSizeUsed   = time < rangeEnd ? tpSizeLive : tpSizeSnap
tpSize       = tpSizeUsed

longTP      = longEntry  + tpSize
shortTP     = shortEntry - tpSize



// ───────────────────────────────────────────────────────────────
// 5) FLEXIBLE STOP LOSS OPTIONS
// ───────────────────────────────────────────────────────────────

longStop := switch slType
    "RR"     => longEntry - tpSize * rrRatio                
    "Points" => longEntry - ptsSL
    "VWAP"   => anchoredVWAP - vwOffset
    "ATR"    => longEntry - math.min(atrUsed, atrGlobal * maxATRMult)
    => longStop
             

shortStop := switch slType
    "RR"     => shortEntry + tpSize * rrRatio                 
    "Points" => shortEntry + ptsSL
    "VWAP"   => anchoredVWAP + vwOffset
    "ATR"    => shortEntry - math.min(atrUsed, atrGlobal * maxATRMult)
    => shortStop

stopSize = longEntry - longStop
isPriceInsideRange() =>
   close[0] < longEntry and close[0] > shortEntry


// ───────────────────────────────────────────────────────────────
// 5.1 Daily and Session P&L and Trade Halting
// ───────────────────────────────────────────────────────────────

// Session PnL Calculation
f_calcSessionPL(_startTime, _endTime) =>
    var float totalPL = 0.0
    if not na(_startTime) and not na(_endTime) and strategy.closedtrades > 0
        totalPL := 0.0
        for i = 0 to strategy.closedtrades - 1
            float eTime = strategy.closedtrades.entry_time(i)
            if eTime >= _startTime and eTime <= _endTime
                float entryPrice = strategy.closedtrades.entry_price(i)
                float exitPrice = strategy.closedtrades.exit_price(i)
                float tradeQty = math.abs(strategy.closedtrades.size(i))
                bool isLong = strategy.closedtrades.size(i) > 0
                float points = isLong ? (exitPrice - entryPrice) : (entryPrice - exitPrice)
                float dollars = points / syminfo.mintick / 4 * 2 * tradeQty
                totalPL := totalPL + dollars
    totalPL

f_calcDayPL() =>
    var float totalDayPL = 0.0
    yy = year(time, tzInput)
    mm = month(time, tzInput)
    dd = dayofmonth(time, tzInput)

    // Calculate today's 15:00
    dayStart = timestamp(tzInput, yy, mm, dd, 15, 0)

    // If current time is before today's 15:00, get prior day's 15:00 using timestamp math
    if time < dayStart
        dayStart := dayStart - 86400000  // Subtract 1 day in milliseconds

    totalDayPL := f_calcSessionPL(dayStart, time)

dayPL = f_calcDayPL()

var bool tradingHalted = false

// Evaluate trading halt condition
if maxDailyLoss > 0 and dayPL < -maxDailyLoss
    tradingHalted := true

if haltAfterProfit and dayPL > 0
    tradingHalted := true
    
// Reset flag at next global open (15:00)
yy = year(time, tzInput)
mm = month(time, tzInput)
dd = dayofmonth(time, tzInput)
globalOpen = timestamp(tzInput, yy, mm, dd, 15, 0)
if time >= globalOpen and time[1] < globalOpen
    tradingHalted := false



// ───────────────────────────────────────────────────────────────
// 6) ENTRY & EXIT LOGIC (Dual Lock: Session Validity + Trade Limit)
// ───────────────────────────────────────────────────────────────
var tradesToday = 0
var closedTrades = 0
var int waitUntilBar = na
var int postTradeLock = na

// Reset state before session start
if time[0] < rangeStart
    placedTrades := false
    tradesToday := 0
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    // ◄◄◄ reset our trade-number gating and emergency exit each new session
    lastIssuedTradeNumber := 0
    emergencyExitSent      := false
    earlyExitFired := false


// Reset just after session ends ✅ Executes once, on the first bar after the session ends - Ideal for resetting session state (e.g., flags, counters, UI values)
if time[1] < exitTime and time[0] >= exitTime
    tradesToday := 0
    placedTrades := false
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    issuedLongOrder := false
    issuedShortOrder := false
    // ◄◄◄ clear our trade-number gating for next session
    lastIssuedTradeNumber := 0
    emergencyExitSent      := false

idLong = "Long"
idShort = "Short"

canceledLong = false
canceledShort = false

// Emergency exit block — must run BEFORE entry logic
if barstate.isrealtime and not emergencyExitSent and bar_index == emergencyExitBar
    strategy.cancel(idLong)
    strategy.cancel(idLong + "_Exit")
    strategy.cancel(idShort)
    strategy.cancel(idShort + "_Exit")
    strategy.close_all(comment="Emergency Market Exit")
    TradersPostDeluxe.SendExitAlert(price=close)
    if showDebugLabels
        label.new(bar_index,low - syminfo.mintick * 40, "Emergency Exit Fired", style=label.style_label_down, color=color.fuchsia, textcolor=color.white)
    emergencyExitSent := true

// Evaluate entry conditions each bar
bool currentPriceIsInsideRange_check = isPriceInsideRange()
bool allConditionsMetForTradePlacement = not tradingHalted and
                                         sessionValid and
                                         strategy.position_size == 0 and
                                         not placedTrades and
                                         (na(waitUntilBar) or bar_index >= waitUntilBar) and
                                         (na(postTradeLock) or bar_index >= postTradeLock) and
                                         currentPriceIsInsideRange_check and
                                         (tradeLimit == 0 or tradesToday < tradeLimit) and
                                         (not requireMidpointReturn or tradesToday == 0 or scoped_isNearMidpoint)  
                                  
// Allow re-arming when we come back to midpoint during deferred starts
if scoped_inBreakoutWindow and midpointStartTolerancePct > 0 and scoped_isNearMidpoint
    placedTrades := false

if inBreakoutWindow and scoped_officialRangeStarted
    // 🔒 Session Invalid Lock
    if not sessionValid and not placedTrades
        strategy.cancel(idLong)
        strategy.cancel(idShort)
        placedTrades := true

    // 🔒 Trade Limit Lock
    if tradesToday >= tradeLimit and not placedTrades
        strategy.cancel(idLong)
        strategy.cancel(idShort)
        placedTrades := true

    // Cancel opposing orders while in position (preserve original unless aggressiveFlip is ON)
    if strategy.position_size > 0 and not aggressiveFlip
        strategy.cancel(idShort)
        canceledShort := true
    if strategy.position_size < 0 and not aggressiveFlip
        strategy.cancel(idLong)
        canceledLong := true

    // ── ENTRY PLACEMENT (trade-number gating) ──
    int nextTradeNum = tradesToday + 1
    if allConditionsMetForTradePlacement and bar_index != lastEntryBar and nextTradeNum > lastIssuedTradeNumber
        lastEntryBar := bar_index
        // Long bracket
        if f_placeBracket(idLong, strategy.long, longEntry, longStop, longTP, tradesToday, false, true)
            lastIssuedTradeNumber := nextTradeNum
        // Short bracket
        if f_placeBracket(idShort, strategy.short, shortEntry, shortStop, shortTP, tradesToday, false, true)
            lastIssuedTradeNumber := nextTradeNum

    // Auto-clear the post-trade lock once elapsed
    if not na(postTradeLock) and bar_index >= postTradeLock
        postTradeLock := na
        issuedLongOrder := false
        issuedShortOrder := false

// ── CLOSED TRADE HANDLER: split PROFIT vs STOP, and respect aggressiveFlip toggle ──
if strategy.closedtrades > closedTrades
    closedTrades := strategy.closedtrades
    tradesToday := tradesToday + 1
    lastIssuedTradeNumber := tradesToday
    placedTrades := false

    float _exit  = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float _entry = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    bool  _long  = strategy.closedtrades.size(strategy.closedtrades - 1) > 0
    bool  wasProfit = _long ? (_exit > _entry) : (_exit < _entry)

    if wasProfit or not aggressiveFlip
        // ► PROFIT (or toggle OFF): original cleanup path + non-overlapping label at low-120
        if not earlyExitFired
            emergencyExitBar := bar_index + 1
            emergencyExitSent := false
            waitUntilBar := bar_index + 1
            postTradeLock := bar_index + 3
        issuedLongOrder := false
        issuedShortOrder := false
        strategy.cancel(idLong)
        strategy.cancel(idLong + "_Exit")
        strategy.cancel(idShort)
        strategy.cancel(idShort + "_Exit")
        scoped_officialRangeStarted := false
        scoped_actualRangeStart := na
        lastEntryBar := -1
        
        if showDebugLabels
            string _cleanupLabel = wasProfit ? "Exit: Profit Complete. Reset" : "Exit: Stop Complete Reset"
            label.new(bar_index, low - syminfo.mintick * 120, _cleanupLabel, style=label.style_label_down, color=color.teal, textcolor=color.white)

    else
        // ► STOP (toggle ON): keep opposite side eligible immediately + non-overlapping label at high+120
        waitUntilBar := bar_index + 1
        postTradeLock := bar_index + 1
        issuedLongOrder := false
        issuedShortOrder := false
        if _long
            strategy.cancel(idLong)
            strategy.cancel(idLong + "_Exit")
        else
            strategy.cancel(idShort)
            strategy.cancel(idShort + "_Exit")
        if showDebugLabels
            label.new(bar_index, high + syminfo.mintick * 120, "Exit: DBO Stop‑Out → Opposite Armed", style=label.style_label_down, color=color.teal, textcolor=color.white)

    // (Optional) immediate lock clears if already elapsed
    if not na(waitUntilBar) and bar_index >= waitUntilBar
        waitUntilBar := na
    if not na(postTradeLock) and bar_index >= postTradeLock
        postTradeLock := na


//If we are nearing the end of session and are positive, bail.
earlyExitTime = exitTime - earlyExitMinutes * 60000
if not earlyExitFired and tradesToday > 0 and time >= earlyExitTime and time < exitTime and strategy.position_size != 0
    float avgPrice = strategy.position_avg_price
    bool isLongPos = strategy.position_size > 0
    //If you’re long (isLongPos == true), it tests close > avgPrice.
    //If you’re short (isLongPos == false), it tests close < avgPrice.
    bool inProfit  = isLongPos ? close > avgPrice : close < avgPrice
    if inProfit
        strategy.close_all(comment="Early Positive Exit")
        TradersPostDeluxe.SendExitAlert(price=close)
        if showDebugLabels
            label.new(bar_index, low - syminfo.mintick * 40, "Early Exit Fired", style=label.style_label_down, color=color.green, textcolor=color.white)
        earlyExitFired := true

// Cleanup: executes on every bar at or after exit
if time[0] >= exitTime
    strategy.cancel(idShort)
    strategy.cancel(idShort + "_Exit")    // also cancel bracket exits
    strategy.cancel(idLong)
    strategy.cancel(idLong  + "_Exit")    // also cancel bracket exits
    strategy.close_all(comment="EOS")
    //label.new(bar_index, high + syminfo.mintick * 80, "End of Session Exit", style=label.style_label_down, color=color.orange, textcolor=color.white)
    resetTimes := true
// ───────────────────────────────────────────────────────────────
// 7) PLOTS & MARKERS
// ───────────────────────────────────────────────────────────────
plot(longEntry,  title="Long Entry",  style=plot.style_linebr, color=color.aqua)
plot(shortEntry, title="Short Entry", style=plot.style_linebr, color=color.aqua)
plot(longTP,    title="Long TP",    style=plot.style_linebr,   color=color.green)
plot(shortTP,   title="Short TP",   style=plot.style_linebr,   color=color.green)
plot(longStop, style=plot.style_linebr, color=color.yellow, title="Long Stop")
plot(shortStop, style=plot.style_linebr, color=color.orange, title="Short Stop")
plot(tpSize / syminfo.mintick, title="TP Ticks", style=plot.style_linebr, color=color.green, display=display.data_window)
plot(stopSize  / syminfo.mintick, title="Stop Ticks", style=plot.style_linebr, color=color.red, display=display.data_window)
plot(longEntry - shortEntry, title="Range Size", style=plot.style_linebr, color=color.yellow, display=display.data_window)
plot(f_calcPositionSize(longEntry, longStop), title="Position Size", style=plot.style_linebr, color=color.orange, display=display.data_window)
plot(inBreakoutWindow ? tradeLimit : na, title="Active Trade Limit", color=color.orange, display=display.data_window)
plot(showVWAPComponents and (inDefine or inBreakoutWindow) ? sessionVWMA : na, title="Session VWMA", style=plot.style_linebr, color=color.orange)
plot(showVWAPComponents and (inDefine or inBreakoutWindow) ? sessionVWAP : na, title="Session VWAP", style=plot.style_linebr, color=color.purple)

// === Data Window display only for filters
plot(emaSlope, title="EMA Slope", color=color.orange, display=display.data_window)
plot(dayHigh - dayLow, title="Range Width", color=color.blue, display=display.data_window)
plot(minRangePoints, title="Min Allowed Range", color=color.blue, display=display.data_window)
plot(maxRangePoints, title="Max Allowed Range", color=color.blue, display=display.data_window)
plot(math.abs(close - ta.vwap), title="VWAP Distance", color=color.purple, display=display.data_window)
plot(sessionRSI, title="RSI Raw", color=color.green, display=display.data_window)
plot((showRSIPlot and validRange) ? rsiOverlay : na, title="RSI (Overlay)", color=color.green, linewidth=1, style=plot.style_linebr)


// === Data Window Logging of Filter Status ===
plot(sessionValid ? 1 : 0, title="Session Valid", color=color.gray, display=display.data_window)
plot(useVWAPDistanceFilter ? (vwapDistanceOk ? 1 : 0) : na, title="VWAP OK", color=color.purple, display=display.data_window)
plot(useEMASlopeFilter ? (emaSlopeOk ? 1 : 0) : na, title="EMA Slope OK", color=color.orange, display=display.data_window)
plot(useRSIFilter ? (rsiValid ? 1 : 0) : na, title="RSI OK", color=color.green, display=display.data_window)
plotchar(na(sessionInvalidReason) ? na : 1, title="Session Reason Exists", char='⟶', location=location.top, display=display.data_window)

// ─────────────────────────────
// 📊 Data Window Debug Plots for Deferred Start
// ─────────────────────────────
plot(scoped_officialRangeStarted ? 1 : 0, title="Scoped Official Range Started", color=color.purple, display=display.data_window)
plot(midpointStartTolerancePct > 0 ? 1 : 0, title="Deferred Start Proximity Filter Enabled", color=color.fuchsia, display=display.data_window)
plot(midpointStartTolerancePct, title = "Midpoint Proximity Percent %", display = display.data_window, color = na)
plot(scoped_inBreakoutWindow ? 1 : 0, title="Scoped In Breakout Window", color=color.red, display=display.data_window)
plot(scoped_inDeferredBreakout ? 1 : 0, title="Scoped Deferred Breakout", color=color.orange, display=display.data_window)
plot(scoped_isNearMidpoint ? 1 : 0, title="Scoped Near Midpoint", color=color.yellow, display=display.data_window)
plot(scoped_rangeMidpoint, title="Scoped Range Midpoint", color=color.gray, display=display.data_window)
plot(scoped_rangeWidth, title="Scoped Range Width", color=color.blue, display=display.data_window)
plot(math.abs(close - scoped_rangeMidpoint), title="Midpoint Distance", color=color.fuchsia)
plot(scoped_rangeWidth * midpointStartTolerancePct / 100, title="Allowed Deviation", color=color.teal)


// ────────────────────────────────────────────────────────────
// Map sessionInvalidReason → numeric code, and plot to Data Window
// (must be at top–level scope, not nested inside an if)
// ────────────────────────────────────────────────────────────
// 1=Range too narrow, 2=Too close to VWAP, 3=EMA slope too flat, 4=RSI out of bounds
reasonCode = sessionInvalidReason == "Range too narrow"    ? 1 :
             sessionInvalidReason == "Too close to VWAP"   ? 2 :
             sessionInvalidReason == "EMA slope too flat"  ? 3 :
             sessionInvalidReason == "RSI out of bounds"    ? 4 : 0
plot(reasonCode, title="Session Invalid Reason", display=display.data_window)

// ───────────────────────────────────────────────────────────────
// 8) PROFIT/LOSS LABELS ON TRADE EXIT & SESSION INFO BOX
// ───────────────────────────────────────────────────────────────
var float lastEntryPrice = na
var bool lastWasLong = false
var bool lastWasLongValid = false
var int lastClosedTrades = 0
var float plPoints = na
var float qty = na

var float debugLastEntry = na
var bool debugLastWasLong = false
var bool debugTradeArmed = false

showSessionBox = input.bool(true, "Show Session Info Box", tooltip="Displays session stats", group="Display Settings")

// Tick to point and $ conversion helpers
f_ticksToPoints(_raw) => syminfo.mintick != 0 ? (_raw / syminfo.mintick) / 4 : _raw
f_dollars(_pts, _qty) => _pts * 2 * math.abs(_qty)

// If armed from bracket logic
if debugTradeArmed and na(lastEntryPrice)
    lastEntryPrice := debugLastEntry
    lastWasLong := debugLastWasLong
    lastWasLongValid := true

// Detect trade closed
if strategy.closedtrades > lastClosedTrades
    lastClosedTrades := strategy.closedtrades
    float exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    qty := strategy.closedtrades.size(strategy.closedtrades - 1)

    if showPnLIndicators == "Yes" and qty != 0 and not na(entryPrice) and not na(exitPrice)
        bool isLong = qty > 0
        float rawPL = isLong ? (exitPrice - entryPrice) : (entryPrice - exitPrice)
        plPoints := f_ticksToPoints(rawPL)
        float dollarPL = f_dollars(plPoints, qty)

        string labelText = "P/L: " + str.tostring(plPoints, "#.##") + " pts, $" + str.tostring(dollarPL, "#.##") + " [" + (isLong ? "Long" : "Short") + "]"
        bool isProfit = plPoints > 0
        color labelColor = isProfit ? color.green : color.red
        //float yOffset = syminfo.mintick * 75
        //bool placeAbove = (isLong and isProfit) or (not isLong and not isProfit)
        //float yPos = placeAbove ?  (high + yOffset) : (low - yOffset)
        //labelStyle = placeAbove ? label.style_label_down : label.style_label_up
        // Place profits above the bar, losses below (prevents overlap on same bar)
        float yOffsetProfit = syminfo.mintick * 90
        float yOffsetLoss   = syminfo.mintick * 90
        bool  placeAbove    = isProfit
        float yPos          = isProfit ? (high + yOffsetProfit) : (low - yOffsetLoss)
        labelStyle          = isProfit ? label.style_label_down : label.style_label_up
        label.new(bar_index, yPos, labelText, style=labelStyle, color=labelColor, textcolor=color.white, size=size.small)

    lastEntryPrice := na
    lastWasLongValid := false
    debugTradeArmed := false

plot(plPoints, title="PL Points", display=display.data_window, color=color.green)
plot(qty, title="Last Trade Qty", display=display.data_window, color=color.orange)
plot((not na(rangeStart) and not na(exitTime) and time >= rangeStart and time <= exitTime) ? f_calcSessionPL(rangeStart, exitTime) : na, title="Session PnL ($)", color=color.fuchsia, display=display.data_window)

var float sessionPL_snapshot = na
var int tradesToday_snapshot = na
var table sessionTable = na
f_getPLTextColor(_pl) => _pl > 0 ? color.green : _pl < 0 ? color.red : color.white

// 🛡️ Snapshot only when trades are present and during session window
if time >= rangeStart and time <= exitTime and tradesToday > 0
    sessionPL_snapshot := f_calcSessionPL(rangeStart, exitTime)
    tradesToday_snapshot := tradesToday



// ───────────────────────────────────────────────────────────────
// 8.1) Trade and Session Cleanup
// ───────────────────────────────────────────────────────────────


var bool didSessionEnd = false
// Single-line label showing the boolean as text
//label.new(bar_index, high + syminfo.mintick*20, didSessionEnd ? "true" : "false", style=label.style_label_down, color=color.teal, textcolor=color.white)

dayOfWeekNow = dayofweek(time)

if time[1] < exitTime and time >= exitTime and not didSessionEnd and not earlyExitFired and dayOfWeekNow != dayofweek.sunday

    if showDebugLabels
        label.new(bar_index, high + 40, "Exit Alert Fired", style=label.style_label_down, color=color.fuchsia, textcolor=color.white)
    TradersPostDeluxe.SendExitAlert(price = close)
    didSessionEnd := true

if didSessionEnd and bar_index > bar_index[1]
    tradesToday := 0
    placedTrades := false
    closedTrades := strategy.closedtrades
    waitUntilBar := na
    resetTimes := true
    didSessionEnd := false
    sessionBlocked :=false
    issuedLongOrder  := false
    issuedShortOrder := false

if showSessionBox and not na(sessionPL_snapshot)
    table.delete(sessionTable[1])
    sessionTable := table.new(position=position.top_right, columns=2, rows=6, bgcolor=color.new(color.blue, 90), border_width=1, border_color=color.blue)

    //label for display box to last completed to live session
    var string lastSessionLabel = na
    var int lastTradeLimitSnapshot = na
    if time[1] < rangeStart and time >= rangeStart
        lastSessionLabel := rangeSetSnapshot
        lastTradeLimitSnapshot := tradeLimit
    bool isLiveSession = barstate.isrealtime and time >= rangeStart and time <= exitTime
    string contextText = not na(lastSessionLabel) ? lastSessionLabel : "N/A"


    table.cell(sessionTable, 0, 0, text="Context", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 0, text=contextText, bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 0, 1, text="Max Trades", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 1, text=str.tostring(lastTradeLimitSnapshot), bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 0, 2, text="Trades Today", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 2, text=str.tostring(tradesToday_snapshot), bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 0, 3, text="Session Risk", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 3, text="$" + str.tostring(riskDollars, "#.##"), bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 0, 4, text="Session PnL", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 4, text="$" + str.tostring(sessionPL_snapshot, "#.##"), bgcolor=color.navy, text_color=f_getPLTextColor(sessionPL_snapshot))
    table.cell(sessionTable, 0, 5, text="Day PnL", bgcolor=color.navy, text_color=color.white)
    table.cell(sessionTable, 1, 5, text="$" + str.tostring(dayPL, "#.##"), bgcolor=color.navy, text_color=f_getPLTextColor(dayPL))


// ───────────────────────────────────────────────────────────────
// 9) STRATEGY-CONFIRMED ENTRY & EXIT ALERTS (with full JSON)
// ───────────────────────────────────────────────────────────────

// ───────────────────────
// Exit Alerts (after strategy exit)
// ───────────────────────
if strategy.closedtrades > strategy.closedtrades[1]
    float exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)
    float entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)
    string exitType = exitPrice > entryPrice ? "target" : "stop"
    TradersPostDeluxe.SendExitAlert(price = exitPrice)

// Debug Plots (Line ~900)
plot(issuedLongOrder ? 1 : 0, title="Debug: Issued Long Order", color=color.blue, display=display.data_window)
plot(issuedShortOrder ? 1 : 0, title="Debug: Issued Short Order", color=color.red, display=display.data_window)

plotshape(time >= exitTime and (issuedLongOrder or issuedShortOrder) and not didSessionEnd and barstate.islastconfirmedhistory
     ? true : false,
     title="EOS Debug", location=location.abovebar,
     style=shape.labeldown, text="EOS")